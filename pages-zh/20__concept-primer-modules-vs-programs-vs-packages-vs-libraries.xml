<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>概念入门</title>
<subtitle>模块 vs 程序 vs 包 vs 库</subtitle>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>概述</title>
<simpara><link xl:href="19__modules-and-imports-root-builtin-discovery.xml">第19章</link>映射了编译器的模块图；本章命名这些模块可以扮演的角色，以便您知道文件何时仅仅是助手，何时升级为程序，以及何时成为可重用包或库的核心。</simpara>
<simpara>我们还将预览Zig CLI如何为消费者注册模块，为<link xl:href="21__zig-init-and-package-metadata.xml">第21章</link>和<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/build.zig">build.zig</link>中的构建图编写奠定基础。</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>区分模块、程序、包和库，并解释Zig在编译过程中如何对待每种类型。</simpara>
</listitem>
<listitem>
<simpara>使用<literal>--dep</literal>和<literal>-M</literal>标志（及其构建图等价物）为消费者注册命名模块。</simpara>
</listitem>
<listitem>
<simpara>在开始新构件或重构现有构件时，应用实用检查表选择正确的单元。<link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="vocabulary">
<title>建立共享词汇表</title>
<simpara><emphasis role="strong">在编写构建脚本或注册依赖项之前，请确定一致的语言：</emphasis>在Zig中，<emphasis role="strong">模块</emphasis>是由<literal>@import</literal>返回的任何编译单元，<emphasis role="strong">程序</emphasis>是具有入口点的模块图，<emphasis role="strong">包</emphasis>捆绑模块加元数据，而<emphasis role="strong">库</emphasis>是旨在重用而没有根<literal>main</literal>的包。
<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/start.zig">start.zig</link></simpara>
<section xml:id="modules-programs">
<title>实践中的模块和程序</title>
<simpara>此演示从一个根模块开始，该模块导出库的清单但也声明<literal>main</literal>，因此运行时将图视为程序，而助手模块内省公共符号以保持术语诚实。<link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc - include::example$chapters-data/code/20__concept-primer-modules-vs-programs-vs-packages-vs-libraries/module_role_map.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run module_role_map.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">== Module vocabulary demo ==
root exports main? yes → treat as program
root public surface: 3 declarations
library 'widgetlib' v0.1.0 exports main? no
library modules listed: 2
intent cheat sheet:
  - ship a CLI entry point → program
  - publish reusable code → package + library
  - share type definitions inside a workspace → module</programlisting>
</para>
</formalpara>
<tip>
<simpara>保持根导出最小化，并在一个地方（此处为<literal>PublicSurface</literal>）记录它们，以便助手模块可以在不依赖未记录的全局变量的情况下推理意图。</simpara>
</tip>
</section>
<section xml:id="modules-programs-entrypoints">
<title>底层原理：入口点和程序</title>
<simpara>模块图表现为程序还是库取决于它最终是否导出入口点符号。<literal>std.start</literal>根据平台、链接模式和几个<literal>builtin</literal>字段决定导出哪个符号，因此<literal>main</literal>的存在只是故事的一部分。</simpara>
<section xml:id="_entry_point_symbol_table">
<title>入口点符号表</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">平台</entry>
<entry align="left" valign="top">链接模式</entry>
<entry align="left" valign="top">条件</entry>
<entry align="left" valign="top">导出符号</entry>
<entry align="left" valign="top">处理函数</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>POSIX/Linux</simpara></entry>
<entry align="left" valign="top"><simpara>可执行文件</simpara></entry>
<entry align="left" valign="top"><simpara>默认</simpara></entry>
<entry align="left" valign="top"><simpara><literal>_start</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>_start()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>POSIX/Linux</simpara></entry>
<entry align="left" valign="top"><simpara>可执行文件</simpara></entry>
<entry align="left" valign="top"><simpara>链接libc</simpara></entry>
<entry align="left" valign="top"><simpara><literal>main</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>main()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
<entry align="left" valign="top"><simpara>可执行文件</simpara></entry>
<entry align="left" valign="top"><simpara>默认</simpara></entry>
<entry align="left" valign="top"><simpara><literal>wWinMainCRTStartup</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>WinStartup()</literal> / <literal>wWinMainCRTStartup()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
<entry align="left" valign="top"><simpara>动态库</simpara></entry>
<entry align="left" valign="top"><simpara>默认</simpara></entry>
<entry align="left" valign="top"><simpara><literal>_DllMainCRTStartup</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>_DllMainCRTStartup()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>UEFI</simpara></entry>
<entry align="left" valign="top"><simpara>可执行文件</simpara></entry>
<entry align="left" valign="top"><simpara>默认</simpara></entry>
<entry align="left" valign="top"><simpara><literal>EfiMain</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>EfiMain()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WASI</simpara></entry>
<entry align="left" valign="top"><simpara>可执行文件（命令）</simpara></entry>
<entry align="left" valign="top"><simpara>默认</simpara></entry>
<entry align="left" valign="top"><simpara><literal>_start</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>wasi_start()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WASI</simpara></entry>
<entry align="left" valign="top"><simpara>可执行文件（反应器）</simpara></entry>
<entry align="left" valign="top"><simpara>默认</simpara></entry>
<entry align="left" valign="top"><simpara><literal>_initialize</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>wasi_start()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WebAssembly</simpara></entry>
<entry align="left" valign="top"><simpara>独立环境</simpara></entry>
<entry align="left" valign="top"><simpara>默认</simpara></entry>
<entry align="left" valign="top"><simpara><literal>_start</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>wasm_freestanding_start()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WebAssembly</simpara></entry>
<entry align="left" valign="top"><simpara>链接libc</simpara></entry>
<entry align="left" valign="top"><simpara>默认</simpara></entry>
<entry align="left" valign="top"><simpara><literal>__main_argc_argv</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>mainWithoutEnv()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OpenCL/Vulkan</simpara></entry>
<entry align="left" valign="top"><simpara>内核</simpara></entry>
<entry align="left" valign="top"><simpara>默认</simpara></entry>
<entry align="left" valign="top"><simpara><literal>main</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>spirvMain2()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MIPS</simpara></entry>
<entry align="left" valign="top"><simpara>任意</simpara></entry>
<entry align="left" valign="top"><simpara>默认</simpara></entry>
<entry align="left" valign="top"><simpara><literal>__start</literal></simpara></entry>
<entry align="left" valign="top"><simpara>（与<literal>_start</literal>相同）</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">来源：</emphasis> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/start.zig">start.zig</link></simpara>
</section>
<section xml:id="_compile_time_entry_point_logic">
<title>编译时入口点逻辑</title>
<simpara>在编译时，<literal>std.start</literal>在<literal>builtin.output_mode</literal>、<literal>builtin.os</literal>、<literal>link_libc</literal>和目标架构上运行一个小决策树，以导出上述符号中的一个：</simpara>
<literallayout class="monospaced">graph TB
  Start["comptime block&lt;br/&gt;(start.zig:28)"]
  CheckMode["Check builtin.output_mode"]
  CheckSimplified["simplified_logic?&lt;br/&gt;(stage2 backends)"]

  CheckLinkC["link_libc or&lt;br/&gt;object_format == .c?"]
  CheckWindows["builtin.os == .windows?"]
  CheckUEFI["builtin.os == .uefi?"]
  CheckWASI["builtin.os == .wasi?"]
  CheckWasm["arch.isWasm() &amp;&amp;&lt;br/&gt;os == .freestanding?"]

  ExportMain["@export(&amp;main, 'main')"]
  ExportWinMain["@export(&amp;WinStartup,&lt;br/&gt;'wWinMainCRTStartup')"]
  ExportStart["@export(&amp;_start, '_start')"]
  ExportEfi["@export(&amp;EfiMain, 'EfiMain')"]
  ExportWasi["@export(&amp;wasi_start,&lt;br/&gt;wasm_start_sym)"]
  ExportWasmStart["@export(&amp;wasm_freestanding_start,&lt;br/&gt;'_start')"]

  Start --&gt; CheckMode
  CheckMode --&gt;|".Exe or has main"| CheckSimplified
  CheckSimplified --&gt;|"true"| Simple["Simplified logic&lt;br/&gt;(lines 33-51)"]
  CheckSimplified --&gt;|"false"| CheckLinkC

  CheckLinkC --&gt;|"yes"| ExportMain
  CheckLinkC --&gt;|"no"| CheckWindows
  CheckWindows --&gt;|"yes"| ExportWinMain
  CheckWindows --&gt;|"no"| CheckUEFI
  CheckUEFI --&gt;|"yes"| ExportEfi
  CheckUEFI --&gt;|"no"| CheckWASI
  CheckWASI --&gt;|"yes"| ExportWasi
  CheckWASI --&gt;|"no"| CheckWasm
  CheckWasm --&gt;|"yes"| ExportWasmStart
  CheckWasm --&gt;|"no"| ExportStart</literallayout>
<simpara><emphasis role="strong">来源：</emphasis> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/start.zig">lib/std/start.zig:28-100</link></simpara>
</section>
</section>
<section xml:id="library-manifests">
<title>库清单和内部重用</title>
<simpara>记录在<literal>pkg/manifest.zig</literal>中的清单模拟了最终成为包元数据的内容：名称、语义版本、模块列表以及明确声明不导出入口点。</simpara>
</section>
</chapter>
<chapter xml:id="packages">
<title>包作为分发契约</title>
<simpara>包是生产者和消费者之间的协议：生产者注册模块名称并暴露元数据；消费者导入这些名称而不接触文件系统路径，信任构建图提供正确的代码。</simpara>
<section xml:id="registering-modules">
<title>使用 -M 和 --dep 注册模块</title>
<simpara>Zig 0.15.2 用 <literal>-M</literal>（模块定义）和 <literal>--dep</literal>（导入表条目）替换了旧的 <literal>--pkg-begin/--pkg-end</literal> 语法，反映了 <literal>std.build</literal> 在连接工作区时的做法（参见 <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build.zig">Build.zig</link>）。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc - include::example$chapters-data/code/20__concept-primer-modules-vs-programs-vs-packages-vs-libraries/package_overlay_demo.zig[]</programlisting>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc - include::example$chapters-data/code/20__concept-primer-modules-vs-programs-vs-packages-vs-libraries/overlay_widget.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe --dep overlay -Mroot=package_overlay_demo.zig -Moverlay=overlay_widget.zig -femit-bin=overlay_demo &amp;&amp; ./overlay_demo</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">registered package: overlay
role advertised: library package
optimize mode: Debug
target os: linux
resolved module namespace: overlay → pub decls: 2</programlisting>
</para>
</formalpara>
<important>
<simpara><literal>--dep overlay</literal> 必须在使用它的模块声明之前；否则导入表将保持为空，编译器无法解析 <literal>@import("overlay")</literal>。<footnote><simpara><literal>--dep</literal> 为下一个 <literal>-M</literal> 条目写入依赖项列表，反映了 <literal>std.build.Module.addImport</literal> 在模块实例化之前排队依赖项的方式。</simpara></footnote></simpara>
</important>
<section xml:id="_case_study_compiler_bootstrap_command">
<title>案例研究：编译器引导命令</title>
<simpara>Zig 编译器本身也是使用相同的 <literal>-M</literal>/<literal>--dep</literal> 机制构建的。在从 <literal>zig1</literal> 引导到 <literal>zig2</literal> 的过程中，命令行连接多个命名模块及其依赖项：</simpara>
<screen>zig1 &lt;lib-dir&gt; build-exe -ofmt=c -lc -OReleaseSmall \
  --name zig2 \
  -femit-bin=zig2.c \
  -target &lt;host-triple&gt; \
  --dep build_options \
  --dep aro \
  -Mroot=src/main.zig \
  -Mbuild_options=config.zig \
  -Maro=lib/compiler/aro/aro.zig</screen>
<simpara>在这里，每个 <literal>--dep</literal> 行都会为下一个 <literal>-M</literal> 模块声明排队依赖项，就像在小型覆盖演示中一样，但规模是编译器级别的。</simpara>
</section>
<section xml:id="_from_cli_flags_to_build_graph">
<title>从CLI标志到构建图</title>
<simpara>一旦您从临时 <literal>zig build-exe</literal> 命令转移到 <literal>build.zig</literal> 文件，相同的概念会重新出现在构建图中作为 <literal>std.Build</literal> 和 <literal>std.Build.Module</literal> 节点。下图总结了原生构建系统的入口点如何连接编译器编译、测试、文档和安装。</simpara>
<literallayout class="monospaced">graph TB
  subgraph "Build Entry Point"
    BUILD_FN["build(b: *std.Build)"] --&gt; OPTIONS["Parse Build Options"]
    OPTIONS --&gt; COMPILER["addCompilerStep()"]
    OPTIONS --&gt; TEST_SETUP["Test Suite Setup"]
    OPTIONS --&gt; DOCS["Documentation Steps"]
  end

  subgraph "Compiler Compilation"
    COMPILER --&gt; EXE["std.Build.CompileStep&lt;br/&gt;(zig executable)"]
    EXE --&gt; COMPILER_MOD["addCompilerMod()"]
    EXE --&gt; BUILD_OPTIONS["build_options&lt;br/&gt;(generated config)"]
    EXE --&gt; LLVM_INTEGRATION["LLVM/Clang/LLD&lt;br/&gt;linking"]
  end

  subgraph "Test Steps"
    TEST_SETUP --&gt; TEST_CASES["test-cases&lt;br/&gt;tests.addCases()"]
    TEST_SETUP --&gt; TEST_MODULES["test-modules&lt;br/&gt;tests.addModuleTests()"]
    TEST_SETUP --&gt; TEST_UNIT["test-unit&lt;br/&gt;compiler unit tests"]
    TEST_SETUP --&gt; TEST_STANDALONE["test-standalone"]
    TEST_SETUP --&gt; TEST_CLI["test-cli"]
  end

  subgraph "Documentation"
    DOCS --&gt; LANGREF_GEN["generateLangRef()&lt;br/&gt;(tools/docgen.zig)"]
    DOCS --&gt; STD_DOCS["autodoc_test&lt;br/&gt;(lib/std/std.zig)"]
  end

  subgraph "Installation"
    EXE --&gt; INSTALL_BIN["stage3/bin/zig"]
    INSTALL_LIB_DIR["lib/ directory"] --&gt; INSTALL_LIB_TARGET["stage3/lib/zig/"]
    LANGREF_GEN --&gt; INSTALL_LANGREF["stage3/doc/langref.html"]
    STD_DOCS --&gt; INSTALL_STD_DOCS["stage3/doc/std/"]
  end</literallayout>
</section>
</section>
<section xml:id="package-intent">
<title>记录包意图</title>
<simpara>除了CLI标志之外，意图存在于文档中：描述哪些模块是公共的，您是否期望下游入口点，以及包应如何被其他构建图消费（参见 <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build/Module.zig">Module.zig</link>）。</simpara>
</section>
</chapter>
<chapter xml:id="choosing-unit">
<title>快速选择正确的单元</title>
<simpara>在决定接下来要创建什么时，请使用下面的速查表；它故意带有观点，以便团队形成共享的默认值。<link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">您想要…</entry>
<entry align="left" valign="top">首选</entry>
<entry align="left" valign="top">理由</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>发布没有入口点的可重用算法</simpara></entry>
<entry align="left" valign="top"><simpara>包 + 库</simpara></entry>
<entry align="left" valign="top"><simpara>捆绑模块和元数据，以便消费者可以通过名称导入，并与路径解耦。</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>发布命令行工具</simpara></entry>
<entry align="left" valign="top"><simpara>程序</simpara></entry>
<entry align="left" valign="top"><simpara>导出<literal>main</literal>（或<literal>_start</literal>），除非您打算共享它们，否则保持助手模块私有。</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>在单个仓库内的文件之间共享类型</simpara></entry>
<entry align="left" valign="top"><simpara>模块</simpara></entry>
<entry align="left" valign="top"><simpara>使用普通的<literal>@import</literal>暴露命名空间，而不会过早耦合构建元数据。<link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section xml:id="_artifact_types_at_a_glance">
<title>工件类型概览</title>
<simpara>编译器的<literal>output_mode</literal>和<literal>link_mode</literal>选择决定了支持每个概念角色的具体工件形式。程序通常构建为可执行文件，而库使用可以是静态或动态的<literal>Lib</literal>输出。</simpara>
<literallayout class="monospaced">graph LR
  subgraph "Output Mode + Link Mode = Artifact Type"
    Exe_static["output_mode: Exe&lt;br/&gt;link_mode: static"] --&gt; ExeStatic["Static executable"]
    Exe_dynamic["output_mode: Exe&lt;br/&gt;link_mode: dynamic"] --&gt; ExeDynamic["Dynamic executable"]

    Lib_static["output_mode: Lib&lt;br/&gt;link_mode: static"] --&gt; LibStatic["Static library (.a)"]
    Lib_dynamic["output_mode: Lib&lt;br/&gt;link_mode: dynamic"] --&gt; LibDynamic["Shared library (.so/.dll)"]

    Obj["output_mode: Obj&lt;br/&gt;link_mode: N/A"] --&gt; ObjFile["Object file (.o)"]
  end</literallayout>
<simpara><emphasis role="strong">来源：</emphasis> <link xl:href="https://github.com/ziglang/zig/tree/master/src/Compilation/Config.zig">Config.zig</link>, <link xl:href="https://github.com/ziglang/zig/tree/master/src/main.zig">main.zig</link>, <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/builtin.zig">builtin.zig</link></simpara>
<simpara>您可以将本章的词汇表与这些工件类型通过简单的映射结合起来：</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">角色</entry>
<entry align="left" valign="top">典型工件</entry>
<entry align="left" valign="top">说明</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>程序</simpara></entry>
<entry align="left" valign="top"><simpara><literal>output_mode: Exe</literal> (静态或动态)</simpara></entry>
<entry align="left" valign="top"><simpara>暴露入口点；也可以在内部导出助手模块。</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>库包</simpara></entry>
<entry align="left" valign="top"><simpara><literal>output_mode: Lib</literal> (静态或共享)</simpara></entry>
<entry align="left" valign="top"><simpara>旨在重用；没有根<literal>main</literal>，消费者通过名称导入模块。</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>内部模块</simpara></entry>
<entry align="left" valign="top"><simpara>取决于上下文</simpara></entry>
<entry align="left" valign="top"><simpara>通常作为可执行文件或库的一部分编译；通过<literal>@import</literal>暴露，而不是独立的工件。</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>注意事项</title>
<itemizedlist>
<listitem>
<simpara>即使在临时模块中也要记录类似清单的数据，以便后续升级为包时变得机械化。</simpara>
</listitem>
<listitem>
<simpara>当您将程序转换为库时，删除或保护入口点；否则消费者会得到冲突的根。<link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara>
</listitem>
<listitem>
<simpara><literal>-M</literal>/<literal>--dep</literal>工作流程是<literal>std.build.Module</literal>的薄层，因此一旦您的项目超过单个二进制文件，请优先使用构建图。<link xl:href="21__zig-init-and-package-metadata.xml">21</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>练习</title>
<itemizedlist>
<listitem>
<simpara>扩展<literal>module_role_map.zig</literal>，使速查表由从JSON清单加载的数据驱动，然后比较与直接Zig结构体的人体工程学。<link xl:href="12__config-as-data.xml">12</link>, <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/json.zig">json.zig</link></simpara>
</listitem>
<listitem>
<simpara>修改覆盖演示以注册两个外部模块并发出它们的声明计数，强化<literal>--dep</literal>如何排队多个导入。</simpara>
</listitem>
<listitem>
<simpara>草拟一个包装覆盖示例的<literal>zig build</literal>脚本，验证CLI标志如何清晰地映射到<literal>b.addModule</literal>和<literal>module.addImport</literal>。<link xl:href="21__zig-init-and-package-metadata.xml">21</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>注意事项、替代方案与边缘情况</title>
<itemizedlist>
<listitem>
<simpara>交叉编译包可能暴露<literal>target</literal>特定的模块；记录条件导入以防止意外的名称解析失败。</simpara>
</listitem>
<listitem>
<simpara>如果您在同一构建图中注册模块名称两次，Zig CLI会报告冲突——将其视为重构的信号，而不是依赖排序。<link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara>
</listitem>
<listitem>
<simpara>一些工具仍然期望已弃用的<literal>--pkg-begin</literal>语法；与编译器同步升级脚本以保持依赖注册一致。<link xl:href="https://ziglang.org/download/0.15.1/release-notes.html">v0.15.2</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>