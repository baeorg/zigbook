////
changes: ["Initial draft of chapter 19 on modules, builtin metadata, and discovery patterns", "Added three runnable demos covering module graphs, builtin probes, and optional dev hooks"]
examples_compile: yes
keywords: ["modules", "imports", "builtin", "root module", "discovery"]
last_updated: 2025-11-03
last_verified: 2025-11-03
next_chapter: "20__concept-primer-modules-vs-programs-vs-packages-vs-libraries"
open_questions: []
previous_chapter: "18__project-generic-priority-queue"
status: draft
xref_complete: true
////

= Modules & Imports: Root/Builtin/Discovery
:chapter-number: 19
:chapter-slug: modules-and-imports-root-builtin-discovery
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Chapter 18 wrapped a generic priority queue in reusable modules; now we widen the aperture to the compiler’s full module graph. We will draw clear lines between the root module, the standard library, and the special `builtin` namespace that surfaces compilation metadata. Along the way, we will embrace Zig 0.15.2’s I/O revamp, practice discovery of optional helpers, and preview how custom entry points hook into `std.start` for programs that need to bypass the default runtime prelude. For more detail, see xref:18__project-generic-priority-queue.adoc[18], link:https://github.com/ziglang/zig/tree/master/lib/std/start.zig[start.zig], and link:https://ziglang.org/download/0.15.1/release-notes.html[v0.15.2].

[[learning-goals]]
== Learning Goals

* Map how root, `std`, and `builtin` interact to form the compile-time module graph and share declarations safely. See link:https://github.com/ziglang/zig/tree/master/lib/std/std.zig[std.zig].
* Harvest target, optimization, and build-mode metadata from `builtin` to steer configuration and diagnostics. See link:https://github.com/ziglang/zig/tree/master/lib/std/builtin.zig[builtin.zig].
* Gate optional helpers with `@import` and `@hasDecl`, keeping discoveries explicit while supporting policy-driven modules.

[[module-graph]]
== Walking the module graph

The compiler perceives every source file as a namespaced struct. When you `@import` a path, the returned struct exposes any `pub` declarations for downstream use. The root module simply corresponds to your top-level file; anything it exports is immediately reachable through `@import("root")`, whether the caller is another module or a test block. We will inspect that relationship with a small constellation of files to show value sharing across modules while capturing build metadata. See link:https://github.com/ziglang/zig/tree/master/lib/std/fs/File.zig[File.zig].

[[module-graph-example]]
=== Sharing root exports across helper modules

`module_graph_report.zig` instantiates a queue-like report across three files: the root exports a `Features` array, a `build_config.zig` helper formats metadata, and a `service/metrics.zig` module consumes the root exports to build a catalog. The example also demonstrates the new writer API introduced in 0.15.2, where we borrow a stack buffer and flush through the `std.fs.File.stdout().writer` interface. See link:https://github.com/ziglang/zig/tree/master/lib/std/Io.zig[Io.zig].

[source,zig]
----
include::{sourcedir}/19__modules-and-imports-root-builtin-discovery/module_graph_report.zig[]
----

.Run
[source,shell]
----
$ zig run module_graph_report.zig
----

.Output
[source,shell]
----
== Module graph walkthrough ==
root.Version -> 1.4.0
mode=Debug target=x86_64-linux
features: root-module-export builtin-introspection module-catalogue
Features exported by root (3):
   1. root-module-export
   2. builtin-introspection
   3. module-catalogue
----

The helper modules reference `@import("root")` to read `Features`, and they format `builtin.target` information to prove the metadata flows correctly. Treat this pattern as your baseline for sharing config without reaching for globals or singleton state. 

[[module-graph-import-tracking]]
=== How `@import` calls are tracked internally

At the compiler level, each `@import("path")` expression becomes an entry in an imports map during AST-to-ZIR lowering. This map deduplicates paths, preserves token locations for diagnostics, and ultimately feeds a packed `Imports` payload in the ZIR extra data.

[mermaid]
....
graph TB
   ImportExpr["@import(&quot;path&quot;)"] --> CheckImports["Check imports map"]

   CheckImports -->|Exists| UseExisting["Reuse existing import"]
   CheckImports -->|Not exists| AddImport["Add to imports map"]

   AddImport --> StoreToken["Map string_index -> token"]
   StoreToken --> GenerateInst["Generate import instruction"]

   GenerateInst --> Finalize["At end of AstGen"]
   Finalize --> StoreImports["Store Imports payload<br/>in extra array"]
....

[[builtin-metadata]]
== Inspecting build metadata via `builtin`

The `builtin` namespace is assembled by the compiler for every translation unit. It exposes fields such as `mode`, `target`, `single_threaded`, and `link_libc`, allowing you to tailor diagnostics or guard costly features behind compile-time switches. The next example exercises these fields and shows how to keep optional imports quarantined behind `comptime` checks so they never trigger in release builds. 

[source,zig]
----
include::{sourcedir}/19__modules-and-imports-root-builtin-discovery/builtin_probe.zig[]
----

.Run
[source,shell]
----
$ zig run builtin_probe.zig
----

.Output
[source,shell]
----
zig version (compiler): 0.15.2
optimize mode: Debug — debug symbols and runtime safety checks enabled
target triple: x86_64-linux-gnu
single-threaded build: false
linking libc: false
----

Key takeaways:

* `std.fs.File.stdout().writer(&buffer)` supplies a buffered writer compatible with the new `std.Io.Writer` API; always flush before exit to avoid truncated output.
* `builtin.is_test` is a comptime constant. Gating `@import("test_helpers.zig")` behind that flag ensures test-only helpers disappear from release builds while keeping coverage instrumentation centralized. 
* Using `@tagName` on enum-like fields (`mode`, `target.cpu.arch`) yields strings without heap allocation, making them ideal for banner messages or feature toggles.

[[builtin-optimization-modes]]
=== Optimization modes in practice

The `builtin.mode` field observed in the probe corresponds to the optimizer configuration for the current module. Each mode trades off safety checks, debug information, speed, and binary size; understanding these trade-offs helps you decide when to enable discovery hooks or expensive diagnostics.

|===
| Mode | Priority | Safety Checks | Speed | Binary Size | Use Case

| `Debug`
| Safety + Debug Info
| All enabled
| Slowest
| Largest
| Development and debugging

| `ReleaseSafe`
| Speed + Safety
| All enabled
| Fast
| Large
| Production with safety

| `ReleaseFast`
| Maximum Speed
| Disabled
| Fastest
| Medium
| Performance-critical production

| `ReleaseSmall`
| Minimum Size
| Disabled
| Fast
| Smallest
| Embedded systems, size-constrained
|===

The optimization mode is specified per-module and affects:

* Runtime safety checks (overflow, bounds checking, null checks)
* Stack traces and debug information generation
* LLVM optimization level (when using LLVM backend)
* Inlining heuristics and code generation strategies

[mermaid]
....
graph TB
   subgraph "Optimization Mode Effects"
      OptMode["optimize_mode: OptimizeMode"]

      OptMode --> SafetyChecks["Runtime Safety Checks"]
      OptMode --> DebugInfo["Debug Information"]
      OptMode --> CodegenStrategy["Codegen Strategy"]
      OptMode --> LLVMOpt["LLVM Optimization Level"]

      SafetyChecks --> Overflow["Integer overflow checks"]
      SafetyChecks --> Bounds["Bounds checking"]
      SafetyChecks --> Null["Null pointer checks"]
      SafetyChecks --> Unreachable["Unreachable assertions"]

      DebugInfo --> StackTraces["Stack traces"]
      DebugInfo --> DWARF["DWARF debug info"]
      DebugInfo --> LineInfo["Source line information"]

      CodegenStrategy --> Inlining["Inline heuristics"]
      CodegenStrategy --> Unrolling["Loop unrolling"]
      CodegenStrategy --> Vectorization["SIMD vectorization"]

      LLVMOpt --> O0["Debug: -O0"]
      LLVMOpt --> O2Safe["ReleaseSafe: -O2 + safety"]
      LLVMOpt --> O3["ReleaseFast: -O3"]
      LLVMOpt --> Oz["ReleaseSmall: -Oz"]
   end
....

[[builtin-test-config]]
=== Case study: `builtin`-driven test configuration

The standard library's test framework uses `builtin` fields extensively to decide when to skip tests for unsupported backends, platforms, or optimization modes. The flow below mirrors the conditional patterns you can adopt in your own modules when wiring optional helpers.

[mermaid]
....
graph TB

   subgraph "Conditional Execution"
      BACKEND_CHECK["Backend Check<br/>if (builtin.zig_backend == .stage2_X)<br/>return error.SkipZigTest;"]
      PLATFORM_CHECK["Platform Check<br/>if (builtin.os.tag == .X)<br/>return error.SkipZigTest;"]
      MODE_CHECK["Mode Check<br/>if (builtin.mode == .ReleaseFast)<br/>return error.SkipZigTest;"]
   end

   subgraph "Test Types"
      RUNTIME["Runtime Test<br/>var x = computeValue();"]
      COMPTIME["Comptime Test<br/>try comptime testFunction();"]
      MIXED["Mixed Test<br/>try testFn();<br/>try comptime testFn();"]
   end

   BODY --> BACKEND_CHECK
   BODY --> PLATFORM_CHECK
   BODY --> MODE_CHECK
   BODY --> RUNTIME
   BODY --> COMPTIME
   BODY --> MIXED
....

[[optional-discovery]]
== Optional discovery with `@import` and `@hasDecl`

Large systems frequently ship debug-only tooling or experimental adapters. Rather than silently probing the filesystem, Zig encourages explicit discovery: import the helper module at comptime when a policy is enabled, then interrogate its exported API with `@hasDecl`. The following sample does just that by conditionally wiring `tools/dev_probe.zig` into the build when running in Debug mode. 

[source,zig]
----
include::{sourcedir}/19__modules-and-imports-root-builtin-discovery/discovery_probe.zig[]
----

.Run
[source,shell]
----
$ zig run discovery_probe.zig
----

.Output
[source,shell]
----
discovery mode: Debug
dev hooks: debug-only instrumentation active
built with zig 0.15.2
----

Because `DevHooks` is itself a comptime `if`, Release builds replace the import with a stub struct whose API documents the absence of dev features. Combined with `@hasDecl`, the root module can emit a summary without enumerating every optional hook manually, keeping compile-time discovery explicit and reproducible. 

[[entrypoints]]
== Entry points and `std.start`

`std.start` inspects the root module to decide whether to export `main`, `_start`, or platform-specific entry symbols. If you provide `pub fn _start() noreturn`, the default start shim stands aside, letting you wire syscalls or a bespoke runtime manually.

[[entrypoints-symbol-table]]
=== Entry point symbol table

The exported symbol chosen by `std.start` depends on the platform, link mode, and configuration flags such as `link_libc`. The table below summarizes the most important combinations.

|===
| Platform | Link Mode | Conditions | Exported Symbol | Handler Function

| POSIX/Linux
| Executable
| Default
| `_start`
| `_start()`

| POSIX/Linux
| Executable
| Linking libc
| `main`
| `main()`

| Windows
| Executable
| Default
| `wWinMainCRTStartup`
| `WinStartup()` / `wWinMainCRTStartup()`

| Windows
| Dynamic Library
| Default
| `_DllMainCRTStartup`
| `_DllMainCRTStartup()`

| UEFI
| Executable
| Default
| `EfiMain`
| `EfiMain()`

| WASI
| Executable (command)
| Default
| `_start`
| `wasi_start()`

| WASI
| Executable (reactor)
| Default
| `_initialize`
| `wasi_start()`

| WebAssembly
| Freestanding
| Default
| `_start`
| `wasm_freestanding_start()`

| WebAssembly
| Linking libc
| Default
| `__main_argc_argv`
| `mainWithoutEnv()`

| OpenCL/Vulkan
| Kernel
| Default
| `main`
| `spirvMain2()`

| MIPS
| Any
| Default
| `__start`
| (same as `_start`)
|===

[[entrypoints-logic]]
=== Compile-time entry point logic

Internally, `std.start` uses `builtin` fields such as `output_mode`, `os`, `link_libc`, and the target architecture to decide which symbol to export. The compile-time flow mirrors the cases in the symbol table.

[mermaid]
....
graph TB
   Start["comptime block<br/>(start.zig:28)"]
   CheckMode["Check builtin.output_mode"]
   CheckSimplified["simplified_logic?<br/>(stage2 backends)"]

   CheckLinkC["link_libc or<br/>object_format == .c?"]
   CheckWindows["builtin.os == .windows?"]
   CheckUEFI["builtin.os == .uefi?"]
   CheckWASI["builtin.os == .wasi?"]
   CheckWasm["arch.isWasm() &&<br/>os == .freestanding?"]

   ExportMain["@export(&main, 'main')"]
   ExportWinMain["@export(&WinStartup,<br/>'wWinMainCRTStartup')"]
   ExportStart["@export(&_start, '_start')"]
   ExportEfi["@export(&EfiMain, 'EfiMain')"]
   ExportWasi["@export(&wasi_start,<br/>wasm_start_sym)"]
   ExportWasmStart["@export(&wasm_freestanding_start,<br/>'_start')"]

   Start --> CheckMode
   CheckMode -->|".Exe or has main"| CheckSimplified
   CheckSimplified -->|"true"| Simple["Simplified logic<br/>(lines 33-51)"]
   CheckSimplified -->|"false"| CheckLinkC

   CheckLinkC -->|"yes"| ExportMain
   CheckLinkC -->|"no"| CheckWindows
   CheckWindows -->|"yes"| ExportWinMain
   CheckWindows -->|"no"| CheckUEFI
   CheckUEFI -->|"yes"| ExportEfi
   CheckUEFI -->|"no"| CheckWASI
   CheckWASI -->|"yes"| ExportWasi
   CheckWASI -->|"no"| CheckWasm
   CheckWasm -->|"yes"| ExportWasmStart
   CheckWasm -->|"no"| ExportStart
....

`std.start` inspects the root module to decide whether to export `main`, `_start`, or platform-specific entry symbols. If you provide `pub fn _start() noreturn`, the default start shim stands aside, letting you wire syscalls or a bespoke runtime manually. To keep the toolchain happy:

* Build with `-fno-entry` so the linker does not expect the C runtime’s `main`.
* Emit diagnostics via syscalls or lightweight wrappers; the standard I/O stack assumes `std.start` performed its initialization. See link:https://github.com/ziglang/zig/tree/master/lib/std/os/linux.zig[linux.zig].
* Optionally wrap the low-level entry point with a thin compat shim that calls into a higher-level Zig function so your business logic still lives in ergonomically testable code.

In the next chapter we will generalize these ideas into a vocabulary for differentiating modules, programs, packages, and libraries, preparing us to scale compile-time configuration without muddling namespace boundaries. xref:20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc[20]

[[notes-caveats]]
== Notes & Caveats

* Prefer `@import("root")` over global singletons when sharing configuration structs; it keeps dependencies explicit and plays nicely with Zig’s compile-time evaluation.
* The 0.15.2 writer API requires explicit buffers; adjust buffer sizes to match your output volume and always flush before returning.
* Optional imports should live behind policy-enforcing declarations so production artifacts do not accidentally drag dev-only code into release builds.

[[exercises]]
== Exercises

* Extend `module_graph_report.zig` so the `Features` array becomes a struct of structs, then update the catalog printer to format nested capabilities with indentation. xref:13__testing-and-leak-detection.adoc[13]
* Modify `builtin_probe.zig` to emit a JSON fragment describing the target; use `std.json.stringify` and verify the output under each optimization mode. See link:https://github.com/ziglang/zig/tree/master/lib/std/json.zig[json.zig].
* Add a ReleaseFast-only helper module for `discovery_probe.zig` that tracks build timestamps; guard it with `if (builtin.mode == .ReleaseFast)` and prove via tests that ReleaseSafe builds never import it. xref:13__testing-and-leak-detection.adoc[13]

[[caveats-alternatives-edge-cases]]
== Caveats, alternatives, edge cases

* When combining `@import("root")` with `@This()` from inside the same file, beware of circular references; forward declarations or intermediate helper structs can break the cycle. 
* On cross-compilation targets where `std.fs.File.stdout()` may not exist (e.g. freestanding WASM), fall back to target-specific writers or telemetry buffers before flushing. See link:https://github.com/ziglang/zig/tree/master/lib/std/os/wasi.zig[wasi.zig].
* If you disable `std.start`, you also opt out of Zig’s automatic panic handler and argument parsing helpers; reintroduce equivalents explicitly or document the new contract for consumers.
