<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>Zig包管理器与<literal>build.zig.zon</literal>（深入）</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>概述</title>
<simpara>第22章介绍了构建系统的API，用于创建构件和配置构建；第23章演示了包含库和可执行文件的工作区组织。本章通过检查<emphasis role="strong">依赖管理</emphasis>来完成构建系统基础——Zig项目如何通过<literal>build.zig.zon</literal>清单和内置在Zig工具链中的包管理器来声明、获取、验证、缓存和集成外部包。<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build.zig">Build.zig</link></simpara>
<simpara>与作为独立工具运行、拥有自己的元数据格式和解析算法的传统包管理器不同，Zig的包管理器是构建系统本身的一个组成部分，利用了用于编译构件的相同确定性缓存基础设施（参见<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build/Cache.zig">Cache.zig</link>）。<literal>build.zig.zon</literal>文件——一个Zig对象表示法（ZON）文档——作为包元数据、依赖声明和包含规则的单一事实来源，而<literal>build.zig</literal>则编排这些依赖如何集成到项目的模块图中。<link xl:href="20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.xml">20</link>
在本章结束时，你将理解依赖的完整生命周期：从在<literal>build.zig.zon</literal>中声明，通过加密验证和缓存，到在Zig源代码中进行模块注册和导入。你还将学习可重现构建的模式、懒加载依赖以及平衡便利性与安全性的本地开发工作流。</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>理解<literal>build.zig.zon</literal>清单文件的结构和语义（参见<link xl:href="https://github.com/ziglang/zig/blob/master/lib/init/build.zig.zon">build.zig.zon模板</link>）。</simpara>
</listitem>
<listitem>
<simpara>使用基于URL的获取和基于路径的本地引用声明依赖项。</simpara>
</listitem>
<listitem>
<simpara>解释加密哈希在依赖验证和内容寻址中的作用。</simpara>
</listitem>
<listitem>
<simpara>导航依赖解析管道：从获取到缓存再到可用性。</simpara>
</listitem>
<listitem>
<simpara>使用<literal>b.dependency()</literal>和<literal>b.lazyDependency()</literal>将获取的依赖项集成到<literal>build.zig</literal>中。</simpara>
</listitem>
<listitem>
<simpara>区分急切和懒加载依赖策略。</simpara>
</listitem>
<listitem>
<simpara>理解可重现性保证：锁定文件、哈希验证和确定性清单。</simpara>
</listitem>
<listitem>
<simpara>使用全局包缓存并理解离线构建工作流。</simpara>
</listitem>
<listitem>
<simpara>使用<literal>zig fetch</literal>命令进行依赖管理。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="build-zig-zon-schema">
<title><literal>build.zig.zon</literal>架构</title>
<simpara><literal>build.zig.zon</literal>文件是一种Zig原生数据格式——本质上是一个单一匿名结构体字面量——用于描述包元数据。它在构建时由Zig编译器解析，提供强类型和熟悉的语法，同时保持人类可读性和简单的编写方式。与JSON或TOML不同，ZON受益于Zig的编译时评估，允许在构建过程中验证和转换结构化数据。</simpara>
<section xml:id="minimal-manifest">
<title>最小清单</title>
<simpara>每个<literal>build.zig.zon</literal>文件必须至少声明包名称、版本和最低支持的Zig版本：</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 24__zig-package-manager-deep.adoc - include::example$chapters-data/code/24__zig-package-manager-deep/01_minimal_manifest.zig.zon[]</programlisting>
<simpara><literal>.paths</literal>字段指定当此包被其他项目获取时包含哪些文件和目录。此包含列表直接影响计算的包哈希——只有列出的文件才计入哈希，确保确定性内容寻址。</simpara>
<tip>
<simpara><literal>.paths</literal>字段既作为包含过滤器又作为文档辅助。始终列出<literal>build.zig</literal>、<literal>build.zig.zon</literal>和你的源目录。排除生成的文件、测试工件和不应成为包规范内容的编辑器特定文件。</simpara>
</tip>
</section>
<section xml:id="package-identity-fields">
<title>包标识和版本控制</title>
<simpara><literal>.name</literal>和<literal>.version</literal>字段共同建立包标识。截至Zig 0.15.2，包管理器尚未执行自动版本解析或去重，但这些字段为未来增强做准备，并帮助人类维护者理解包关系。</simpara>
<simpara><literal>.minimum_zig_version</literal>字段传达兼容性期望。当包声明最低版本时，如果当前Zig工具链较旧，构建系统将拒绝继续，防止由于缺少功能或更改语义而导致的模糊编译失败。</simpara>
<simpara><literal>.fingerprint</literal>字段（在最小示例中省略但在模板中显示）是在包创建时生成一次且此后永不更改的唯一标识符。此指纹能够明确检测包分叉和更新，防止试图冒充上游项目的恶意分叉。</simpara>
<warning>
<simpara>更改<literal>.fingerprint</literal>具有安全和信任影响。它表示此包与其来源是不同的实体，这可能会破坏信任链并在未来的Zig版本中混淆依赖解析。</simpara>
</warning>
</section>
<section xml:id="declaring-dependencies">
<title>声明依赖项</title>
<simpara>依赖项在<literal>.dependencies</literal>结构体中声明。每个依赖项必须提供<literal>.url</literal>和<literal>.hash</literal>对（对于远程包）或<literal>.path</literal>（对于本地包）：</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 24__zig-package-manager-deep.adoc - include::example$chapters-data/code/24__zig-package-manager-deep/02_with_dependency.zig.zon[]</programlisting>
<simpara>基于URL的依赖项从网络获取，根据提供的哈希进行验证，并全局缓存。基于路径的依赖项引用相对于构建根目录的目录，在本地开发或vendoring依赖项时很有用。</simpara>
<simpara>哈希使用multihash格式，其中前缀<literal>1220</literal>表示SHA-256。这种内容寻址方法确保包由其内容而非URL标识，使包管理器对URL更改和镜像可用性具有弹性。</simpara>
<important>
<simpara><literal>.hash</literal>字段是真相来源——包不是来自URL；它们来自哈希。URL只是获取与哈希匹配的内容的一个可能镜像。这种设计将包标识（内容）与包位置（URL）分开。</simpara>
</important>
</section>
<section xml:id="lazy-dependencies">
<title>懒加载与急切加载依赖项</title>
<simpara>默认情况下，所有声明的依赖项都是<emphasis role="strong">急切</emphasis>的：它们在构建脚本运行之前被获取和验证。对于仅在特定条件下需要的可选依赖项（例如，调试工具、基准测试实用程序或平台特定扩展），你可以使用<literal>.lazy = true</literal>将它们标记为<emphasis role="strong">懒加载</emphasis>：</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 24__zig-package-manager-deep.adoc - include::example$chapters-data/code/24__zig-package-manager-deep/03_lazy_dependency.zig.zon[]</programlisting>
<simpara>懒加载依赖项直到<literal>build.zig</literal>通过<literal>b.lazyDependency()</literal>明确请求它们时才会被获取。如果构建脚本从未为给定包调用<literal>lazyDependency()</literal>，则该包保持未获取状态，节省下载时间和磁盘空间。</simpara>
<simpara>这种两阶段方法允许构建脚本声明可选依赖项，而不强制所有用户下载它们。当请求懒加载依赖项但尚不可用时，构建运行器将获取它，然后重新运行构建脚本——这是一个在灵活性和确定性之间取得平衡的透明过程。</simpara>
</section>
</chapter>
<chapter xml:id="resolution-pipeline">
<title>依赖解析管道</title>
<simpara>理解Zig如何将<literal>.dependencies</literal>声明转换为可用模块，阐明了包管理器的设计，并有助于调试获取失败或集成问题。</simpara>
<section xml:id="parse-and-validate">
<title>1. 解析和验证</title>
<simpara>当你运行<literal>zig build</literal>时，编译器首先将<literal>build.zig.zon</literal>解析为ZON字面量（参见<link xl:href="https://github.com/ziglang/zig/blob/master/lib/compiler/build_runner.zig">build_runner.zig</link>）。此解析步骤验证语法并确保所有必需字段都存在。编译器检查：</simpara>
<itemizedlist>
<listitem>
<simpara>每个依赖项具有<literal>.url</literal>+<literal>.hash</literal>或<literal>.path</literal>（但不能同时具有两者）</simpara>
</listitem>
<listitem>
<simpara>哈希字符串使用有效的multihash编码</simpara>
</listitem>
<listitem>
<simpara><literal>.minimum_zig_version</literal>不比运行的工具链更新</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="fetch-and-verify">
<title>2. 获取和验证</title>
<simpara>对于每个具有<literal>.url</literal>的<emphasis role="strong">急切</emphasis>依赖项，构建运行器：</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>从哈希计算唯一缓存键</simpara>
</listitem>
<listitem>
<simpara>检查包是否存在于全局缓存中（在类Unix系统上为<literal>~/.cache/zig/p/&lt;hash&gt;/</literal>）</simpara>
</listitem>
<listitem>
<simpara>如果未缓存，则下载URL内容</simpara>
</listitem>
<listitem>
<simpara>如果需要，提取存档（支持<literal>.tar.gz</literal>、<literal>.tar.xz</literal>、<literal>.zip</literal>）</simpara>
</listitem>
<listitem>
<simpara>应用依赖项自己的<literal>build.zig.zon</literal>中的<literal>.paths</literal>过滤器</simpara>
</listitem>
<listitem>
<simpara>计算过滤内容的哈希</simpara>
</listitem>
<listitem>
<simpara>验证其匹配声明的<literal>.hash</literal>字段</simpara>
</listitem>
<listitem>
<simpara>将验证的内容存储在全局缓存中</simpara>
</listitem>
</orderedlist>
<simpara>如果哈希验证失败，构建将中止，并显示指示哈希不匹配的清晰错误消息。这防止了供应链攻击，其中受损的镜像提供不同的内容。</simpara>
<simpara>基于路径的依赖项跳过获取步骤——它们始终相对于构建根目录可用。</simpara>
</section>
<section xml:id="cache-lookup">
<title>3. 缓存查找和重用</title>
<simpara>一旦包被缓存，后续构建将重用缓存的版本，而无需重新下载或重新验证。全局缓存在系统上的所有Zig项目之间共享，因此获取一次流行的依赖项会使所有项目受益。</simpara>
<simpara>缓存目录结构是内容寻址的：每个包的哈希直接映射到缓存子目录。这使得缓存管理透明且可预测——你可以检查缓存的包或清除缓存，而不会破坏构建状态的风险。</simpara>
</section>
<section xml:id="dependency-graph-construction">
<title>4. 依赖图构建</title>
<simpara>在所有急切依赖项可用后，构建运行器构建依赖图。每个包的<literal>build.zig</literal>作为Zig模块加载，并调用<literal>build()</literal>函数来注册构件和步骤。</simpara>
<simpara>懒加载依赖项<emphasis role="strong">不</emphasis>在此阶段加载。相反，构建运行器将它们标记为"可能需要的"并继续。如果<literal>build.zig</literal>为尚未获取的懒加载包调用<literal>b.lazyDependency()</literal>，构建运行器记录请求，完成当前构建过程，获取懒加载依赖项，然后重新运行构建脚本。</simpara>
<simpara>这种延迟获取机制允许构建脚本根据用户选项或目标特征有条件地加载依赖项，而不强制所有用户下载每个可选包。</simpara>
<simpara>在内部，Zig在<literal>InternPool</literal>中记录对ZON清单和其他依赖项的依赖关系，以便对<literal>build.zig.zon</literal>或嵌入文件的更改仅使依赖于它们的分析单元失效：</simpara>
<literallayout class="monospaced">graph TB
   subgraph "InternPool - Dependency Storage"
      SRCHASHDEPS["src_hash_deps&lt;br/&gt;Map: TrackedInst.Index → DepEntry.Index"]
      NAVVALDEPS["nav_val_deps&lt;br/&gt;Map: Nav.Index → DepEntry.Index"]
      NAVTYDEPS["nav_ty_deps&lt;br/&gt;Map: Nav.Index → DepEntry.Index"]
      INTERNEDDEPS["interned_deps&lt;br/&gt;Map: Index → DepEntry.Index"]
      ZONFILEDEPS["zon_file_deps&lt;br/&gt;Map: FileIndex → DepEntry.Index"]
      EMBEDFILEDEPS["embed_file_deps&lt;br/&gt;Map: EmbedFile.Index → DepEntry.Index"]
      NSDEPS["namespace_deps&lt;br/&gt;Map: TrackedInst.Index → DepEntry.Index"]
      NSNAMEDEPS["namespace_name_deps&lt;br/&gt;Map: NamespaceNameKey → DepEntry.Index"]

      FIRSTDEP["first_dependency&lt;br/&gt;Map: AnalUnit → DepEntry.Index"]
      DEPENTRIES["dep_entries&lt;br/&gt;ArrayListUnmanaged&lt;DepEntry&gt;"]
      FREEDEP["free_dep_entries&lt;br/&gt;ArrayListUnmanaged&lt;DepEntry.Index&gt;"]
   end

   subgraph "DepEntry Structure"
      DEPENTRY["DepEntry&lt;br/&gt;{depender: AnalUnit,&lt;br/&gt;next_dependee: DepEntry.Index.Optional,&lt;br/&gt;next_depender: DepEntry.Index.Optional}"]
   end

   SRCHASHDEPS --&gt; DEPENTRIES
   NAVVALDEPS --&gt; DEPENTRIES
   NAVTYDEPS --&gt; DEPENTRIES
   INTERNEDDEPS --&gt; DEPENTRIES
   ZONFILEDEPS --&gt; DEPENTRIES
   EMBEDFILEDEPS --&gt; DEPENTRIES
   NSDEPS --&gt; DEPENTRIES
   NSNAMEDEPS --&gt; DEPENTRIES
   FIRSTDEP --&gt; DEPENTRIES

   DEPENTRIES --&gt; DEPENTRY
   FREEDEP -.-&gt;|"reuses indices from"| DEPENTRIES</literallayout>
<simpara>ZON files participate in the same incremental compilation graph as source hashes and embedded files: updating <literal>build.zig.zon</literal> updates the corresponding <literal>zon_file_deps</literal> entries, which in turn mark dependent analysis units and build steps as outdated.</simpara>
<simpara>More broadly, ZON manifests are just one of several <emphasis role="strong">dependee</emphasis> categories that the compiler tracks; at a high level these groups look like this:</simpara>
<literallayout class="monospaced">graph LR
   subgraph "Source-Level Dependencies"
      SRCHASH["Source Hash&lt;br/&gt;TrackedInst.Index&lt;br/&gt;src_hash_deps"]
      ZONFILE["ZON File&lt;br/&gt;FileIndex&lt;br/&gt;zon_file_deps"]
      EMBEDFILE["Embedded File&lt;br/&gt;EmbedFile.Index&lt;br/&gt;embed_file_deps"]
   end

   subgraph "Nav Dependencies"
      NAVVAL["Nav Value&lt;br/&gt;Nav.Index&lt;br/&gt;nav_val_deps"]
      NAVTY["Nav Type&lt;br/&gt;Nav.Index&lt;br/&gt;nav_ty_deps"]
   end

   subgraph "Type/Value Dependencies"
      INTERNED["Interned Value&lt;br/&gt;Index&lt;br/&gt;interned_deps&lt;br/&gt;runtime funcs, container types"]
   end

   subgraph "Namespace Dependencies"
      NSFULL["Full Namespace&lt;br/&gt;TrackedInst.Index&lt;br/&gt;namespace_deps"]
      NSNAME["Namespace Name&lt;br/&gt;NamespaceNameKey&lt;br/&gt;namespace_name_deps"]
   end

   subgraph "Memoized State"
      MEMO["Memoized Fields&lt;br/&gt;panic_messages, etc."]
   end</literallayout>
<simpara>The package manager sits on top of this infrastructure: <literal>.dependencies</literal> entries in <literal>build.zig.zon</literal> ultimately translate into ZON-file dependees and cached content that participate in the same dependency system.</simpara>
</section>
<section xml:id="conceptual-example">
<title>Conceptual Example: Resolution Pipeline</title>
<simpara>The following example demonstrates the logical flow of dependency resolution:</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 24__zig-package-manager-deep.adoc - include::example$chapters-data/code/24__zig-package-manager-deep/07_resolution_pipeline_demo.zig[]</programlisting>
<formalpara><title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run 07_resolution_pipeline_demo.zig</programlisting>
</para>
</formalpara>
<formalpara><title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">=== Zig Package Manager Resolution Pipeline ===

1. Parse build.zig.zon dependencies

2. Resolve eager dependencies
   - core: local path '../core' → available
   - utils: fetching → verifying → cached → available

3. Lazy dependencies (deferred until used)
   - optional_viz: waiting for lazyDependency() call

4. Build script requests lazy dependency
   - optional_viz requested → fetching now

5. Cache locations
   - Global: ~/.cache/zig/p/&lt;hash&gt;/
   - Project: .zig-cache/

=== Resolution Complete ===</programlisting>
</para>
</formalpara>
<simpara>This conceptual model matches the actual implementation in the 构建运行器 and standard library.</simpara>
</section>
</chapter>
<chapter xml:id="integrating-dependencies">
<title>Integrating Dependencies in <literal>build.zig</literal></title>
<simpara>Declaring a dependency in <literal>build.zig.zon</literal> makes it available for fetching; integrating it into your build requires calling <literal>b.dependency()</literal> or <literal>b.lazyDependency()</literal> in <literal>build.zig</literal> to obtain a <literal>*std.Build.Dependency</literal> handle, then extracting modules or artifacts from that dependency.</simpara>
<section xml:id="basic-dependency-usage">
<title>Using <literal>b.dependency()</literal></title>
<simpara>For eager dependencies, use <literal>b.dependency(name, args)</literal> where <literal>name</literal> matches a key in <literal>.dependencies</literal> and <literal>args</literal> is a struct containing build options to pass down to the dependency&#8217;s build script:</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 24__zig-package-manager-deep.adoc - include::example$chapters-data/code/24__zig-package-manager-deep/04_build_with_dependency.zig[]</programlisting>
<simpara>The <literal>b.dependency()</literal> call returns a <literal>*Dependency</literal>, which provides methods to access the dependency&#8217;s artifacts (<literal>.artifact()</literal>), modules (<literal>.module()</literal>), lazy paths (<literal>.path()</literal>), and named write-files (<literal>.namedWriteFiles()</literal>).</simpara>
<simpara>The <literal>args</literal> parameter forwards build options to the dependency, allowing you to configure the dependency&#8217;s target, optimization level, or custom features. This ensures the dependency is built with compatible settings.</simpara>
<tip>
<simpara>Always pass <literal>.target</literal> and <literal>.optimize</literal> to dependencies unless you have a specific reason not to. Mismatched target settings can cause link errors or subtle ABI incompatibilities.</simpara>
</tip>
</section>
<section xml:id="lazy-dependency-usage">
<title>Using <literal>b.lazyDependency()</literal></title>
<simpara>For lazy dependencies, use <literal>b.lazyDependency(name, args)</literal> instead. This function returns <literal>?*Dependency</literal>—<literal>null</literal> if the dependency has not yet been fetched:</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 24__zig-package-manager-deep.adoc - include::example$chapters-data/code/24__zig-package-manager-deep/05_lazy_dependency_usage.zig[]</programlisting>
<simpara>When <literal>lazyDependency()</literal> returns <literal>null</literal>, the build runner records the request and re-runs the build script after fetching the missing dependency. On the second pass, <literal>lazyDependency()</literal> will succeed, and the build proceeds normally.</simpara>
<simpara>This pattern allows build scripts to conditionally include optional features without forcing all users to fetch those dependencies:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ zig build                          # Core functionality only
$ zig build -Dbenchmarks=true        # Fetches benchmark_utils if needed
$ zig build -Ddebug-viz=true         # Fetches debug_visualizer if needed</programlisting>
<caution>
<simpara>Mixing <literal>b.dependency()</literal> and <literal>b.lazyDependency()</literal> for the same package is an error. If a dependency is marked <literal>.lazy = true</literal> in <literal>build.zig.zon</literal>, you <emphasis role="strong">must</emphasis> use <literal>b.lazyDependency()</literal>. If it&#8217;s eager (default), you <emphasis role="strong">must</emphasis> use <literal>b.dependency()</literal>. The build system enforces this to prevent inconsistent fetch behavior.</simpara>
</caution>
</section>
</chapter>
<chapter xml:id="hash-verification-and-multihash">
<title>Hash Verification and Multihash Format</title>
<simpara>Cryptographic hashes are central to Zig&#8217;s package manager, ensuring that fetched content matches expectations and protecting against tampering or corruption.</simpara>
<section xml:id="multihash-format">
<title>Multihash Format</title>
<simpara>Zig uses the multihash format to encode hash digests. A multihash string consists of:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A prefix indicating the hash algorithm (e.g., <literal>1220</literal> for SHA-256)</simpara>
</listitem>
<listitem>
<simpara>The hex-encoded hash digest</simpara>
</listitem>
</orderedlist>
<simpara>For SHA-256, the prefix <literal>1220</literal> breaks down as:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>12</literal> (hex) = SHA-256 algorithm identifier</simpara>
</listitem>
<listitem>
<simpara><literal>20</literal> (hex) = 32 bytes = SHA-256 digest length</simpara>
</listitem>
</itemizedlist>
<simpara>The following example demonstrates conceptual hash computation (the actual implementation lives in the 构建运行器 and cache system):</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 24__zig-package-manager-deep.adoc - include::example$chapters-data/code/24__zig-package-manager-deep/06_hash_verification_example.zig[]</programlisting>
<formalpara><title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run 06_hash_verification_example.zig</programlisting>
</para>
</formalpara>
<formalpara><title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Package hash: 69b2de89d968f316b3679f2e68ecacb50fd3064e0e0ee7922df4e1ced43744d2
Expected hash in build.zig.zon: 122069b2de89d968f316b3679f2e68ecacb50fd3064e0e0ee7922df4e1ced43744d2

Note: The `1220` prefix indicates SHA-256 in multihash format.</programlisting>
</para>
</formalpara>
<simpara>The compiler uses a similar "hash → compare → reuse" pattern for incremental compilation when deciding whether to reuse cached IR for a declaration:</simpara>
<literallayout class="monospaced">graph TB
   Process["Process declaration"] --&gt; UpdateHasher["src_hasher.update()"]

   UpdateHasher --&gt; HashBytes["Hash relevant source bytes"]
   HashBytes --&gt; HashDeps["Hash dependencies"]
   HashDeps --&gt; FinalHash["Produce source hash"]

   FinalHash --&gt; CompareOld["Compare with cached hash"]
   CompareOld --&gt;|Different| Recompile["Invalidate and recompile"]
   CompareOld --&gt;|Same| UseCached["Use cached ZIR/AIR"]</literallayout>
<simpara>This is conceptually the same as package hashing: for both source and dependencies, Zig computes a content hash, compares it with a cached value, and either reuses cached 构件 or recomputes them.</simpara>
<simpara>In practice, you rarely need to compute hashes manually. The <literal>zig fetch</literal> command automates this:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ zig fetch https://example.com/package.tar.gz</programlisting>
<simpara>Zig downloads the package, computes the hash, and prints the complete multihash string you can copy into <literal>build.zig.zon</literal>.</simpara>
<note>
<simpara>The multihash format is forward-compatible with future hash algorithms. If Zig adopts SHA-3 or BLAKE3, new prefix codes will identify those algorithms without breaking existing manifests.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="reproducibility-guarantees">
<title>可重现性 and Deterministic Builds</title>
<simpara>可重现性—the ability to recreate identical build outputs given the same inputs—is a cornerstone of reliable software distribution. Zig&#8217;s package manager contributes to reproducibility through content addressing, hash verification, and explicit versioning.</simpara>
<section xml:id="content-addressing">
<title>Content Addressing</title>
<simpara>Because packages are identified by hash rather than URL, the package manager is inherently resilient to URL changes, mirror failures, and upstream relocations. As long as some mirror provides content matching the hash, the package is usable.</simpara>
<simpara>This content-addressed design also prevents certain classes of supply-chain attacks: an attacker who compromises a single mirror cannot inject malicious code unless they also break the hash function (SHA-256), which is computationally infeasible.</simpara>
<simpara>The same content-addressing principle appears elsewhere in Zig&#8217;s implementation: the <literal>InternPool</literal> stores each distinct type or value exactly once and identifies it by an index, with dependency tracking built on top of these content-derived keys rather than on file paths or textual names.</simpara>
</section>
<section xml:id="lockfile-semantics">
<title>Lockfile Semantics and Transitive Dependencies</title>
<simpara>As of Zig 0.15.2, the package manager does not generate a separate lockfile—<literal>build.zig.zon</literal> itself serves as the lockfile. Each dependency&#8217;s hash locks its content, and transitive dependencies are locked by the direct dependency&#8217;s hash (since the direct dependency&#8217;s <literal>build.zig.zon</literal> specifies its own dependencies).</simpara>
<simpara>This approach simplifies the mental model: there is one source of truth (<literal>build.zig.zon</literal>), and the hash chain ensures transitivity without additional metadata files.</simpara>
<simpara>Future Zig versions may introduce explicit lockfiles for advanced use cases (e.g., tracking resolved URLs or deduplicating transitive dependencies), but the core content-addressing principle will remain. <link xl:href="https://ziglang.org/download/0.15.1/release-notes.html">v0.15.2</link></simpara>
</section>
<section xml:id="offline-builds">
<title>Offline Builds and Cache Portability</title>
<simpara>Once all dependencies are cached, you can build offline indefinitely. The global cache persists across projects, so fetching a dependency once benefits all future projects that use it.</simpara>
<simpara>To prepare for offline builds:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Run <literal>zig build --fetch</literal> to fetch all declared dependencies without building</simpara>
</listitem>
<listitem>
<simpara>Verify the cache is populated: <literal>ls ~/.cache/zig/p/</literal></simpara>
</listitem>
<listitem>
<simpara>Disconnect from the network and run <literal>zig build</literal> normally</simpara>
</listitem>
</orderedlist>
<simpara>If you need to transfer a project with its dependencies to an air-gapped environment, you can:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Fetch all dependencies on a networked machine</simpara>
</listitem>
<listitem>
<simpara>Archive the <literal>~/.cache/zig/p/</literal> directory</simpara>
</listitem>
<listitem>
<simpara>Extract the archive on the air-gapped machine to the same cache location</simpara>
</listitem>
<listitem>
<simpara>Run <literal>zig build</literal> normally</simpara>
</listitem>
</orderedlist>
<note>
<simpara>Path-based dependencies (<literal>.path = "&#8230;&#8203;"</literal>) do not require network access and work immediately offline.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="zig-fetch-commands">
<title>Using <literal>zig fetch</literal> for Dependency Management</title>
<simpara>The <literal>zig fetch</literal> command provides a CLI for managing dependencies without editing <literal>build.zig.zon</literal> manually.</simpara>
<section xml:id="fetching-and-saving">
<title>Fetching and Saving Dependencies</title>
<simpara>To add a new dependency:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ zig fetch --save https://github.com/example/package/archive/v1.0.0.tar.gz</programlisting>
<simpara>This command:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Downloads the URL</simpara>
</listitem>
<listitem>
<simpara>Computes the hash</simpara>
</listitem>
<listitem>
<simpara>Adds an entry to <literal>.dependencies</literal> in <literal>build.zig.zon</literal></simpara>
</listitem>
<listitem>
<simpara>Saves the package name and hash</simpara>
</listitem>
</orderedlist>
<simpara>You can then reference the dependency by name in <literal>build.zig</literal>.</simpara>
</section>
<section xml:id="fetching-without-saving">
<title>Fetching Without Saving</title>
<simpara>To fetch a URL and print its hash without modifying <literal>build.zig.zon</literal>:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ zig fetch https://example.com/package.tar.gz</programlisting>
<simpara>This is useful for verifying package integrity or preparing vendored dependencies.</simpara>
</section>
<section xml:id="recursive-fetch">
<title>Recursive Fetch</title>
<simpara>To fetch all dependencies transitively (including dependencies of dependencies):</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ zig build --fetch</programlisting>
<simpara>This populates the cache with everything needed for a complete build, ensuring offline builds will succeed.</simpara>
</section>
</chapter>
<chapter xml:id="exercises">
<title>练习</title>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong">Minimal Package</emphasis>: Create a new Zig library with <literal>zig init-lib</literal>, examine the generated <literal>build.zig.zon</literal>, and explain the purpose of each top-level field. <link xl:href="21__zig-init-and-package-metadata.xml">21</link></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Path-Based Dependency</emphasis>: Set up two sibling directories (<literal>mylib/</literal> and <literal>myapp/</literal>). Make <literal>myapp</literal> depend on <literal>mylib</literal> using <literal>.path</literal>, implement a simple function in <literal>mylib</literal>, call it from <literal>myapp</literal>, and build successfully.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Hash Verification Failure</emphasis>: Intentionally corrupt a dependency&#8217;s hash in <literal>build.zig.zon</literal> (change one character) and run <literal>zig build</literal>. Observe and interpret the error message.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Lazy Dependency Workflow</emphasis>: Create a project with a lazy dependency for a benchmarking module. Verify that <literal>zig build</literal> (without options) does not fetch the dependency, but <literal>zig build -Dbenchmarks=true</literal> does.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Cache Inspection</emphasis>: Run <literal>zig build --fetch</literal> on a project with remote dependencies, then explore the global cache directory (<literal>~/.cache/zig/p/</literal> on Unix). Identify the package directories by their hash prefixes.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Offline Build Test</emphasis>: Fetch all dependencies for a project, disconnect from the network (or block DNS resolution), and confirm <literal>zig build</literal> succeeds. Reconnect and add a new dependency to verify fetch works again.</simpara>
</listitem>
</orderedlist>
</chapter>
<chapter xml:id="notes-and-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">URL Stability</emphasis>: While content addressing makes the package manager resilient to URL changes, always prefer stable release URLs (tagged releases, not <literal>main</literal> branch archives) to minimize maintenance burden.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Path Dependencies in Distributed Packages</emphasis>: If your package uses <literal>.path</literal> dependencies, those paths must exist relative to the package root when fetched by consumers. Prefer URL-based dependencies for distributed packages to avoid path resolution issues.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Transitive Dependency Deduplication</emphasis>: Zig 0.15.2 does not deduplicate transitive dependencies with different hash strings, even if they refer to the same content. Future versions may implement smarter deduplication.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Security and Trust</emphasis>: Hash verification protects against transport corruption and most tampering, but does not validate package <emphasis role="strong">provenance</emphasis>. Trust the source of the hash (e.g., a project&#8217;s official repository or release page), not just any mirror.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Build Option Forwarding</emphasis>: When calling <literal>b.dependency()</literal>, carefully choose which build options to forward. Forwarding too many can cause build failures if the dependency doesn&#8217;t recognize an option; forwarding too few can result in mismatched configurations.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Caveats, Alternatives, and Edge Cases</title>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Lazy Dependency Refetch</emphasis>: If you delete a lazy dependency from the cache and re-run <literal>zig build</literal> without the option that triggers it, the dependency remains unfetched. Only when the build script calls <literal>lazyDependency()</literal> again will the fetch occur.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Hash Mismatches After Upstream Changes</emphasis>: If an upstream package changes its content without changing its version tag, and you re-fetch the URL, you&#8217;ll encounter a hash mismatch. Always delete the old <literal>.hash</literal> in <literal>build.zig.zon</literal> when updating a URL to signal that you expect new content.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Vendoring Dependencies</emphasis>: For projects with strict supply-chain requirements, consider vendoring dependencies by committing them to your repository (using <literal>.path</literal> references) instead of relying on URL-based fetches. This trades repository size for control.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Mirror Configuration</emphasis>: Zig 0.15.2 does not yet support mirror lists or fallback URLs per dependency. If your primary URL becomes unavailable, you must manually update <literal>build.zig.zon</literal> to a new URL (the hash remains the same, ensuring content integrity).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Fingerprint Collisions</emphasis>: The <literal>.fingerprint</literal> field is a 64-bit value chosen randomly. Collisions are statistically unlikely but not impossible. Future Zig versions may detect and handle fingerprint conflicts during dependency resolution.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="summary">
<title>Summary</title>
<simpara>This chapter explored the full lifecycle of Zig package management:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong"><literal>build.zig.zon</literal> schema</emphasis>: Package metadata, dependency declarations, inclusion rules, and fingerprint identity.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Dependency types</emphasis>: URL-based vs path-based; eager vs lazy loading strategies.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Resolution pipeline</emphasis>: Parse → fetch → verify → cache → construct dependency graph.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Integration in <literal>build.zig</literal></emphasis>: Using <literal>b.dependency()</literal> and <literal>b.lazyDependency()</literal> to access modules and artifacts.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Hash verification</emphasis>: Multihash format, SHA-256 content addressing, supply-chain protection.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">可重现性</emphasis>：内容寻址、锁定文件语义、离线构建、缓存可移植性。</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><literal>zig fetch</literal>命令</emphasis>：从CLI添加、获取和验证依赖项。</simpara>
</listitem>
</itemizedlist>
<simpara>你现在对Zig构建系统有了完整的心理模型：构件创建、工作区组织和依赖管理（本章）。下一章将通过深入探讨模块解析机制和发现模式来扩展这一基础。</simpara>
<simpara>理解包管理器的设计——内容寻址、懒加载、加密验证——使你能够构建可重现、安全且可维护的Zig项目，无论是独立工作还是将第三方库集成到生产系统中。</simpara>
</chapter>
</book>