////
changes: ["Draft advanced result location semantics appendix"]
examples_compile: yes
keywords: ["result-location", "aggregation", "allocations"]
last_updated: 2025-11-13
last_verified: 2025-11-13
next_chapter: "61__zig-ir-and-stage2-peek"
open_questions: []
previous_chapter: "59__advanced-inline-assembly"
status: draft
xref_complete: true
////

= Appendix F. Advanced Result Location Semantics
:chapter-number: 60
:chapter-slug: advanced-result-location-semantics
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Result Location Semantics (RLS) are the quiet engine that powers Zig's zero-copy aggregates, type inference, and efficient error propagation. After experimenting with inline assembly in Appendix E, we now dive back into the compiler to see how Zig steers values directly into their final home. It eliminates temporaries whether you build structs, unions, or manually fill caller-provided buffers. xref:59__advanced-inline-assembly.adoc[59]

Zig 0.15.2 clarifies RLS diagnostics around pointer alignment and optional result pointers, making it easier to reason about where your data lives during construction. link:https://ziglang.org/download/0.15.1/release-notes.html[v0.15.2]

[[learning-goals]]
== Learning Goals

* Trace how struct literals and coercions forward result locations to every field without hidden copies.
* Apply explicit result pointers when you want to reuse caller-owned storage while still offering a value-returning API.
* Combine unions with RLS so each variant writes directly into its own payload without allocating scratch buffers at runtime.

[[struct-forwarding]]
== Struct Forwarding in Practice

When you assign a struct literal to a variable, Zig rewrites the operation into a series of field writes, allowing each sub-expression to inherit the final destination. The first recipe summarizes a handful of sensor readings into a `Report`, demonstrating how nested literals (`range` inside `Report`) inherit result locations transitively. link:https://github.com/ziglang/zig/tree/master/lib/std/math.zig[math.zig]

[source,zig]
----
include::{sourcedir}/60__advanced-result-location-semantics/01_histogram_report.zig[]
----

.Run
[source,shell]
----
$ zig test chapters-data/code/60__advanced-result-location-semantics/01_histogram_report.zig
----

.Output
[source,shell]
----
All 1 tests passed.
----

TIP: Because the literal `.{ .range = …, .buckets = histogram }` writes field-by-field, you can safely seed `histogram` with `var` data—no temporary copy of the 16-byte array is ever produced. xref:36__style-and-best-practices.adoc[36]

[[manual-result-pointers]]
== Manual Result Pointers for Reuse

Sometimes you want both worlds: a value-returning helper for ergonomic callers and an in-place variant for hot loops that reuse storage. By exposing a `parseInto` routine that receives a `*Numbers`, you determine the result location explicitly while still offering `parseNumbers` that benefits from automatic elision. xref:04__errors-resource-cleanup.adoc[4] Note how the slice method accepts `*const Numbers`; returning a slice from a by-value parameter would point at a temporary and violate safety rules. link:https://github.com/ziglang/zig/tree/master/lib/std/mem.zig[mem.zig]

[source,zig]
----
include::{sourcedir}/60__advanced-result-location-semantics/02_numbers_parse_into.zig[]
----

.Run
[source,shell]
----
$ zig test chapters-data/code/60__advanced-result-location-semantics/02_numbers_parse_into.zig
----

.Output
[source,shell]
----
All 2 tests passed.
----

NOTE: Resetting `Numbers` with a fresh value and zeroing the backing array ensures the result location is ready for reuse even if the previous parse only filled part of the buffer. xref:57__error-handling-patterns-cookbook.adoc[57]

[[union-forwarding]]
== Union Variants and Branch-Specific Destinations

Unions expose the same mechanics: once the compiler knows which variant you are constructing, it wires the payload's result location to the appropriate field. The lookup helper below either streams bytes into a `Resource` payload or returns metadata for malformed queries, without allocating interim buffers. The same approach scales to streaming parsers, FFI bridges, or caches that must avoid heap traffic.

[source,zig]
----
include::{sourcedir}/60__advanced-result-location-semantics/03_union_forwarding.zig[]
----

.Run
[source,shell]
----
$ zig test chapters-data/code/60__advanced-result-location-semantics/03_union_forwarding.zig
----

.Output
[source,shell]
----
All 2 tests passed.
----

CAUTION: When copying into fixed-size buffers, clamp the length as shown, so you do not accidentally write past the payload. If you require full-length retention, switch to a slice field and pair it with lifetimes that outlive the union value. xref:10__allocators-and-memory-management.adoc[10]

[[patterns]]
== Patterns to Keep on Hand

* Treat `return .{ … };` as sugar for field-wise writes—the compiler already knows the destination, so lean on literals for clarity. xref:36__style-and-best-practices.adoc[36]
* Offer pointer-based `*_into` variants when parsing or formatting—they turn RLS into a conscious API lever instead of an implicit optimization. xref:04__errors-resource-cleanup.adoc[4]
* When unions carry large payloads, construct them inline so variants do not require heap allocations or temporary buffers. xref:08__user-types-structs-enums-unions.adoc[8]

[[notes-caveats]]
== Notes & Caveats

* Return slices from by-value methods (like `fn slice(self: Numbers)`) capture a temporary copy; prefer pointer receivers to keep the result location stable.
* Many standard-library builders accept result pointers—read their signatures before re-implementing similar plumbing yourself. link:https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig[fmt.zig]
* RLS bypasses no validation: if a sub-expression fails (for example, parsing errors), the partially written destination remains in your control, so remember to reset or discard it before reuse. xref:57__error-handling-patterns-cookbook.adoc[57]

[[exercises]]
== Exercises

* Extend `buildReport` to parameterize the bucket size, then inspect how nested loops still forward their destinations without copies. xref:36__style-and-best-practices.adoc[36]
* Add overflow detection to `parseInto`, so it rejects integers above a configurable limit, resetting the result buffer when the error fires. xref:57__error-handling-patterns-cookbook.adoc[57]
* Teach `lookup` to stream into a caller-provided scratch buffer when the payload exceeds 32 bytes, mirroring the pointer-based pattern from the previous section. xref:04__errors-resource-cleanup.adoc[4]

[[caveats-alternatives-edge-cases]]
== Alternatives & Edge Cases

* For `comptime` constructs, result locations may exist entirely in compile-time memory; use `@TypeOf` to confirm whether your data ever escapes to runtime. xref:15__comptime-and-reflection.adoc[15]
* When interfacing with C APIs that expect you to manage buffers, combine RLS with `extern` structs, so you match their layout while still avoiding intermediate copies. xref:33__c-interop-import-export-abi.adoc[33]
* Profile hot paths before micro-optimizing: sometimes using `std.ArrayList` or a streaming writer is clearer, and RLS will still erase intermediate temporaries for you. link:https://github.com/ziglang/zig/tree/master/lib/std/array_list.zig[array_list.zig]
