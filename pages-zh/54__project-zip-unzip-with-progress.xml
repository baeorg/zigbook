<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>Project</title>
<subtitle>Zip/Unzip with Progress</subtitle>
<date>2025-11-15</date>
</info>
<chapter xml:id="overview">
<title>概览</title>
<simpara>之前的项目专注于确定性文本分析；现在我们将这些工件和周围的诊断打包成一个可重现的归档流水线。<link xl:href="53__project-top-k-word-frequency-analyzer.xml">53</link> 我们将编写一个极简的 ZIP 创建器，它将文件流式传输到内存，发出中央目录，然后在报告增量进度的同时验证提取。该程序依赖于标准库的 ZIP 读取器、手动标头编码、用于 CRC32 检查的 <literal>StringHashMap</literal> 记账，以及通过 <literal>std.Progress</literal> 进行结构化状态更新。<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/zip.zig">zip.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/hash_map.zig">hash_map.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/hash/crc.zig">crc.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Progress.zig">Progress.zig</link></simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>从头开始组装一个 ZIP 归档，通过编写本地文件标头、中央目录和中央目录结尾记录，以正确的顺序同时遵守大小和偏移约束。</simpara>
</listitem>
<listitem>
<simpara>捕获确定性完整性指标（CRC32、SHA-256）与包一起，以便持续集成可以在每次运行时验证结构和内容。<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/crypto.zig">crypto.zig</link></simpara>
</listitem>
<listitem>
<simpara>显示对分析员友好的进度消息，通过禁用动画渲染器并使用 <literal>std.Progress</literal> 发出纯文本检查点来保持可脚本化。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="pipeline-design">
<title>设计流水线</title>
<simpara>工作流分三个阶段运行：生成样本文件、构建归档以及提取和验证。每个阶段增加根进度节点，产生确定性控制台摘要，同时作为验收标准。所有文件系统操作都在由 <literal>std.testing.tmpDir</literal> 管理的临时目录下进行，保持真实工作区的清洁。<link xl:href="47__time-logging-and-progress.xml">47</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/testing.zig">testing.zig</link></simpara>
<simpara>对于归档元数据，我们在编写标头和稍后验证提取的文件时重用相同的相对路径。在 <literal>StringHashMap</literal> 中存储每条路径的 CRC32 和字节计数，使我们能够以直接的方式比较提取后期望值与实际输出的差异。</simpara>
</chapter>
<chapter xml:id="archive-assembly">
<title>归档组装</title>
<simpara>由于 Zig 0.15.2 附带 ZIP 读取器而不是写入器，我们使用 <literal>ArrayList(u8)</literal> 在内存中构建归档，依次附加每个组件：本地文件标头、文件名、文件字节。每个标头字段都使用显式的小端助手编写，以便结果可在架构之间移植。一旦有效负载进入 blob，我们附加中央目录（每个文件一条记录）然后是中央目录结尾记录，反映 PKWARE APPNOTE 中定义并在 <literal>std.zip</literal> 中编码的结构。<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/array_list.zig">array_list.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig">fmt.zig</link></simpara>
<simpara>在编写标头时，我们确保大小和偏移适合 32 位字段（坚持经典 ZIP 子集）并将文件名复制一次到映射中，以便我们以后能够确定性地释放资源。归档镜像完成后，我们将其持久化到磁盘并计算 SHA-256 摘要以进行下游回归——摘要使用 <literal>std.fmt.bytesToHex</literal> 渲染，因此可以内联比较而无需任何额外的工具。</simpara>
</chapter>
<chapter xml:id="extraction-and-verification">
<title>提取和验证</title>
<simpara>提取重用标准库迭代器，它遍历每个中央目录记录并将数据流交给 <literal>std.zip.Entry.extract</literal>；我们通过 <literal>std.zip.Diagnostics</literal> 规范化根文件夹名称，以便我们可以将其呈现给调用者。每个文件落地到磁盘后，我们再次计算 CRC32 并将字节计数与记录的期望进行比较。任何不匹配都会立即使程序失败，使其安全地嵌入到 CI 流水线或部署挂钩中。</simpara>
<simpara><literal>std.Progress</literal> 节点驱动控制台输出：根节点跟踪三个高级阶段，而子节点在生成、构建和验证期间通过文件列表计数。因为打印被禁用，最终消息是普通文本行（通过缓冲的 stdout 写入器呈现），可以在自动化测试中逐字比较。<link xl:href="47__time-logging-and-progress.xml">47</link></simpara>
</chapter>
<chapter xml:id="code-listing">
<title>端到端实现</title>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 54__project-zip-unzip-with-progress.adoc - include::example$chapters-data/code/54__project-zip-unzip-with-progress/zip_progress_pipeline.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run zip_progress_pipeline.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">[1/3] seeded samples -&gt; files=4, bytes=250
[2/3] built archive -&gt; bytes=716
    sha256=4a13a3dc1e6ef90c252b0cc797ff14456aa28c670cafbc9d27a025b0079b05d5
[3/3] extracted + verified -&gt; files=4, bytes=250, root=input</programlisting>
</para>
</formalpara>
<simpara>验证步骤有意复制提取的根字符串，当诊断发现公共前缀时；摘要随后释放该缓冲区以保持通用分配器清洁。这反映了通过临时目录流式传输大型归档的 CLI 工具的良好卫生。<link xl:href="52__debug-and-valgrind.xml">52</link></simpara>
</chapter>
<chapter xml:id="notes-caveats">
<title>注意与警示</title>
<itemizedlist>
<listitem>
<simpara>写入器坚持经典（非 Zip64）子集；一旦文件超过 4 GiB，您必须升级标头和额外字段，或委托给专门的 ZIP 库。<link xl:href="44__collections-and-algorithms.xml">44</link></simpara>
</listitem>
<listitem>
<simpara>进度节点是嵌套的但打印被禁用；如果您想要实时 TTY 更新，删除 <literal>.disable_printing = true</literal> 并让渲染器清除帧。请记住，这样做会牺牲捕获日志中的确定性。<link xl:href="47__time-logging-and-progress.xml">47</link></simpara>
</listitem>
<listitem>
<simpara>CRC32 确认完整性但不确认真实性。将 SHA-256 摘要与签名结合或将归档附加到 <literal>zig build</literal> 步骤以实现可重现的部署流水线。<link xl:href="39__performance-and-inlining.xml">39</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>练习</title>
<itemizedlist>
<listitem>
<simpara>扩展构建器以在任何文件跨越 4 GiB 边界时发出 Zip64 记录。为小束保留传统路径并编写验证两者的回归测试。<link xl:href="33__c-interop-import-export-abi.xml">33</link></simpara>
</listitem>
<listitem>
<simpara>用流式写入器替换内存中的 blob，该写入器将块刷新到磁盘；在 <literal>perf</literal> 或 <literal>zig build test</literal> 下使用大型合成文件比较吞吐量和内存消耗。<link xl:href="41__cross-compilation-and-wasm.xml">41</link></simpara>
</listitem>
<listitem>
<simpara>添加一个命令行标志，在归档之前接受忽略列表（glob 模式），然后报告跳过的文件的确切数量以及现有总计。<link xl:href="36__style-and-best-practices.xml">36</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fs/Dir.zig">Dir.zig</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives">
<title>注意事项、替代方案与边界情况</title>
<itemizedlist>
<listitem>
<simpara>将归档直接流式传输到 stdout 对流水线很好，但使验证更棘手；考虑首先写入临时文件，以便在发送之前重新打开它进行校验和。<link xl:href="28__filesystem-and-io.xml">28</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fs/File.zig">File.zig</link></simpara>
</listitem>
<listitem>
<simpara>ZIP 加密故意超出范围。如果您需要保密性，请使用 <literal>std.crypto</literal> 原语包装结果文件或切换到使用 age 或 minisign 的加密 tarball 等格式。<link xl:href="45__text-formatting-and-unicode.xml">45</link></simpara>
</listitem>
<listitem>
<simpara>对于多千兆字节的语料库，分块读取输入并增量更新 CRC32 而不是调用 <literal>readToEndAlloc</literal>；否则临时分配器会膨胀。<link xl:href="10__allocators-and-memory-management.xml">10</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>