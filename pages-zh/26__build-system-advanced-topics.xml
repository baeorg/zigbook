<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>构建系统高级主题</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>概览</title>
<simpara>模块解析为我们提供了推理编译器图的词汇。现在我们将这些词汇转化为基础设施。本章深入探讨<literal>std.Build</literal>的基础知识之外，探索构件巡览和库/可执行工作区。我们将有意注册模块，组合多包工作区，在不接触shell脚本的情况下生成构建输出，并从单个<literal>build.zig</literal>驱动跨目标矩阵。参见<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build.zig">Build.zig</link>。</simpara>
<simpara>你将学习命名写入文件、匿名模块和<literal>resolveTargetQuery</literal>如何为构建运行器提供输入，如何保持vendored代码与注册表依赖隔离，以及如何连接CI作业来证明你的图在Debug和Release构建中表现一致。参见<link xl:href="https://github.com/ziglang/zig/blob/master/lib/compiler/build_runner.zig">build_runner.zig</link>。</simpara>
<section xml:id="_how_the_build_system_executes">
<title>构建系统如何执行</title>
<simpara>在进入高级模式之前，必须先理解<literal>std.Build</literal>的执行方式。下图展示了从 Zig 编译器调用你的<literal>build.zig</literal>脚本到最终制品安装的完整流程：</simpara>
<literallayout class="monospaced">graph TB
    subgraph "CMake Stage (stage2)"
        CMAKE["CMake"]
        ZIG2_C["zig2.c&lt;br/&gt;(generated C code)"]
        ZIGCPP["zigcpp&lt;br/&gt;(C++ LLVM/Clang wrapper)"]
        ZIG2["zig2 executable"]

        CMAKE --&gt; ZIG2_C
        CMAKE --&gt; ZIGCPP
        ZIG2_C --&gt; ZIG2
        ZIGCPP --&gt; ZIG2
    end

    subgraph "Native Build System (stage3)"
        BUILD_ZIG["build.zig&lt;br/&gt;Native Build Script"]
        BUILD_FN["build() function"]
        COMPILER_STEP["addCompilerStep()"]
        EXE["std.Build.Step.Compile&lt;br/&gt;(compiler executable)"]
        INSTALL["Installation Steps"]

        BUILD_ZIG --&gt; BUILD_FN
        BUILD_FN --&gt; COMPILER_STEP
        COMPILER_STEP --&gt; EXE
        EXE --&gt; INSTALL
    end

    subgraph "Build Arguments"
        ZIG_BUILD_ARGS["ZIG_BUILD_ARGS&lt;br/&gt;--zig-lib-dir&lt;br/&gt;-Dversion-string&lt;br/&gt;-Dtarget&lt;br/&gt;-Denable-llvm&lt;br/&gt;-Doptimize"]
    end

    ZIG2 --&gt;|"zig2 build"| BUILD_ZIG
    ZIG_BUILD_ARGS --&gt; BUILD_FN

    subgraph "Output"
        STAGE3_BIN["stage3/bin/zig"]
        STD_LIB["stage3/lib/zig/std/"]
        LANGREF["stage3/doc/langref.html"]
    end

    INSTALL --&gt; STAGE3_BIN
    INSTALL --&gt; STD_LIB
    INSTALL --&gt; LANGREF</literallayout>
<simpara>你的<literal>build.zig</literal>是由编译器编译并执行的普通 Zig 程序。入口是<literal>build()</literal>函数，它接收一个<literal>*std.Build</literal>实例，提供定义步骤、制品和依赖的 API。构建参数（<literal>-D</literal> 选项）由<literal>b.option()</literal>解析，并以编译期常量的形式流入你的构建逻辑。构建运行器随后遍历你声明的步骤依赖图，只执行满足所请求目标所需的步骤（默认是安装步骤）。这种声明式模型确保可复现性：相同的输入总是产生相同的构建图。</simpara>
</section>
</chapter>
<chapter xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>显式注册可复用模块与匿名包，控制哪些名称出现在导入命名空间。<link xl:href="25__module-resolution-and-discovery-deep.xml">25</link></simpara>
</listitem>
<listitem>
<simpara>使用具名写入文件从构建图生成可确定的制品（报告、清单），而非临时的 shell 脚本。</simpara>
</listitem>
<listitem>
<simpara>使用<literal>resolveTargetQuery</literal>协调多目标构建，包括宿主健康检查与跨编译流水线。<link xl:href="22__build-system-deep-dive.xml">22</link>，<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build/Step/Compile.zig">Compile.zig</link></simpara>
</listitem>
<listitem>
<simpara>构造复合工作区，使引入的 vendored 模块保持私有，同时注册表包保持自洽。<link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</listitem>
<listitem>
<simpara>在 CI 中固化可复现性：安装步骤、运行步骤与生成的制品全部依附于<literal>std.Build.Step</literal>的依赖关系。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="workspace-surface">
<title>构建工作区外层接口</title>
<simpara>工作区本质上是具有清晰命名空间边界的构建图。下例提升三个模块——<literal>analytics</literal>、<literal>reporting</literal>，以及一个引入的<literal>adapters</literal>助手——并展示根可执行文件如何消费它们。我们强调哪些模块是全局注册的，哪些保持匿名，以及如何直接从构建图发射文档。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 26__build-system-advanced-topics.adoc - include::example$chapters-data/code/26__build-system-advanced-topics/01_workspace_build.zig[]</programlisting>
<simpara><literal>build()</literal>函数遵循刻意的节奏：</simpara>
<itemizedlist>
<listitem>
<simpara><literal>b.addModule("analytics", …)</literal>注册一个公共名称，使整个工作区都能<literal>@import("analytics")</literal>。<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build/Module.zig">Module.zig</link></simpara>
</listitem>
<listitem>
<simpara><literal>b.createModule</literal>创建一个私有模块（<literal>adapters</literal>），仅根可执行文件可见——适合不应被消费者直接访问的 vendored 代码。<link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</listitem>
<listitem>
<simpara><literal>b.addNamedWriteFiles("workspace-graph")</literal>在<literal>zig-out/</literal>生成<literal>module-graph.txt</literal>，无需定制工具即可记录命名空间映射。</simpara>
</listitem>
<listitem>
<simpara>所有依赖都通过<literal>.imports</literal>穿线，编译器不再退回到文件系统猜测。<link xl:href="25__module-resolution-and-discovery-deep.xml">25</link></simpara>
</listitem>
</itemizedlist>
<formalpara><title>运行工作区应用</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build --build-file 01_workspace_build.zig run</programlisting>
</para>
</formalpara>
<formalpara><title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">metric: response_ms
count: 6
mean: 12.95
deviation: 1.82
profile: stable
json export: {
  "name": "response_ms",
  "mean": 12.950,
  "deviation": 1.819,
  "profile": "stable"
}</programlisting>
</para>
</formalpara>
<formalpara><title>生成模块图</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build --build-file 01_workspace_build.zig graph</programlisting>
</para>
</formalpara>
<formalpara><title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">No stdout expected.</programlisting>
</para>
</formalpara>
<note>
<simpara>具名写入文件遵循缓存：在无变更时重复运行<literal>zig build … graph</literal>是瞬时的。查看<literal>zig-out/graph/module-graph.txt</literal>以了解构建运行器输出的映射。</simpara>
</note>
<section xml:id="workspace-library-code">
<title>工作区的库代码</title>
<simpara>为保持示例自包含，模块与构建脚本并排存放。可按需调整，或替换为在<literal>build.zig.zon</literal>中声明的注册表依赖。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 26__build-system-advanced-topics.adoc - include::example$chapters-data/code/26__build-system-advanced-topics/workspace/analytics/lib.zig[]</programlisting>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 26__build-system-advanced-topics.adoc - include::example$chapters-data/code/26__build-system-advanced-topics/workspace/reporting/lib.zig[]</programlisting>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 26__build-system-advanced-topics.adoc - include::example$chapters-data/code/26__build-system-advanced-topics/workspace/adapters/vendored.zig[]</programlisting>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 26__build-system-advanced-topics.adoc - include::example$chapters-data/code/26__build-system-advanced-topics/workspace/app/main.zig[]</programlisting>
<tip>
<simpara>当你希望构建期辅助工具在无全局堆的情况下运行时，<literal>std.fmt.allocPrint</literal>与分配器配合良好。在 Zig 0.15.2 中发射 CSV 或 JSON 快照时优先选用它，而不是临时的<literal>ArrayList</literal>。参见<link xl:href="https://ziglang.org/download/0.15.1/release-notes.html#upgrading-stdiogetstdoutwriterprint">v0.15.2</link>与<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig">fmt.zig</link>。</simpara>
</tip>
</section>
<section xml:id="dependency-hygiene">
<title>依赖卫生检查清单</title>
<itemizedlist>
<listitem>
<simpara>以明确名称注册 vendored 模块，并仅通过<literal>.imports</literal>共享。除非确有需要让消费者直接导入，否则<emphasis role="strong">不要</emphasis>通过<literal>b.addModule</literal>泄露它们。</simpara>
</listitem>
<listitem>
<simpara>将<literal>zig-out/workspace-graph/module-graph.txt</literal>视为活文档。提交输出以便 CI 校验，或通过 diff 捕捉意外的命名空间变化。</simpara>
</listitem>
<listitem>
<simpara>对于注册表依赖，<literal>b.dependency()</literal>的句柄只转发一次，并用本地模块包裹起来，从而将升级噪音隔离。<link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_build_options_as_configuration">
<title>将构建选项作为配置</title>
<simpara>构建选项为工作区可配置性提供了强有力的机制。下图展示了命令行<literal>-D</literal>参数如何流经<literal>b.option()</literal>，通过<literal>b.addOptions()</literal>加入生成模块，并作为编译期常量通过<literal>@import("build_options")</literal>访问：</simpara>
<literallayout class="monospaced">graph LR
    subgraph "Command Line"
        CLI["-Ddebug-allocator&lt;br/&gt;-Denable-llvm&lt;br/&gt;-Dversion-string&lt;br/&gt;etc."]
    end

    subgraph "build.zig"
        PARSE["b.option()&lt;br/&gt;Parse options"]
        OPTIONS["exe_options =&lt;br/&gt;b.addOptions()"]
        ADD["exe_options.addOption()"]

        PARSE --&gt; OPTIONS
        OPTIONS --&gt; ADD
    end

    subgraph "Generated Module"
        BUILD_OPTIONS["build_options&lt;br/&gt;(auto-generated)"]
        CONSTANTS["pub const mem_leak_frames = 4;&lt;br/&gt;pub const have_llvm = true;&lt;br/&gt;pub const version = '0.16.0';&lt;br/&gt;etc."]

        BUILD_OPTIONS --&gt; CONSTANTS
    end

    subgraph "Compiler Source"
        IMPORT["@import('build_options')"]
        USE["if (build_options.have_llvm) { ... }"]

        IMPORT --&gt; USE
    end

    CLI --&gt; PARSE
    ADD --&gt; BUILD_OPTIONS
    BUILD_OPTIONS --&gt; IMPORT</literallayout>
<simpara>该模式对参数化工作区至关重要。使用<literal>b.option(bool, "feature-x", "Enable feature X")</literal>声明选项，然后调用<literal>options.addOption("feature_x", feature_x)</literal>使其在编译期可用。选项变化时生成模块将自动重建，确保二进制始终反映当前配置。此技术适用于版本字符串、特性开关、调试设置以及代码所需的任何构建期常量。</simpara>
</section>
</chapter>
<chapter xml:id="target-matrix">
<title>目标矩阵与发布通道</title>
<simpara>复杂项目通常会交付多套二进制：为贡献者提供调试工具、面向生产的 ReleaseFast 构建，以及用于自动化的 WASI 制品。与其为每个目标复制构建逻辑，不如组装一个遍历<literal>std.Target.Query</literal>定义的矩阵。</simpara>
<section xml:id="_understanding_target_resolution">
<title>理解目标解析</title>
<simpara>在遍历目标之前，理解<literal>b.resolveTargetQuery</literal>如何将部分规格转换为完整解析的目标非常重要。下图展示了解析过程：</simpara>
<literallayout class="monospaced">graph LR
    subgraph "User Input"
        Query["Target.Query"]
        Query --&gt; QCpu["cpu_arch: ?Cpu.Arch"]
        Query --&gt; QModel["cpu_model: CpuModel"]
        Query --&gt; QOs["os_tag: ?Os.Tag"]
        Query --&gt; QAbi["abi: ?Abi"]
    end

    subgraph "Resolution Process"
        Resolve["resolveTargetQuery()"]
        Query --&gt; Resolve
        Detection["Native Detection"]
        Defaults["Apply Defaults"]
        Detection --&gt; Resolve
        Defaults --&gt; Resolve
    end

    subgraph "Fully Resolved"
        Target["Target"]
        Resolve --&gt; Target
        Target --&gt; TCpu["cpu: Cpu"]
        Target --&gt; TOs["os: Os"]
        Target --&gt; TAbi["abi: Abi"]
        Target --&gt; TOfmt["ofmt: ObjectFormat"]
    end</literallayout>
<simpara>当你传入的<literal>Target.Query</literal>在 CPU 或 OS 字段为<literal>null</literal>时，解析器会检测你的本机平台并填充具体值。同样地，如果你指定了 OS 但未给出 ABI，解析器会为该 OS 应用默认 ABI（例如 Linux 的<literal>.gnu</literal>、Windows 的<literal>.msvc</literal>）。解析每个查询仅发生一次，并产生一个<literal>ResolvedTarget</literal>，其中包含完整指定的<literal>Target</literal>，以及值是否来自本机检测的元数据。理解这一点对跨编译至关重要：由于 CPU 型号与特性检测不同，<literal>.cpu_arch = .x86_64</literal>且<literal>.os_tag = .linux</literal>的查询在每个宿主平台上得到的解析目标可能不同。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 26__build-system-advanced-topics.adoc - include::example$chapters-data/code/26__build-system-advanced-topics/02_multi_target_matrix.zig[]</programlisting>
<simpara>关键技巧：</simpara>
<itemizedlist>
<listitem>
<simpara>预先声明一组<literal>{ name, query, optimize }</literal>组合。查询与<literal>zig build -Dtarget</literal>语义一致，同时保持类型检查。</simpara>
</listitem>
<listitem>
<simpara><literal>b.resolveTargetQuery</literal>将每个查询转换为<literal>ResolvedTarget</literal>，使模块继承规范的 CPU/OS 默认值。</simpara>
</listitem>
<listitem>
<simpara>将所有内容聚合到一个<literal>matrix</literal>步骤下可保持 CI 接线简洁：调用<literal>zig build -Drelease-mode=fast matrix</literal>（或保留默认），并让依赖确保制品存在。</simpara>
</listitem>
<listitem>
<simpara>作为矩阵的一部分运行第一个（宿主）目标，无需跨运行器仿真即可捕获回归。若需更深覆盖，在调用<literal>addRunArtifact</literal>之前启用<literal>b.enable_qemu</literal>/<literal>b.enable_wasmtime</literal>。</simpara>
</listitem>
</itemizedlist>
<formalpara><title>运行矩阵构建</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build --build-file 02_multi_target_matrix.zig matrix</programlisting>
</para>
</formalpara>
<formalpara><title>输出（宿主变体）</title>
<para>
<screen>target: x86_64-linux-gnu
optimize: Debug</screen>
</para>
</formalpara>
</section>
<section xml:id="_running_cross_compiled_targets">
<title>运行跨编译目标</title>
<simpara>当矩阵包含跨平台编译的目标时，实际运行二进制需要外部执行器。构建系统会根据宿主/目标兼容性自动选择合适的执行器：</simpara>
<literallayout class="monospaced">flowchart TD
    Start["getExternalExecutor(host, candidate)"]

    CheckMatch{"OS + CPU\ncompatible?"}
    CheckDL{"link_libc &amp;&amp;\nhas dynamic_linker?"}
    DLExists{"Dynamic linker\nexists on host?"}

    Native["Executor.native"]

    CheckRosetta{"macOS + arm64 host\n&amp;&amp; x86_64 target?"}
    Rosetta["Executor.rosetta"]

    CheckQEMU{"OS matches &amp;&amp;\nallow_qemu?"}
    QEMU["Executor.qemu\n(e.g., 'qemu-aarch64')"]

    CheckWasmtime{"target.isWasm() &amp;&amp;\nallow_wasmtime?"}
    Wasmtime["Executor.wasmtime"]

    CheckWine{"target.os == .windows\n&amp;&amp; allow_wine?"}
    Wine["Executor.wine"]

    CheckDarling{"target.os.isDarwin()\n&amp;&amp; allow_darling?"}
    Darling["Executor.darling"]

    BadDL["Executor.bad_dl"]
    BadOsCpu["Executor.bad_os_or_cpu"]

    Start --&gt; CheckMatch
    CheckMatch --&gt; |Yes|CheckDL
    CheckMatch --&gt; |No|CheckRosetta

    CheckDL --&gt; |No libc|Native
    CheckDL --&gt; |Has libc|DLExists
    DLExists --&gt; |Yes|Native
    DLExists --&gt; |No|BadDL

    CheckRosetta --&gt; |Yes|Rosetta
    CheckRosetta --&gt; |No|CheckQEMU

    CheckQEMU --&gt; |Yes|QEMU
    CheckQEMU --&gt; |No|CheckWasmtime

    CheckWasmtime --&gt; |Yes|Wasmtime
    CheckWasmtime --&gt; |No|CheckWine

    CheckWine --&gt; |Yes|Wine
    CheckWine --&gt; |No|CheckDarling

    CheckDarling --&gt; |Yes|Darling
    CheckDarling --&gt; |No|BadOsCpu</literallayout>
<simpara>在调用<literal>addRunArtifact</literal>之前，通过设置<literal>b.enable_qemu = true</literal>或<literal>b.enable_wasmtime = true</literal>在构建脚本中启用仿真器。在 macOS ARM 宿主上，x86_64 目标会自动使用 Rosetta 2。对于 Linux 的跨架构测试，当操作系统匹配时，QEMU 用户态仿真可透明运行 ARM/RISC-V/MIPS 二进制。WASI 目标需要 Wasmtime；而在 Linux 上运行 Windows 二进制可使用 Wine。若无可用执行器，运行步骤会以<literal>Executor.bad_os_or_cpu</literal>失败——请在代表性 CI 宿主上尽早通过矩阵覆盖测试进行检测。</simpara>
<caution>
<simpara>依赖本机系统库（如 glibc）的跨目标需要合适的 sysroot 包。在将这些组合加入生产流水线之前，设置<literal>ZIG_LIBC</literal>或配置<literal>b.libc_file</literal>。</simpara>
</caution>
</section>
</chapter>
<chapter xml:id="vendoring-vs-registry">
<title>Vendor 与注册表依赖</title>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">注册表优先</emphasis>：保持<literal>build.zig.zon</literal>哈希为权威，然后通过<literal>b.dependency()</literal>与<literal>module.addImport()</literal>注册每个依赖模块。<link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">本地引入优先</emphasis>：将源码置于<literal>deps/&lt;name&gt;/</literal>并用<literal>b.addAnonymousModule</literal>或<literal>b.createModule</literal>进行连接。在<literal>module-graph.txt</literal>中记录溯源，让协作者了解哪些代码被本地钉住。</simpara>
</listitem>
<listitem>
<simpara>无论选择何种策略，都在 CI 中记录一条策略：若<literal>zig out/workspace-graph/module-graph.txt</literal>出现意外变更则使步骤失败，或添加检查 vendored 目录 LICENSE 文件的 lint。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="ci-scenarios">
<title>CI 场景与自动化钩子</title>
<section xml:id="_step_dependencies_in_practice">
<title>步骤依赖的实践</title>
<simpara>理解构建步骤的组合方式可为 CI 流水线带来收益。下图展示了来自 Zig 编译器自身构建系统的真实步骤依赖图：</simpara>
<literallayout class="monospaced">graph TB
    subgraph "Installation Step (default)"
        INSTALL["b.getInstallStep()"]
    end

    subgraph "Compiler Artifacts"
        EXE_STEP["exe.step&lt;br/&gt;(compile compiler)"]
        INSTALL_EXE["install_exe.step&lt;br/&gt;(install binary)"]
    end

    subgraph "Documentation"
        LANGREF["generateLangRef()"]
        INSTALL_LANGREF["install_langref.step"]
        STD_DOCS_GEN["autodoc_test"]
        INSTALL_STD_DOCS["install_std_docs.step"]
    end

    subgraph "Library Files"
        LIB_FILES["installDirectory(lib/)"]
    end

    subgraph "Test Steps"
        TEST["test step"]
        FMT["test-fmt step"]
        CASES["test-cases step"]
        MODULES["test-modules step"]
    end

    INSTALL --&gt; INSTALL_EXE
    INSTALL --&gt; INSTALL_LANGREF
    INSTALL --&gt; LIB_FILES

    INSTALL_EXE --&gt; EXE_STEP
    INSTALL_LANGREF --&gt; LANGREF
    INSTALL --&gt; INSTALL_STD_DOCS
    INSTALL_STD_DOCS --&gt; STD_DOCS_GEN

    TEST --&gt; EXE_STEP
    TEST --&gt; FMT
    TEST --&gt; CASES
    TEST --&gt; MODULES

    CASES --&gt; EXE_STEP
    MODULES --&gt; EXE_STEP</literallayout>
<simpara>注意默认的安装步骤（<literal>zig build</literal>）依赖二进制安装、文档与库文件，但<emphasis role="strong">不</emphasis>依赖测试。与此同时，测试步骤依赖编译以及所有测试子步骤。此分离允许 CI 在并行作业中分别运行用于发布制品的<literal>zig build</literal>与用于验证的<literal>zig build test</literal>。借助内容寻址缓存，每个步骤仅在其依赖发生变化时执行。你可以在本地通过<literal>zig build --verbose</literal>或添加自定义步骤以转储依赖来检查该图。</simpara>
</section>
<section xml:id="_automation_patterns">
<title>自动化模式</title>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">制品校验</emphasis>：添加<literal>zig build graph</literal>作业，将<literal>module-graph.txt</literal>与已编译二进制一并上传。消费者可在版本间 diff 命名空间。</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">矩阵扩展</emphasis>：通过构建选项（<literal>-Dinclude-windows=true</literal>）参数化组合数组。使用<literal>b.option(bool, "include-windows", …)</literal>让 CI 在无需修改源码的情况下切换额外目标。</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">安全姿态</emphasis>：在矩阵运行前串接<literal>zig build --fetch</literal>（第 24 章），以便离线的跨作业运行之前填充缓存。参见<link xl:href="24__zig-package-manager-deep.xml">24</link>。</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">可复现性</emphasis>：让 CI 连续运行两次<literal>zig build install</literal>并断言两次运行间无文件变化。由于<literal>std.Build</literal>遵循内容哈希，除非输入改变，第二次调用应不做任何工作。</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_advanced_test_organization">
<title>高级测试组织</title>
<simpara>对于综合性项目，将测试按类别组织并应用矩阵需要谨慎的步骤组合。下图展示了生产级的测试层次结构：</simpara>
<literallayout class="monospaced">graph TB
    subgraph "Test Steps"
        TEST_STEP["test step&lt;br/&gt;(umbrella step)"]
        FMT["test-fmt&lt;br/&gt;Format checking"]
        CASES["test-cases&lt;br/&gt;Compiler test cases"]
        MODULES["test-modules&lt;br/&gt;Per-target module tests"]
        UNIT["test-unit&lt;br/&gt;Compiler unit tests"]
        STANDALONE["Standalone tests"]
        CLI["CLI tests"]
        STACK_TRACE["Stack trace tests"]
        ERROR_TRACE["Error trace tests"]
        LINK["Link tests"]
        C_ABI["C ABI tests"]
        INCREMENTAL["test-incremental&lt;br/&gt;Incremental compilation"]
    end

    subgraph "Module Tests"
        BEHAVIOR["behavior tests&lt;br/&gt;test/behavior.zig"]
        COMPILER_RT["compiler_rt tests&lt;br/&gt;lib/compiler_rt.zig"]
        ZIGC["zigc tests&lt;br/&gt;lib/c.zig"]
        STD["std tests&lt;br/&gt;lib/std/std.zig"]
        LIBC_TESTS["libc tests"]
    end

    subgraph "Test Configuration"
        TARGET_MATRIX["test_targets array&lt;br/&gt;Different architectures&lt;br/&gt;Different OSes&lt;br/&gt;Different ABIs"]
        OPT_MODES["Optimization modes:&lt;br/&gt;Debug, ReleaseFast&lt;br/&gt;ReleaseSafe, ReleaseSmall"]
        FILTERS["test-filter&lt;br/&gt;test-target-filter"]
    end

    TEST_STEP --&gt; FMT
    TEST_STEP --&gt; CASES
    TEST_STEP --&gt; MODULES
    TEST_STEP --&gt; UNIT
    TEST_STEP --&gt; STANDALONE
    TEST_STEP --&gt; CLI
    TEST_STEP --&gt; STACK_TRACE
    TEST_STEP --&gt; ERROR_TRACE
    TEST_STEP --&gt; LINK
    TEST_STEP --&gt; C_ABI
    TEST_STEP --&gt; INCREMENTAL

    MODULES --&gt; BEHAVIOR
    MODULES --&gt; COMPILER_RT
    MODULES --&gt; ZIGC
    MODULES --&gt; STD

    TARGET_MATRIX --&gt; MODULES
    OPT_MODES --&gt; MODULES
    FILTERS --&gt; MODULES</literallayout>
<simpara>总控测试步骤聚合所有测试类别，使你可通过<literal>zig build test</literal>运行完整套件。各类别也可单独调用（<literal>zig build test-fmt</literal>、<literal>zig build test-modules</literal>）以加快迭代。注意仅模块测试接收矩阵配置——格式校验与 CLI 测试不因目标而异。使用<literal>b.option([]const u8, "test-filter", …)</literal>让 CI 运行子集，并根据测试类型选择性应用优化模式。该模式可扩展到数百个测试文件，同时通过并行与缓存保持可管理的构建时间。</simpara>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>注意与警示</title>
<itemizedlist>
<listitem>
<simpara><literal>b.addModule</literal>在当前构建图中全局注册一个名称；<literal>b.createModule</literal>则使模块保持私有。混淆它们会导致意外的导入或符号缺失。<link xl:href="25__module-resolution-and-discovery-deep.xml">25</link></simpara>
</listitem>
<listitem>
<simpara>具名写入文件遵循缓存。如需从零再生成，请删除<literal>.zig-cache</literal>；否则该步骤可能让你误以为变更已生效，实则命中缓存。</simpara>
</listitem>
<listitem>
<simpara>遍历矩阵时，务必使用<literal>zig build uninstall</literal>（或自定义<literal>Step.RemoveDir</literal>）清理陈旧二进制，以避免跨版本混淆。</simpara>
</listitem>
</itemizedlist>
<section xml:id="_under_the_hood_dependency_tracking">
<title>底层原理：依赖跟踪</title>
<simpara>构建系统的缓存与增量行为依赖于编译器复杂的依赖跟踪基础设施。理解这一点有助于解释为何缓存构建如此之快，以及为何某些变更会触发超出预期的更大范围重建。</simpara>
<literallayout class="monospaced">graph TB
    subgraph "InternPool - Dependency Storage"
        SRCHASHDEPS["src_hash_deps&lt;br/&gt;Map: TrackedInst.Index → DepEntry.Index"]
        NAVVALDEPS["nav_val_deps&lt;br/&gt;Map: Nav.Index → DepEntry.Index"]
        NAVTYDEPS["nav_ty_deps&lt;br/&gt;Map: Nav.Index → DepEntry.Index"]
        INTERNEDDEPS["interned_deps&lt;br/&gt;Map: Index → DepEntry.Index"]
        ZONFILEDEPS["zon_file_deps&lt;br/&gt;Map: FileIndex → DepEntry.Index"]
        EMBEDFILEDEPS["embed_file_deps&lt;br/&gt;Map: EmbedFile.Index → DepEntry.Index"]
        NSDEPS["namespace_deps&lt;br/&gt;Map: TrackedInst.Index → DepEntry.Index"]
        NSNAMEDEPS["namespace_name_deps&lt;br/&gt;Map: NamespaceNameKey → DepEntry.Index"]

        FIRSTDEP["first_dependency&lt;br/&gt;Map: AnalUnit → DepEntry.Index"]
        DEPENTRIES["dep_entries&lt;br/&gt;ArrayListUnmanaged&lt;DepEntry&gt;"]
        FREEDEP["free_dep_entries&lt;br/&gt;ArrayListUnmanaged&lt;DepEntry.Index&gt;"]
    end

    subgraph "DepEntry Structure"
        DEPENTRY["DepEntry&lt;br/&gt;{depender: AnalUnit,&lt;br/&gt;next_dependee: DepEntry.Index.Optional,&lt;br/&gt;next_depender: DepEntry.Index.Optional}"]
    end

    SRCHASHDEPS --&gt; DEPENTRIES
    NAVVALDEPS --&gt; DEPENTRIES
    NAVTYDEPS --&gt; DEPENTRIES
    INTERNEDDEPS --&gt; DEPENTRIES
    ZONFILEDEPS --&gt; DEPENTRIES
    EMBEDFILEDEPS --&gt; DEPENTRIES
    NSDEPS --&gt; DEPENTRIES
    NSNAMEDEPS --&gt; DEPENTRIES
    FIRSTDEP --&gt; DEPENTRIES

    DEPENTRIES --&gt; DEPENTRY
    FREEDEP -.-&gt;|"reuses indices from"| DEPENTRIES</literallayout>
<simpara>编译器以多种粒度跟踪依赖：源文件哈希（<literal>src_hash_deps</literal>）、导航值（<literal>nav_val_deps</literal>）、类型（<literal>nav_ty_deps</literal>）、驻留常量、ZON 文件、嵌入文件与命名空间成员关系。这些映射都指向共享的<literal>dep_entries</literal>数组，其中包含形成链表的<literal>DepEntry</literal>结构。每个条目参与两条链：一条连接依赖某个被依赖者的所有分析单元（失效时遍历），另一条连接某个分析单元的所有被依赖者（清理时遍历）。当你修改源文件时，编译器为其哈希，在<literal>src_hash_deps</literal>中查找依赖者，并仅将那些分析单元标记为过时。这种细粒度跟踪使得在一个文件中更改私有函数不会重建无关模块——依赖图精确刻画了谁真正依赖于谁。构建系统通过内容寻址利用此基础设施：步骤输出以其输入哈希进行缓存，输入未变更时复用缓存。</simpara>
</section>
</chapter>
<chapter xml:id="exercises">
<title>练习</title>
<itemizedlist>
<listitem>
<simpara>扩展<literal>01_workspace_build.zig</literal>，使<literal>graph</literal>步骤同时输出人类可读表格与 JSON 文档。提示：使用<literal>std.json</literal>输出调用<literal>graph_files.add("module-graph.json", …)</literal>。参见<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/json.zig">json.zig</link>。</simpara>
</listitem>
<listitem>
<simpara>为<literal>02_multi_target_matrix.zig</literal>添加<literal>-Dtarget-filter</literal>选项，将矩阵执行限制为逗号分隔的允许列表。使用<literal>std.mem.splitScalar</literal>解析其值。<link xl:href="22__build-system-deep-dive.xml">22</link></simpara>
</listitem>
<listitem>
<simpara>通过<literal>b.dependency("logging", .{})</literal>引入一个注册表依赖，并使用<literal>module.addImport("logging", dep.module("logging"))</literal>向工作区暴露它。在<literal>module-graph.txt</literal>中记录新的命名空间。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>注意事项、替代方案与边界情况</title>
<itemizedlist>
<listitem>
<simpara>大型工作区可能超出默认安装目录限制。在添加制品前使用<literal>b.setInstallPrefix</literal>或<literal>b.setLibDir</literal>将输出路由到每个目标的专属目录。</simpara>
</listitem>
<listitem>
<simpara>在 Windows 上，若期望生成 MSVC 兼容制品，<literal>resolveTargetQuery</literal>需要<literal>abi = .msvc</literal>；默认的<literal>.gnu</literal> ABI 产生 MinGW 二进制。</simpara>
</listitem>
<listitem>
<simpara>若向依赖提供匿名模块，需注意它们不会去重。当多个制品需要相同的 vendored 代码时，请复用同一个<literal>b.createModule</literal>实例。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="summary">
<title>总结</title>
<itemizedlist>
<listitem>
<simpara>当你显式注册每个模块并通过具名写入文件记录映射时，工作区可保持可预期。</simpara>
</listitem>
<listitem>
<simpara><literal>resolveTargetQuery</literal>与迭代友好的组合，使你无需复制粘贴构建逻辑即可扩展到多目标。</simpara>
</listitem>
<listitem>
<simpara>CI 作业得益于<literal>std.Build</literal>原语：步骤清晰表达依赖，运行制品作为健康检查的闸门，具名制品捕捉可复现的元数据。</simpara>
</listitem>
</itemizedlist>
<simpara>结合第 22–25 章，你现已具备在包、目标与发布通道间扩展、并保持确定性的 Zig 构建图的工具。</simpara>
</chapter>
</book>