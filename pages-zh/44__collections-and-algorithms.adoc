////
changes: ["Initial collections and algorithms chapter"]
examples_compile: yes
keywords: ["ArrayList", "HashMap", "PriorityQueue", "sort", "collections"]
last_updated: 2025-11-06
last_verified: 2025-11-06
next_chapter: "45__text-formatting-and-unicode"
open_questions: []
previous_chapter: "43__stdlib-index"
status: draft
xref_complete: true
////

= Collections and Algorithms
:chapter-number: 44
:chapter-slug: collections-and-algorithms
:creative-commons:
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

With the stdlib index providing your map, you now dive into Zig's collection types—the workhorses of data manipulation. This chapter explores dynamic arrays (`ArrayList`), hash tables (`HashMap` and variants), priority structures (`PriorityQueue`), linked lists, specialized containers like `MultiArrayList` and `SegmentedList`, and sorting algorithms (see link:https://github.com/ziglang/zig/tree/master/lib/std/array_list.zig[array_list.zig] and link:https://github.com/ziglang/zig/tree/master/lib/std/hash_map.zig[hash_map.zig]). Each collection embraces Zig's explicit allocator model, giving you control over memory lifetime and enabling leak detection during testing.

Unlike languages with implicit garbage collection, Zig collections require you to `deinit()` or transfer ownership explicitly. This discipline, combined with the standard library's rich suite of adapters (unmanaged variants, sentinel-aware slices, custom contexts), makes collections both powerful and predictable. By chapter's end, you'll confidently choose the right structure for your use case and understand the performance trade-offs inherent in each design (see link:https://github.com/ziglang/zig/tree/master/lib/std/sort.zig[sort.zig]).

[[learning-goals]]
== Learning Goals

* Use `ArrayList(T)` for dynamic arrays: append, insert, remove, iterate, and understand reallocation strategies.
* Employ `HashMap` and `AutoHashMap` for key-value lookups with custom hash and equality functions.
* Leverage `PriorityQueue` for min/max heap operations and understand comparison contexts (see link:https://github.com/ziglang/zig/tree/master/lib/std/priority_queue.zig[priority_queue.zig]).
* Apply `std.sort` for in-place sorting with stable and unstable algorithms (pdqsort, block sort, insertion sort).
* Recognize specialized structures: `MultiArrayList` for structure-of-arrays layout, `SegmentedList` for stable pointers, linked lists for intrusive designs (see link:https://github.com/ziglang/zig/tree/master/lib/std/multi_array_list.zig[multi_array_list.zig] and link:https://github.com/ziglang/zig/tree/master/lib/std/segmented_list.zig[segmented_list.zig]).
* Appreciate allocator impact: how collection growth triggers reallocation and how arenas simplify bulk-free patterns (see xref:10__allocators-and-memory-management.adoc[10]).

[[arraylist]]
== ArrayList: Dynamic Arrays

`ArrayList(T)` is Zig's foundational growable array, analogous to C++'s `std::vector` or Rust's `Vec<T>`. It manages a contiguous slice of `T` values, expanding capacity as needed. You interact with `.items` (the current slice) and call methods like `append`, `pop`, `insert`, and `remove`.

[[arraylist-basics]]
=== Basic Operations

Create an `ArrayList` by specifying the element type and passing an allocator. Call `deinit()` when done to free the backing memory.

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/arraylist_basic.zig[]
----

.Build
[source,shell]
----
$ zig build-exe arraylist_basic.zig
----

.Run
[source,shell]
----
$ ./arraylist_basic
----

.Output
[source,shell]
----
Item 0: 10
Item 1: 20
Item 2: 30
Popped: 30
Remaining length: 2
----

TIP: `ArrayList` doubles capacity when full (exponential growth), amortizing reallocation cost. You can pre-allocate with `try list.ensureTotalCapacity(allocator, n)` if you know the final size.

[[arraylist-ownership]]
=== Ownership and Unmanaged Variants

By default, `ArrayList(T)` stores its allocator internally (managed variant). For more explicit control, use the unmanaged form by accessing `.items` and `.capacity` directly, or use the deprecated `Unmanaged` APIs. The modern pattern is to use the simpler managed form unless you need to decouple allocation from the list itself.

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/arraylist_ownership.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe arraylist_ownership.zig && ./arraylist_ownership
----

.Output
[source,shell]
----
Managed list length: 3
After transfer, original list length: 0
Owned slice length: 3
----

NOTE: `toOwnedSlice()` empties the list and returns the backing memory as a slice—you become responsible for freeing it with `allocator.free(slice)`.

[[arraylist-insertion-removal]]
=== Insertion and Removal

Beyond `append` and `pop`, `ArrayList` supports mid-array operations. `orderedRemove` maintains element order (shifts subsequent elements), while `swapRemove` is O(1) but doesn't preserve order (swaps with the last element).

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/arraylist_insert_remove.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe arraylist_insert_remove.zig && ./arraylist_insert_remove
----

.Output
[source,shell]
----
After insert at 1: [1, 99, 2, 3, 4]
After orderedRemove at 2: [1, 99, 3, 4]
After swapRemove at 1: [1, 4, 3]
----

IMPORTANT: `orderedRemove` is O(n) in the worst case (removing the first element requires shifting all others); use `swapRemove` when order doesn't matter for O(1) performance.

[[hashmap]]
== HashMap: Key-Value Lookups

Zig's hash map family provides O(1) average-case lookups via open addressing and linear probing. `HashMap(K, V, Context, max_load_percentage)` requires a context with `hash` and `eql` functions. For convenience, `AutoHashMap` auto-generates these for hashable types, and `StringHashMap` specializes for `[]const u8` keys.

[[hashmap-basic]]
=== StringHashMap Basics

For string keys (`[]const u8`), use `StringHashMap(V)` which provides optimized string hashing. Note that `AutoHashMap` does not support slice types like `[]const u8` to avoid ambiguity—use `StringHashMap` instead.

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/hashmap_basic.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe hashmap_basic.zig && ./hashmap_basic
----

.Output
[source,shell]
----
Value for 'foo': 42
Contains 'bar': true
Contains 'baz': false
After removing 'foo', contains: false
----

TIP: Use `put` to insert or update, `get` to retrieve (returns `?V`), and `remove` to delete. Check existence with `contains` without retrieving the value.

[[hashmap-string]]
=== StringHashMap for String Keys

When keys are `[]const u8`, use `StringHashMap(V)` for optimized string hashing. Remember: the map doesn't copy key memory—you must ensure strings outlive the map or use an arena allocator.

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/hashmap_string.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe hashmap_string.zig && ./hashmap_string
----

.Output
[source,shell]
----
City: Seattle, Population: 750000
City: Austin, Population: 950000
City: Boston, Population: 690000
----

IMPORTANT: String keys are not duplicated by the map—if you pass stack-allocated or temporary strings, they must remain valid. Use an arena allocator or `dupe` to manage key lifetimes.

[[hashmap-custom]]
=== Custom Hash and Equality

For types not supported by `autoHash`, define a context with custom `hash` and `eql` functions.

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/hashmap_custom.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe hashmap_custom.zig && ./hashmap_custom
----

.Output
[source,shell]
----
Point(10, 20): Alice
Point(30, 40): Bob
Contains (10, 20): true
----

NOTE: The context parameter in `HashMap(K, V, Context, max_load_percentage)` allows stateful hashing (e.g., salted hashes). For stateless contexts, pass `void`.

[[priorityqueue]]
== PriorityQueue: Heap-Based Priority Structures

`PriorityQueue(T, Context, compareFn)` implements a binary min-heap or max-heap depending on your comparison function. It supports `add`, `peek`, `remove` (pop the top element), and `removeIndex`.

[[priorityqueue-basic]]
=== Min-Heap Example

A min-heap pops the smallest element first. The comparison function returns `.lt` when the first argument should come before the second.

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/priorityqueue_min.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe priorityqueue_min.zig && ./priorityqueue_min
----

.Output
[source,shell]
----
Popped: 1
Popped: 5
Popped: 10
Popped: 20
----

TIP: For a max-heap, reverse the comparison logic: return `.gt` when `a < b`.

[[priorityqueue-tasks]]
=== Priority Queue for Task Scheduling

Priority queues excel at scheduling: add tasks with priorities, then always process the highest-priority task first.

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/priorityqueue_tasks.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe priorityqueue_tasks.zig && ./priorityqueue_tasks
----

.Output
[source,shell]
----
Processing: Critical bug (priority 10)
Processing: Feature request (priority 5)
Processing: Documentation (priority 1)
----

NOTE: `PriorityQueue` uses a heap internally, so `add` is O(log n), `peek` is O(1), and `remove` is O(log n).

[[sorting]]
== Sorting

Zig's `std.sort` module provides multiple algorithms: `insertion` (stable, O(n²)), `heap` (unstable, O(n log n)), `pdq` (pattern-defeating quicksort, O(n log n) worst-case), and `block` (stable, O(n log n) with extra memory). The default recommendation is `pdq` for most use cases.

[[sort-basic]]
=== Basic Sorting

Call `std.sort.pdq` with a slice, a context, and a `lessThan` function.

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/sort_basic.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe sort_basic.zig && ./sort_basic
----

.Output
[source,shell]
----
Sorted ascending: [1, 2, 5, 8, 10]
Sorted descending: [10, 8, 5, 2, 1]
----

TIP: `pdq` is unstable but fast. Use `block` if you need stability (equal elements retain their original order).

[[sort-structs]]
=== Sorting Structs

Sort by struct fields by providing a custom comparison function.

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/sort_structs.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe sort_structs.zig && ./sort_structs
----

.Output
[source,shell]
----
Sorted by age:
Alice, age 30
Bob, age 25
Charlie, age 35
----

NOTE: The context parameter in sorting functions can hold state (e.g., sort direction flags or comparison modifiers). Use `anytype` for flexibility.

[[multiarraylist]]
== MultiArrayList: Structure-of-Arrays Layout

`MultiArrayList(T)` stores structs in a structure-of-arrays (SoA) format: each field is stored in its own contiguous array, improving cache locality when accessing individual fields across many elements.

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/multiarraylist.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe multiarraylist.zig && ./multiarraylist
----

.Output
[source,shell]
----
Entity 0: id=1, x=10.5, y=20.3
Entity 1: id=2, x=30.1, y=40.7
Sum of x coordinates: 40.6
----

TIP: Use `MultiArrayList` when you frequently iterate over a single field (e.g., positions in a game engine) but rarely need the entire struct. This layout maximizes CPU cache efficiency.

[[segmentedlist]]
== SegmentedList: Stable Pointers

`SegmentedList(T, prealloc_item_count)` grows by allocating fixed-size segments rather than reallocating a single contiguous array. This ensures pointers to elements remain valid across insertions.

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/segmentedlist.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe segmentedlist.zig && ./segmentedlist
----

.Output
[source,shell]
----
First item: 10
First item (after append): 10
List length: 3
----

IMPORTANT: Unlike `ArrayList`, pointers to `SegmentedList` elements remain valid even as you add more items. Use this when you need stable addressing (e.g., storing pointers in other data structures).

[[linkedlists]]
== Linked Lists

Zig provides `DoublyLinkedList(T)` and `SinglyLinkedList(T)` as intrusive linked lists: nodes embed the link pointers directly (see link:https://github.com/ziglang/zig/tree/master/lib/std/DoublyLinkedList.zig[DoublyLinkedList.zig] and link:https://github.com/ziglang/zig/tree/master/lib/std/SinglyLinkedList.zig[SinglyLinkedList.zig]). This avoids allocator overhead per node and integrates naturally with existing structs.

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/linkedlist.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe linkedlist.zig && ./linkedlist
----

.Output
[source,shell]
----
Node: 10
Node: 20
Node: 30
----

NOTE: Intrusive lists don't own node memory—you allocate and manage nodes yourself. This is powerful but requires discipline to avoid use-after-free bugs.

[[specialized-maps]]
== Specialized Maps

=== ArrayHashMap

`ArrayHashMap` stores keys and values in separate arrays, preserving insertion order and enabling iteration by index (see link:https://github.com/ziglang/zig/tree/master/lib/std/array_hash_map.zig[array_hash_map.zig]).

=== StaticStringMap

`StaticStringMap(V)` is a compile-time perfect hash map for string keys—fast lookups with zero runtime allocation or hashing overhead (see link:https://github.com/ziglang/zig/tree/master/lib/std/static_string_map.zig[static_string_map.zig]).

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/static_string_map.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe static_string_map.zig && ./static_string_map
----

.Output
[source,shell]
----
Status code for 'ok': 200
Status code for 'not_found': 404
Status code for 'server_error': 500
----

TIP: Use `StaticStringMap` for compile-time constant mappings (e.g., keyword tables, command parsers). It compiles to optimal switch statements or lookup tables.

[[allocator-impact]]
== Allocator Impact on Collections

Every collection requires an allocator, either passed at initialization (`ArrayList(T).init(allocator)`) or per operation (unmanaged variants). Growth strategies trigger reallocations, and failure returns `error.OutOfMemory` (see xref:10__allocators-and-memory-management.adoc[10]).

[[arena-pattern]]
=== Arena Pattern for Bulk-Free

When building temporary collections that live for a single scope, use an arena allocator to free everything at once.

[source,zig]
----
include::{sourcedir}/44__collections-and-algorithms/collections_arena.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe collections_arena.zig && ./collections_arena
----

.Output
[source,shell]
----
List has 1000 items
Map has 500 entries
All freed at once via arena.deinit()
----

NOTE: The arena doesn't call individual collection `deinit()` methods. It frees all memory at once. Use this pattern when you know collections won't outlive the arena's scope (see xref:10__allocators-and-memory-management.adoc[10]).

[[performance-considerations]]
== Performance Considerations

* **ArrayList growth**: Doubling capacity amortizes reallocation cost, but large allocations may fail. Pre-allocate if size is known.
* **HashMap load factor**: Default `max_load_percentage` is 80%. Higher values save memory but increase collision chains.
* **Sort stability**: `pdq` is fastest but unstable. Use `block` or `insertion` when order of equal elements matters.
* **MultiArrayList cache**: SoA layout shines when iterating single fields but adds indirection overhead for full-struct access.
* **SegmentedList segments**: Smaller `prealloc_item_count` means more segments (more allocations); larger values waste memory if lists stay small.

[[exercises]]
== Exercises

* Implement a `FrequencyMap` using `StringHashMap(u32)` that counts word occurrences in a text file, then print the top-10 most frequent words using a `PriorityQueue`.
* Compare `ArrayList` vs `SegmentedList` performance: create 10,000 items, take pointers to the first 100, then append 10,000 more. Verify pointers remain valid with `SegmentedList` but may invalidate with `ArrayList`.
* Write an `LRU` cache using `HashMap` for lookups and `DoublyLinkedList` for eviction order. When capacity is reached, remove the least-recently-used item.
* Sort an `ArrayList` of structs by multiple keys (e.g., sort by `age`, then by `name` for ties) using a custom comparator and `std.sort.pdq`.

[[caveats-alternatives-edge-cases]]
== Caveats, Alternatives, Edge Cases

* **Unmanaged variants**: Most collections have unmanaged counterparts (e.g., `ArrayListUnmanaged(T)`) for manual allocator threading, useful in generic code or when embedding collections in structs.
* **HashMap key lifetimes**: Maps don't duplicate keys. Ensure key memory outlives the map, or use an arena allocator to manage key storage collectively.
* **Iterator invalidation**: Like C++, modifying a collection (append, remove) may invalidate iterators or pointers to elements. Always check documentation for each operation.
* **Stable vs unstable sort**: If your data has equal elements that must maintain relative order (e.g., sorting a table by column but preserving row order for ties), use `std.sort.block` or `insertion`, not `pdq`.
* **Treap**: Zig also provides `std.Treap`, a tree-heap hybrid for ordered maps with probabilistic balancing, useful when you need both sorted iteration and O(log n) operations (see link:https://github.com/ziglang/zig/tree/master/lib/std/treap.zig[treap.zig]).
