////
changes: ["Draft inline assembly deep-dive appendix"]
examples_compile: yes
keywords: ["asm", "x86", "intrinsics"]
last_updated: 2025-11-13
last_verified: 2025-11-13
next_chapter: "60__advanced-result-location-semantics"
open_questions: []
previous_chapter: "58__mapping-c-rust-idioms"
status: draft
xref_complete: true
////

= Appendix E. Advanced Inline Assembly
:chapter-number: 59
:chapter-slug: advanced-inline-assembly
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Inline assembly grants you the power to reach below Zig's abstractions when you need one-off instructions, interoperability with legacy ABIs, or access to processor features not yet wrapped by the standard library. xref:33__c-interop-import-export-abi.adoc[33] Zig 0.15.2 hardened inline assembly by enforcing alignment checks for pointer casts and providing clearer constraint diagnostics, making it both safer and easier to debug than previous releases. link:https://ziglang.org/download/0.15.1/release-notes.html[v0.15.2]

[[learning-goals]]
== Learning Goals

* Recognize the structure of Zig’s GNU-style inline assembly blocks and map operands to registers or memory.
* Apply register and clobber constraints to orchestrate data flow between Zig variables and machine instructions.
* Guard architecture-specific snippets with compile-time checks so your build fails fast on unsupported targets.

[[asm-shapes]]
== Shaping Assembly Blocks

Zig adopts the familiar GCC/Clang inline assembly layout: a template string followed by colon-separated outputs, inputs, and clobbers. Start with simple arithmetic to get comfortable with operand binding before you reach for more exotic instructions. The first example uses `addl` to combine two 32-bit values, binding both operands to registers without touching memory. link:https://github.com/ziglang/zig/tree/master/lib/std/os/plan9/x86_64.zig[x86_64.zig]

[source,zig]
----
include::{sourcedir}/59__advanced-inline-assembly/01_inline_add.zig[]
----

.Run
[source,shell]
----
$ zig test chapters-data/code/59__advanced-inline-assembly/01_inline_add.zig
----

.Output
[source,shell]
----
All 1 tests passed.
----

TIP: Operand placeholders such as `%[lhs]` reference the symbolic names you assign in the constraint list; keeping those names mnemonic pays off once your templates grow beyond a single instruction. xref:58__mapping-c-rust-idioms.adoc[58]

[[register-choreography]]
== Register Choreography Without Footguns

More complex snippets often need bidirectional operands (read/write) or additional bookkeeping once the instruction finishes. The `xchg` sequence below swaps two integers entirely in registers, then writes the updated values back to Zig-managed memory. xref:04__errors-resource-cleanup.adoc[4] Guarding the function with `@compileError` prevents accidental use on non-x86 platforms, while the `+r` constraint indicates that each operand is both read and written. link:https://github.com/ziglang/zig/tree/master/lib/std/pie.zig[pie.zig]

[source,zig]
----
include::{sourcedir}/59__advanced-inline-assembly/02_xchg_swap.zig[]
----

.Run
[source,shell]
----
$ zig test chapters-data/code/59__advanced-inline-assembly/02_xchg_swap.zig
----

.Output
[source,shell]
----
All 1 tests passed.
----

NOTE: Because the swap operates only on registers, you stay clear of tricky memory constraints; when you do need to touch memory directly, add an explicit `"memory"` clobber so Zig’s optimizer does not reorder surrounding loads or stores. xref:36__style-and-best-practices.adoc[36]

[[observability]]
== Observability and Guard Rails

Once you trust the syntax, inline assembly becomes a precision tool for hardware-provided counters or instructions not yet surfaced elsewhere. Reading the x86 time-stamp counter with `rdtsc` gives you cycle-level timing while demonstrating multi-output constraints and the new alignment assertions introduced in 0.15.x. xref:39__performance-and-inlining.adoc[39] The example bundles the low and high halves of the counter into a `u64` and falls back to a compile error on non-x86_64 targets.

[source,zig]
----
include::{sourcedir}/59__advanced-inline-assembly/03_rdtsc.zig[]
----

.Run
[source,shell]
----
$ zig test chapters-data/code/59__advanced-inline-assembly/03_rdtsc.zig
----

.Output
[source,shell]
----
All 1 tests passed.
----

CAUTION: Instructions like `rdtsc` can reorder around other operations; consider pairing them with serializing instructions (e.g. `lfence`) or explicit memory clobbers when precise measurement matters. xref:39__performance-and-inlining.adoc[39]

[[patterns]]
== Patterns to Keep on Hand

* Wrap architecture-specific blocks in `if (builtin.cpu.arch != …) @compileError` guards so cross-compilation fails early. xref:41__cross-compilation-and-wasm.adoc[41]
* Prefer register-only operands when prototyping—once the logic is correct, introduce memory operands and clobbers deliberately. xref:33__c-interop-import-export-abi.adoc[33]
* Treat inline assembly as an escape hatch; if the standard library (or builtins) exposes the instruction, prefer that higher-level API to stay portable. link:https://github.com/ziglang/zig/tree/master/lib/std/mem.zig[mem.zig]

[[notes-caveats]]
== Notes & Caveats

* Inline assembly is target-specific; always document the minimum CPU features required and consider feature probes before executing the block. xref:29__threads-and-atomics.adoc[29]
* Clobber lists matter—forgetting `"cc"` or `"memory"` may lead to miscompilations that only surface under optimization. xref:36__style-and-best-practices.adoc[36]
* When mixing Zig and foreign ABIs, double-check the calling convention and register preservation rules; the compiler will not save registers for you. link:https://github.com/ziglang/zig/tree/master/lib/std/builtin.zig[builtin.zig]

[[exercises]]
== Exercises

* Add an `lfence` instruction before `rdtsc` and measure the impact on stability; compare results in Debug and ReleaseFast builds. xref:39__performance-and-inlining.adoc[39]
* Extend `swapXchg` with a `"memory"` clobber and benchmark the difference when swapping values in a tight loop. link:https://github.com/ziglang/zig/tree/master/lib/std/time.zig[time.zig]
* Rewrite `addAsm` using a compile-time format string that emits `add` or `sub` based on a boolean parameter. xref:15__comptime-and-reflection.adoc[15]

[[caveats-alternatives-edge-cases]]
== Alternatives & Edge Cases

* Some instructions (e.g., privileged system calls) require elevated privileges—wrap them in runtime checks so they never execute inadvertently. xref:48__process-and-environment.adoc[48]
* On microarchitectures with out-of-order execution, pair timing reads with fences to avoid skewed measurements. xref:39__performance-and-inlining.adoc[39]
* For portable timing, prefer `std.time.Timer` or platform APIs and reserve inline assembly for truly architecture-specific hot paths.
