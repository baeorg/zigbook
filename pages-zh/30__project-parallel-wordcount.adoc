////
changes: ["Introduced parallel wordcount project", "Implemented thread sharding and atomic-safe merging"]
examples_compile: yes
keywords: ["threads", "wordcount", "hashmap", "sharding"]
last_updated: 2025-11-05
last_verified: 2025-11-05
next_chapter: "31__networking-http-and-json"
open_questions: []
previous_chapter: "29__threads-and-atomics"
status: draft
xref_complete: true
////

= Project: Parallel Wordcount
:chapter-number: 30
:chapter-slug: project-parallel-wordcount
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Armed with the concurrency primitives from the last chapter, we’ll build a small but useful tool: a parallel word counter that reads a file, shards it into contiguous segments along whitespace, spins up worker threads to tokenize and tally, then merges thread-local maps into a final frequency table. See xref:29__threads-and-atomics.adoc[29], link:https://github.com/ziglang/zig/tree/master/lib/std/Thread.zig[Thread.zig], and link:https://github.com/ziglang/zig/tree/master/lib/std/atomic.zig[atomic.zig].

Why this project? It exercises common systems patterns—work decomposition, avoiding false sharing, ownership of string keys, and memory order discipline—without drowning in boilerplate. The result is a robust skeleton you can adapt to log crunching, grep-like indexing, or lightweight analytics.

[[learning-goals]]
== Learning Goals

* Partition inputs into shards while respecting token boundaries.
* Use `std.Thread.spawn` safely and fall back to inline execution in single‑threaded builds.
* Maintain per‑thread `std.StringHashMap` instances and merge them without dangling pointers.
* Present a deterministic “Top N” by sorting a vector of key/value pairs.

[[project-setup]]
== Project layout and build

We keep this sample as a tiny package with a local build. The 0.15.2 build API constructs an explicit module and passes it to `addExecutable`—note the `root_module` field rather than the old `root_source_file`.

[source,zig]
----
include::{sourcedir}/30__project-parallel-wordcount/build.zig[]
----
See link:https://github.com/ziglang/zig/tree/master/lib/std/Build.zig[Build.zig].

[[implementation]]
== Implementation

The program reads an entire file into memory (bounded by a reasonable cap), creates shard boundaries at whitespace, and then launches N workers (N=CPU count unless in single‑threaded mode). Each worker tokenizes and lowercases ASCII, strips punctuation, and inserts into its own map backed by an arena to avoid per‑token frees. At merge time, we duplicate keys into the final map’s allocator so deinitializing arenas doesn’t invalidate keys.

[source,zig]
----
include::{sourcedir}/30__project-parallel-wordcount/src/main.zig[]
----
See link:https://github.com/ziglang/zig/tree/master/lib/std/hash_map.zig[hash_map.zig] and link:https://github.com/ziglang/zig/tree/master/lib/std/mem/tokenize.zig[tokenize.zig].

.Run
[source,shell]
----
$ zig build --build-file chapters-data/code/30__project-parallel-wordcount/build.zig run -- chapters-data/code/30__project-parallel-wordcount/data/lines.txt
----

.Output
[source,shell]
----
top 10 words in 8 shards:
and 2
i 2
little 2
me 2
the 2
a 1
about 1
ago—never 1
call 1
how 1
----

TIP: `StringHashMap` stores string slices by reference; it does not copy bytes. When merging maps that point into short‑lived arenas, duplicate the key bytes into the destination allocator, then free them when you’re done. The example iterates and frees keys just before exit.

[[notes-caveats]]
== Notes & Caveats

* Sharding pushes shard ends forward to the next whitespace to avoid splitting tokens mid‑word. That means shards may be uneven; that’s fine for an I/O‑bound tool.
* The sample lowercases ASCII and strips punctuation crudely to stay focused on threading. If you need Unicode segmentation, integrate `std.unicode` and a more faithful normalization.
* In single‑threaded builds (`-Dsingle-threaded=true`), we execute workers inline and skip spawning entirely, mirroring the pattern from Chapter 29.

[[exercises]]
== Exercises

* Add `-n <N>` to print the top N words, parsing flags with `std.process.argsWithAllocator`.
* Switch the merge phase to a parallel reduction: pairwise merge per CPU until one map remains; measure scalability.
* Replace the arena with a bump allocator sized via `file size / shards` and reason about fragmentation vs. peak footprint.

[[summary]]
== Summary

This project distills a practical, fast path from bytes on disk to a sorted frequency table while respecting Zig’s ownership and threading model. It consolidates sharding, per‑thread maps, and safe merging—a minimal template ready for larger pipelines.
