<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>Zig 初始化与包元数据</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>概述</title>
<simpara>第20章建立了区分模块、程序、包和库的词汇表；本章展示<literal>zig init</literal>如何将这些词汇引导到实际文件中，以及<literal>build.zig.zon</literal>如何将包身份、版本约束和依赖元数据编码化，以便构建系统和包管理器能够可靠地解析导入。参见<link xl:href="20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.xml">20</link>和<link xl:href="https://ziglang.org/download/0.15.1/release-notes.html">v0.15.2</link>。</simpara>
<simpara>在第22章深入构建图编写之前，我们专注于包元数据结构，确保您理解<literal>build.zig.zon</literal>中每个字段控制什么，以及为什么Zig的指纹机制取代了早期的基于UUID的方案。参见<link xl:href="22__build-system-deep-dive.xml">22</link>、<link xl:href="https://github.com/ziglang/zig/blob/master/lib/init/build.zig.zon">build.zig.zon</link>和<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build.zig">Build.zig</link>。</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>使用<literal>zig init</literal>和<literal>zig init --minimal</literal>为模块、可执行文件和测试搭建具有适当样板的新项目。</simpara>
</listitem>
<listitem>
<simpara>解释<literal>build.zig.zon</literal>中的每个字段：名称、版本、指纹、最小Zig版本、依赖项和路径。</simpara>
</listitem>
<listitem>
<simpara>区分远程依赖项（URL + 哈希）、本地依赖项（路径）和延迟依赖项（延迟获取）。</simpara>
</listitem>
<listitem>
<simpara>解释为什么指纹提供全局唯一的包身份以及它们如何防止恶意分支混淆。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="zig-init-basics">
<title>使用<literal>zig init</literal>搭建项目</title>
<simpara>Zig 0.15.2更新了默认的<literal>zig init</literal>模板，鼓励将可重用模块与可执行入口点分离，解决了新用户常见的困惑，即库代码被不必要地编译为静态存档而不是作为纯Zig模块暴露。参见<link xl:href="https://github.com/ziglang/zig/blob/master/lib/init/build.zig">build.zig</link>。</simpara>
<section xml:id="default-template">
<title>默认模板：模块 + 可执行文件</title>
<simpara>在空目录中运行<literal>zig init</literal>会生成四个文件，展示了既需要可重用模块又需要CLI工具的项目的推荐模式：</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ mkdir myproject &amp;&amp; cd myproject
$ zig init
info: created build.zig
info: created build.zig.zon
info: created src/main.zig
info: created src/root.zig
info: see `zig build --help` for a menu of options</programlisting>
<simpara>生成的结构分离了关注点：</simpara>
<itemizedlist>
<listitem>
<simpara><literal>src/root.zig</literal>: 可重用模块，暴露公共API（例如 <literal>bufferedPrint</literal>, <literal>add</literal>）</simpara>
</listitem>
<listitem>
<simpara><literal>src/main.zig</literal>: 可执行入口点，导入并使用模块</simpara>
</listitem>
<listitem>
<simpara><literal>build.zig</literal>: 构建图，连接模块和可执行产物</simpara>
</listitem>
<listitem>
<simpara><literal>build.zig.zon</literal>: 包元数据，包括名称、版本和指纹</simpara>
</listitem>
</itemizedlist>
<simpara>这种布局使得外部包可以轻松依赖您的模块，而无需继承不必要的可执行代码，同时仍然为本地开发或分发提供方便的CLI。<link xl:href="20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.xml">20</link></simpara>
<tip>
<simpara>如果您只需要模块或只需要可执行文件，删除不需要的文件并相应地简化 <literal>build.zig</literal>——模板是一个起点，不是强制要求。</simpara>
</tip>
</section>
<section xml:id="minimal-template">
<title>最小模板：为有经验的用户提供的存根</title>
<simpara>对于了解构建系统并希望最小化样板代码的用户，<literal>zig init --minimal</literal> 仅生成 <literal>build.zig.zon</literal> 和一个存根 <literal>build.zig</literal>：</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ mkdir minimal-project &amp;&amp; cd minimal-project
$ zig init --minimal
info: successfully populated 'build.zig.zon' and 'build.zig'</programlisting>
<simpara>生成的 <literal>build.zig.zon</literal> 很紧凑：</simpara>
<programlisting language="zig" linenumbering="unnumbered">.{
    .name = .minimal_project,
    .version = "0.0.1",
    .minimum_zig_version = "0.15.2",
    .paths = .{""},
    .fingerprint = 0x52714d1b5f619765,
}</programlisting>
<simpara>存根 <literal>build.zig</literal> 同样简洁：</simpara>
<programlisting language="zig" linenumbering="unnumbered">const std = @import("std");

pub fn build(b: *std.Build) void {
    _ = b; // stub
}</programlisting>
<simpara>此模式适用于您有明确的构建策略并希望避免删除样板注释和示例代码的情况。</simpara>
</section>
</chapter>
<chapter xml:id="build-zig-zon-anatomy">
<title><literal>build.zig.zon</literal> 的结构剖析</title>
<simpara>Zig对象表示法（ZON）是Zig语法的严格子集，用于数据字面量；<literal>build.zig.zon</literal>是构建运行器在调用您的<literal>build.zig</literal>脚本之前解析包元数据的规范文件。参见<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/zon.zig">zon.zig</link>和<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/zig/Zoir.zig">Zoir.zig</link>。</simpara>
<section xml:id="zon-parse-modes">
<title>ZON文件的解析方式</title>
<simpara>从解析器的角度来看，<literal>.zon</literal>清单只是<literal>Ast.parse()</literal>的另一种模式。分词器在<literal>.zig</literal>和<literal>.zon</literal>文件之间共享，但<literal>.zig</literal>被解析为声明容器，而<literal>.zon</literal>被解析为单个表达式——这正是<literal>build.zig.zon</literal>包含的内容。</simpara>
<literallayout class="monospaced">graph TD
  START["Ast.parse()"] --&gt; TOKENIZE["Tokenize source"]
  TOKENIZE --&gt; MODE{Mode?}

  MODE --&gt;|".zig"| PARSEROOT["Parse.parseRoot()"]
  MODE --&gt;|".zon"| PARSEZON["Parse.parseZon()"]

  PARSEROOT --&gt; CONTAINERMEMBERS["parseContainerMembers()"]
  CONTAINERMEMBERS --&gt; ROOTAST["Root AST&lt;br/&gt;(container decls)"]

  PARSEZON --&gt; EXPR["expectExpr()"]
  EXPR --&gt; EXPRAST["Root AST&lt;br/&gt;(single expression)"]

  ROOTAST --&gt; ASTRETURN["Return Ast struct"]
  EXPRAST --&gt; ASTRETURN</literallayout>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Zig模式</emphasis>（<literal>.zig</literal>文件）：将完整源文件解析为包含声明的容器</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">ZON模式</emphasis>（<literal>.zon</literal>文件）：解析单个表达式（Zig对象表示法）</simpara>
</listitem>
</itemizedlist>
<simpara>Sources: <link xl:href="">lib/std/zig/Parse.zig:192-205</link>, <link xl:href="">lib/std/zig/Parse.zig:208-228</link></simpara>
</section>
<section xml:id="zon-required-fields">
<title>Required Fields</title>
<simpara>Every <literal>build.zig.zon</literal> must define these core fields:</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 21__zig-init-and-package-metadata.adoc - include::example$chapters-data/code/21__zig-init-and-package-metadata/minimal_zon.zon[]</programlisting>
<itemizedlist>
<listitem>
<simpara><literal>.name</literal>: A symbol literal (e.g., <literal>.myproject</literal>) used as the default dependency key; conventionally lowercase, omitting redundant "zig" prefixes since the package already lives in the Zig namespace.</simpara>
</listitem>
<listitem>
<simpara><literal>.version</literal>: A semantic version string (<literal>"MAJOR.MINOR.PATCH"</literal>) that the package manager will eventually use for deduplication. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/SemanticVersion.zig">SemanticVersion.zig</link></simpara>
</listitem>
<listitem>
<simpara><literal>.minimum_zig_version</literal>: The earliest Zig release that this package supports; older compilers will refuse to build it.</simpara>
</listitem>
<listitem>
<simpara><literal>.paths</literal>: An array of file/directory paths (relative to the build root) included in the package&#8217;s content hash; only these files are distributed and cached.</simpara>
</listitem>
<listitem>
<simpara><literal>.fingerprint</literal>: A 64-bit hexadecimal integer serving as the package&#8217;s globally unique identifier, generated once by the toolchain and never changed (except in hostile fork scenarios).</simpara>
</listitem>
</itemizedlist>
<simpara>The following demo shows how these fields map to runtime introspection patterns (though in practice the build runner handles this automatically):</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 21__zig-init-and-package-metadata.adoc - include::example$chapters-data/code/21__zig-init-and-package-metadata/zon_field_demo.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run zon_field_demo.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">=== build.zig.zon Field Demo ===
Sample ZON structure:
.{
    .name = .demo,
    .version = "0.1.0",
    .minimum_zig_version = "0.15.2",
    .fingerprint = 0x1234567890abcdef,
    .paths = .{"build.zig", "src"},
    .dependencies = .{},
}

Field explanations:
  .name: Package identifier (symbol literal)
  .version: Semantic version string
  .minimum_zig_version: Minimum supported Zig
  .fingerprint: Unique package ID (hex integer)
  .paths: Files included in package distribution
  .dependencies: External packages required

Note: Zig 0.15.2 uses .fingerprint for unique identity
      (Previously used UUID-style identifiers)</programlisting>
</para>
</formalpara>
<note>
<simpara>Zig 0.15.2 replaced the old UUID-style <literal>.id</literal> field with the more compact <literal>.fingerprint</literal> field, simplifying generation and comparison while maintaining global uniqueness guarantees.<footnote><simpara>See Zig 0.15.2 release notes, section "Zig Init".</simpara></footnote></simpara>
</note>
</section>
<section xml:id="fingerprint-identity">
<title>Fingerprint: Global Identity and Fork Detection</title>
<simpara>The <literal>.fingerprint</literal> field is the linchpin of package identity: it is generated once when you first run <literal>zig init</literal>, and should never change for the lifetime of the package unless you are deliberately forking it into a new identity.</simpara>
<simpara>Changing the fingerprint of an actively maintained upstream project is considered a <emphasis role="strong">hostile fork</emphasis>—an attempt to hijack the package&#8217;s identity and redirect users to different code. Legitimate forks (where the upstream is abandoned) should regenerate the fingerprint to establish a new identity, while maintaining forks (backports, security patches) preserve the original fingerprint to signal continuity.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 21__zig-init-and-package-metadata.adoc - include::example$chapters-data/code/21__zig-init-and-package-metadata/fingerprint_demo.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run fingerprint_demo.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">=== Package Identity Validation ===

Package: mylib
Version: 1.0.0
Fingerprint: 0xabcdef1234567890

Version format valid: true

Fingerprint ensures:
  - Globally unique package identity
  - Unambiguous version detection
  - Fork detection (hostile vs. legitimate)

WARNING: Changing fingerprint of a maintained project
         is considered a hostile fork attempt!</programlisting>
</para>
</formalpara>
<important>
<simpara>The inline comment <literal>// Changing this has security and trust implications.</literal> in the generated <literal>.zon</literal> file is deliberately preserved to surface during code review if someone modifies the fingerprint without understanding the consequences.</simpara>
</important>
</section>
<section xml:id="dependencies-field">
<title>Dependencies: Remote, Local, and Lazy</title>
<simpara>The <literal>.dependencies</literal> field is a struct literal mapping dependency names to fetch specifications; each entry is either a remote URL dependency, a local filesystem path dependency, or a lazily-fetched optional dependency.</simpara>
<section xml:id="annotated-dependencies">
<title>Annotated Dependency Examples</title>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 21__zig-init-and-package-metadata.adoc - include::example$chapters-data/code/21__zig-init-and-package-metadata/annotated_zon.zon[]</programlisting>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Remote dependencies</emphasis> specify <literal>.url</literal> (a tarball/zip archive location) and <literal>.hash</literal> (a multihash-format content hash). The hash is the source of truth: even if the URL changes or mirrors are added, the package identity remains tied to the hash.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Local dependencies</emphasis> specify <literal>.path</literal> (a relative directory from the build root). No hash is computed because the filesystem is the authority; this is useful for monorepo layouts or during development before publishing.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Lazy dependencies</emphasis> add <literal>.lazy = true</literal> to defer fetching until the dependency is actually imported by a build script. This reduces bandwidth for optional features or platform-specific code paths.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="dependency-types-demo">
<title>Dependency Types in Practice</title>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 21__zig-init-and-package-metadata.adoc - include::example$chapters-data/code/21__zig-init-and-package-metadata/dependency_types.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run dependency_types.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">=== Dependency Types Comparison ===

Dependency 1: remote_package
  Type: remote
  Lazy: false
  URL: https://example.com/pkg.tar.gz
  Hash: 122012345678...
  (Fetched from network, cached locally)

Dependency 2: local_package
  Type: local
  Lazy: false
  Path: ../local-lib
  (No hash needed, relative to build root)

Dependency 3: lazy_optional
  Type: remote
  Lazy: true
  URL: https://example.com/opt.tar.gz
  Hash: 1220abcdef...
  (Fetched from network, cached locally)

Key differences:
  - Remote: Uses hash as source of truth
  - Local: Direct filesystem path
  - Lazy: Only fetched when actually imported</programlisting>
</para>
</formalpara>
<tip>
<simpara>Use local paths during active development across multiple packages in the same workspace, then switch to remote URLs with hashes when publishing for external consumers. <link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</tip>
<simpara>Chapter 24 revisits these concepts in depth by walking through a package resolution pipeline that starts from <literal>build.zig.zon</literal>. <link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</section>
</section>
<section xml:id="paths-field">
<title>Paths: Controlling Package Distribution</title>
<simpara>The <literal>.paths</literal> field specifies which files and directories are included when computing the package hash and distributing the package; everything not listed is excluded from the cached artifact.</simpara>
<simpara>Typical patterns:</simpara>
<programlisting language="zig" linenumbering="unnumbered">.paths = .{
    "build.zig",        // Build script is always needed
    "build.zig.zon",    // Metadata file itself
    "src",              // Source code directory (recursive)
    "LICENSE",          // Legal requirement
    "README.md",        // Documentation
}</programlisting>
<simpara>Listing a directory includes all files within it recursively; listing the empty string <literal>""</literal> includes the build root itself (equivalent to listing every file individually, which is rarely desired).</simpara>
<important>
<simpara>Exclude generated artifacts (<literal>zig-cache/</literal>, <literal>zig-out/</literal>), large assets not needed for compilation, and internal development tools from <literal>.paths</literal> to keep package downloads small and deterministic.</simpara>
</important>
</section>
<section xml:id="_under_the_hood_zon_files_in_dependency_tracking">
<title>Under the hood: ZON files in dependency tracking</title>
<simpara>The compiler&#8217;s incremental dependency tracker treats ZON files as a distinct <emphasis role="strong">dependee</emphasis> category alongside source hashes, embedded files, and declaration-based dependencies. The core storage is an <literal>InternPool</literal> that owns multiple maps into a shared <literal>dep_entries</literal> array:</simpara>
<literallayout class="monospaced">graph TB
    subgraph "InternPool - Dependency Storage"
      SRCHASHDEPS["src_hash_deps&lt;br/&gt;Map: TrackedInst.Index → DepEntry.Index"]
      NAVVALDEPS["nav_val_deps&lt;br/&gt;Map: Nav.Index → DepEntry.Index"]
      NAVTYDEPS["nav_ty_deps&lt;br/&gt;Map: Nav.Index → DepEntry.Index"]
      INTERNEDDEPS["interned_deps&lt;br/&gt;Map: Index → DepEntry.Index"]
      ZONFILEDEPS["zon_file_deps&lt;br/&gt;Map: FileIndex → DepEntry.Index"]
      EMBEDFILEDEPS["embed_file_deps&lt;br/&gt;Map: EmbedFile.Index → DepEntry.Index"]
      NSDEPS["namespace_deps&lt;br/&gt;Map: TrackedInst.Index → DepEntry.Index"]
      NSNAMEDEPS["namespace_name_deps&lt;br/&gt;Map: NamespaceNameKey → DepEntry.Index"]

        FIRSTDEP["first_dependency&lt;br/&gt;Map: AnalUnit â†’ DepEntry.Index"]
        DEPENTRIES["dep_entries&lt;br/&gt;ArrayListUnmanaged&lt;DepEntry&gt;"]
        FREEDEP["free_dep_entries&lt;br/&gt;ArrayListUnmanaged&lt;DepEntry.Index&gt;"]
    end

    subgraph "DepEntry Structure"
        DEPENTRY["DepEntry&lt;br/&gt;{depender: AnalUnit,&lt;br/&gt;next_dependee: DepEntry.Index.Optional,&lt;br/&gt;next_depender: DepEntry.Index.Optional}"]
    end

    SRCHASHDEPS --&gt; DEPENTRIES
    NAVVALDEPS --&gt; DEPENTRIES
    NAVTYDEPS --&gt; DEPENTRIES
    INTERNEDDEPS --&gt; DEPENTRIES
    ZONFILEDEPS --&gt; DEPENTRIES
    EMBEDFILEDEPS --&gt; DEPENTRIES
    NSDEPS --&gt; DEPENTRIES
    NSNAMEDEPS --&gt; DEPENTRIES
    FIRSTDEP --&gt; DEPENTRIES

    DEPENTRIES --&gt; DEPENTRY
    FREEDEP -.-&gt;|"reuses indices from"| DEPENTRIES</literallayout>
<simpara>The dependency tracking system uses multiple hash maps to look up dependencies by different <emphasis role="strong">dependee</emphasis> types. All maps point into a shared <literal>dep_entries</literal> array, which stores the actual <literal>DepEntry</literal> structures forming linked lists of dependencies.</simpara>
<simpara>Sources: <link xl:href="">src/InternPool.zig:34-85</link></simpara>
<literallayout class="monospaced">graph LR
    subgraph "Source-Level Dependencies"
        SRCHASH["Source Hash&lt;br/&gt;TrackedInst.Index&lt;br/&gt;src_hash_deps"]
        ZONFILE["ZON File&lt;br/&gt;FileIndex&lt;br/&gt;zon_file_deps"]
        EMBEDFILE["Embedded File&lt;br/&gt;EmbedFile.Index&lt;br/&gt;embed_file_deps"]
    end

    subgraph "Nav Dependencies"
        NAVVAL["Nav Value&lt;br/&gt;Nav.Index&lt;br/&gt;nav_val_deps"]
        NAVTY["Nav Type&lt;br/&gt;Nav.Index&lt;br/&gt;nav_ty_deps"]
    end

    subgraph "Type/Value Dependencies"
        INTERNED["Interned Value&lt;br/&gt;Index&lt;br/&gt;interned_deps&lt;br/&gt;runtime funcs, container types"]
    end

    subgraph "Namespace Dependencies"
        NSFULL["Full Namespace&lt;br/&gt;TrackedInst.Index&lt;br/&gt;namespace_deps"]
        NSNAME["Namespace Name&lt;br/&gt;NamespaceNameKey&lt;br/&gt;namespace_name_deps"]
    end

    subgraph "Memoized State"
        MEMO["Memoized Fields&lt;br/&gt;panic_messages, etc."]
    end</literallayout>
<simpara>Each category tracks a different kind of dependee:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Dependee Type</entry>
<entry align="left" valign="top">Map Name</entry>
<entry align="left" valign="top">Key Type</entry>
<entry align="left" valign="top">When Invalidated</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Source Hash</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>src_hash_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TrackedInst.Index</literal></simpara></entry>
<entry align="left" valign="top"><simpara>ZIR instruction body changes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Nav Value</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>nav_val_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Nav.Index</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Declaration value changes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Nav Type</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>nav_ty_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Nav.Index</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Declaration type changes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Interned Value</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>interned_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Index</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function IES changes, container type recreated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">ZON File</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>zon_file_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FileIndex</literal></simpara></entry>
<entry align="left" valign="top"><simpara>ZON file imported via <literal>@import</literal> changes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Embedded File</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>embed_file_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>EmbedFile.Index</literal></simpara></entry>
<entry align="left" valign="top"><simpara>File content accessed via <literal>@embedFile</literal> changes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Full Namespace</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>namespace_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TrackedInst.Index</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Any name added/removed in namespace</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Namespace Name</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>namespace_name_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>NamespaceNameKey</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specific name existence changes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Memoized State</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>memoized_state_*_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara>N/A (single entry)</simpara></entry>
<entry align="left" valign="top"><simpara>Compiler state fields change</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Sources: <link xl:href="">src/InternPool.zig:34-71</link></simpara>
</section>
<section xml:id="minimum-zig-version">
<title>Minimum Zig Version: Compatibility Bounds</title>
<simpara>The <literal>.minimum_zig_version</literal> field declares the earliest Zig release that the package can build with; older compilers will refuse to proceed, preventing silent miscompilations due to missing features or changed semantics.</simpara>
<simpara>When the language stabilizes at 1.0.0, this field will interact with semantic versioning to provide compatibility guarantees; before 1.0.0, it serves as a forward-looking compatibility declaration even though breaking changes happen every release.</simpara>
</section>
<section xml:id="version-field">
<title>Version: Semantic Versioning for Deduplication</title>
<simpara>The <literal>.version</literal> field currently documents the package&#8217;s semantic version but does not yet enforce compatibility ranges or automatic deduplication; that functionality is planned for post-1.0.0 when the language stabilizes.</simpara>
<simpara>Follow semantic versioning conventions:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">MAJOR</emphasis>: Increment for incompatible API changes</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">MINOR</emphasis>: Increment for backward-compatible feature additions</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">PATCH</emphasis>: Increment for backward-compatible bug fixes</simpara>
</listitem>
</itemizedlist>
<simpara>This discipline will pay off once the package manager can auto-resolve compatible versions within dependency trees. <link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</section>
</chapter>
<chapter xml:id="zig-init-workflow">
<title>Practical Workflow: From Init to First Build</title>
<simpara>A typical project initialization sequence looks like this:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ mkdir mylib &amp;&amp; cd mylib
$ zig init
info: created build.zig
info: created build.zig.zon
info: created src/main.zig
info: created src/root.zig

$ zig build
$ zig build test
All 3 tests passed.

$ zig build run
All your codebase are belong to us.
Run `zig build test` to run the tests.</programlisting>
<simpara>At this point, you have:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A reusable module (<literal>src/root.zig</literal>) exposing <literal>bufferedPrint</literal> and <literal>add</literal></simpara>
</listitem>
<listitem>
<simpara>An executable (<literal>src/main.zig</literal>) importing and using the module</simpara>
</listitem>
<listitem>
<simpara>Tests for both the module and executable</simpara>
</listitem>
<listitem>
<simpara>Package metadata (<literal>build.zig.zon</literal>) ready for publishing</simpara>
</listitem>
</orderedlist>
<simpara>To share your module with other packages, you would publish the repository with a tagged release, document the URL and hash, and consumers would add it to their <literal>.dependencies</literal> table.</simpara>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>The fingerprint is generated from a random seed; regenerating <literal>build.zig.zon</literal> will produce a different fingerprint unless you preserve the original.</simpara>
</listitem>
<listitem>
<simpara>Changing <literal>.name</literal> does not change the fingerprint; the name is a convenience alias while the fingerprint is the identity.</simpara>
</listitem>
<listitem>
<simpara>Local path dependencies bypass the hash-based content addressing entirely; they are trusted based on filesystem state at build time.</simpara>
</listitem>
<listitem>
<simpara>The package manager caches fetched dependencies in a global cache directory; subsequent builds with the same hash skip re-downloading.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Run <literal>zig init</literal> in a new directory, then modify <literal>build.zig.zon</literal> to add a fake remote dependency with a placeholder hash; observe the error when running <literal>zig build --fetch</literal>.</simpara>
</listitem>
<listitem>
<simpara>Create two packages in sibling directories, configure one as a local path dependency of the other, and verify that changes in the dependency are immediately visible without re-fetching.</simpara>
</listitem>
<listitem>
<simpara>Generate a <literal>build.zig.zon</literal> with <literal>zig init --minimal</literal>, then manually add a <literal>.dependencies</literal> table and compare the resulting structure with the annotated example in this chapter.</simpara>
</listitem>
<listitem>
<simpara>Fork a hypothetical package by regenerating the fingerprint (delete the field and run <literal>zig build</literal>), then document in a README why this is a new identity rather than a hostile takeover.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Caveats, alternatives, edge cases</title>
<itemizedlist>
<listitem>
<simpara>If you omit <literal>.paths</literal>, the package manager may include unintended files in the distribution, inflating download size and exposing internal implementation details.</simpara>
</listitem>
<listitem>
<simpara>Remote dependency URLs can become stale if the host moves or removes the archive; consider mirroring critical dependencies or using content-addressed storage systems. <link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</listitem>
<listitem>
<simpara>The <literal>zig fetch --save &lt;url&gt;</literal> command automates adding a remote dependency to <literal>.dependencies</literal> by downloading, hashing, and inserting the correct entry—use it instead of hand-typing hashes.</simpara>
</listitem>
<listitem>
<simpara>Lazy dependencies require build script cooperation: if your <literal>build.zig</literal> unconditionally references a lazy dependency without checking availability, the build will fail with a "dependency not available" error.</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>