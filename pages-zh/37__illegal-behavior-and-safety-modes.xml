<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>非法行为与安全模式</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>概览</title>
<simpara>完成风格调优后，我们认识到：若不在失败时明确告警，不变量将失去意义（<link xl:href="36__style-and-best-practices.xml">36</link>）。本章说明 Zig 如何将这些失败形式化为“非法行为”，以及工具链如何在状态被破坏前捕获大多数问题。<link xl:href="https://ziglang.org/documentation/master/#illegal-behavior">#illegal behavior</link></simpara>
<simpara>接下来将深入命令行工具，因此在脚本为我们切换优化模式之前，需先架设好运行时护栏。<link xl:href="38__zig-cli-deep-dive.xml">38</link></simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>区分安全检查和非检查类别的非法行为。</simpara>
</listitem>
<listitem>
<simpara>检查当前优化模式并推断 Zig 将发出哪些运行时检查。</simpara>
</listitem>
<listitem>
<simpara>围绕 <literal>@setRuntimeSafety</literal>、<literal>unreachable</literal> 和 <literal>std.debug.assert</literal> 构建契约，确保不变量在每次构建中都可证明。</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Refs: <link xl:href="04__errors-resource-cleanup.xml">4</link></emphasis></simpara>
</chapter>
<chapter xml:id="illegal-behavior-basics">
<title>Zig 中的非法行为</title>
<simpara>非法行为是 Zig 对语言拒绝定义的操作的统称，范围从整数溢出到解引用无效指针。我们已经依赖切片和可选类型的边界检查；本节整合这些规则，以便即将进行的 CLI 工作继承可预测的失败处理机制。<link xl:href="03__data-fundamentals.xml">3</link></simpara>
<section xml:id="illegal-behavior-checked-unchecked">
<title>安全检查路径 vs 非检查路径</title>
<simpara>带安全检查的非法行为涵盖编译器可在运行时插桩的情形（溢出、哨兵不匹配、访问错误的联合字段）；而非检查情形对安全插桩不可见（通过错误指针类型别名、外部代码导致的布局违规）。</simpara>
<simpara>Debug 与 ReleaseSafe 默认保留护栏。ReleaseFast 与 ReleaseSmall 假定你为性能放弃了这些陷阱，因此任何越过不变量的行为在实践中都变为未定义。</simpara>
</section>
<section xml:id="illegal-behavior-guarded-example">
<title>示例：守护未检查算术</title>
<simpara>如下助手先用<literal>@addWithOverflow</literal>证明一次加法安全，然后对最终的<literal>+</literal>禁用运行期安全，以避免冗余检查，并在异常输入下将结果饱和到类型最大值。<link xl:href="https://ziglang.org/documentation/master/#setruntimesafety">#setruntimesafety</link></simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 37__illegal-behavior-and-safety-modes.adoc - include::example$chapters-data/code/37__illegal-behavior-and-safety-modes/01_guarded_runtime_safety.zig[]</programlisting>
<formalpara><title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig test 01_guarded_runtime_safety.zig</programlisting>
</para>
</formalpara>
<formalpara><title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">All 2 tests passed.</programlisting>
</para>
</formalpara>
<note>
<simpara>使用 <literal>-OReleaseFast</literal> 运行相同的测试，验证即使全局运行时安全缺失，守护机制仍会继续饱和而非崩溃。</simpara>
</note>
</section>
</chapter>
<chapter xml:id="safety-modes">
<title>按优化模式的安全默认项</title>
<simpara>当前优化模式通过<literal>@import("builtin").mode</literal>公开，无需查阅构建脚本即可知晓某制品包含哪些运行时检查。<link xl:href="https://ziglang.org/documentation/master/#compile-variables">#compile variables</link> 下表概述在你手动选择启用/禁用检查之前，各模式的默认契约。</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">模式</entry>
<entry align="left" valign="top">运行时安全</entry>
<entry align="left" valign="top">典型意图</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Debug</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>具有最大诊断信息和堆栈跟踪的开发构建。</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ReleaseSafe</simpara></entry>
<entry align="left" valign="top"><simpara>Enabled</simpara></entry>
<entry align="left" valign="top"><simpara>生产构建，仍然倾向于可预测的陷阱而非静默损坏。</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ReleaseFast</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>高性能二进制文件，假定不变量已在其他地方得到证明。</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>ReleaseSmall</simpara></entry>
<entry align="left" valign="top"><simpara>Disabled</simpara></entry>
<entry align="left" valign="top"><simpara>大小受限的交付物，其中每个注入的陷阱都会成为负担。</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section xml:id="safety-modes-probe">
<title>在运行时插桩安全</title>
<simpara>该探针打印当前模式及其隐含的安全默认项，并比较一次带检查的加法与未检查的加法，使你可观察在关闭检查后哪些行为仍然成立。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 37__illegal-behavior-and-safety-modes.adoc - include::example$chapters-data/code/37__illegal-behavior-and-safety-modes/02_mode_probe.zig[]</programlisting>
<formalpara><title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run 02_mode_probe.zig</programlisting>
</para>
</formalpara>
<formalpara><title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">optimize-mode: Debug
runtime-safety-default: true
checked-add result=24 overflowed=true
unchecked-add result=24</programlisting>
</para>
</formalpara>
<tip>
<simpara>使用 <literal>-OReleaseFast</literal> 重新运行探针，观察默认安全标志翻转为 <literal>false</literal>，同时检查路径仍报告溢出，帮助您记录发布构建中可能需要的功能标志或遥测数据。</simpara>
</tip>
</section>
</chapter>
<chapter xml:id="contracts-and-panics">
<title>契约、崩溃与恢复</title>
<simpara>在启用安全的构建中触发 <literal>unreachable</literal> 时，堆栈跟踪会平静地令人恐惧。将它们视为断言和错误联合体耗尽优雅退出后的最后一道防线。<link xl:href="https://ziglang.org/documentation/master/#reaching-unreachable-code">#reaching unreachable code</link></simpara>
<simpara>将这种纪律与前几章的错误处理技术相结合，可在不牺牲确定性的情况下保持失败模式的可调试性。<link xl:href="04__errors-resource-cleanup.xml">4</link></simpara>
<section xml:id="contracts-example">
<title>示例：断言数字字符转换</title>
<simpara>这里我们两次记录 ASCII 数字契约：一次使用断言解锁未检查的数学运算，一次使用错误联合体进行调用者友好的验证。<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/debug.zig">debug.zig</link></simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 37__illegal-behavior-and-safety-modes.adoc - include::example$chapters-data/code/37__illegal-behavior-and-safety-modes/03_unreachable_contract.zig[]</programlisting>
<formalpara><title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig test 03_unreachable_contract.zig</programlisting>
</para>
</formalpara>
<formalpara><title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">All 2 tests passed.</programlisting>
</para>
</formalpara>
<important>
<simpara>在 ReleaseFast 中，断言支持的路径会编译为一次减法；但在 Debug 下传入非数字时仍会触发 panic。对不可信数据请保留返回错误的防御性变体。</simpara>
</important>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>注意与警示</title>
<itemizedlist>
<listitem>
<simpara>即使在 Debug 模式下，某些基于指针的错误仍保持未检查状态。当需要边界强制执行时，优先使用基于切片的 API。</simpara>
</listitem>
<listitem>
<simpara>将 <literal>@setRuntimeSafety(false)</literal> 的范围缩小到尽可能小的块，并在切换前证明前置条件。</simpara>
</listitem>
<listitem>
<simpara>在开发中捕获 panic 堆栈跟踪，如果预计稍后需要分类 ReleaseSafe 崩溃，请提供符号文件。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>练习</title>
<itemizedlist>
<listitem>
<simpara>扩展 <literal>guardedUncheckedAdd</literal>，在哨兵终止的切片将溢出目标缓冲区时发出诊断信息，然后测量启用安全和禁用安全构建之间的差异。<link xl:href="https://ziglang.org/documentation/master/#sentinel-terminated-arrays">#sentinel terminated arrays</link></simpara>
</listitem>
<listitem>
<simpara>编写一个基准测试工具，循环执行数百万次安全加法，每次迭代切换 <literal>@setRuntimeSafety</literal> 以确认每种模式下守护机制的成本。</simpara>
</listitem>
<listitem>
<simpara>增强模式探针，在即将进行的 CLI 项目中记录构建元数据，以便脚本在 ReleaseFast 二进制文件省略陷阱时发出警告。<link xl:href="38__zig-cli-deep-dive.xml">38</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>替代方案与边界情况</title>
<itemizedlist>
<listitem>
<simpara>在 ReleaseFast 中未能从 <literal>+</literal> 切换到 <literal>@addWithOverflow</literal> 会带来静默回绕的风险，这种风险仅在罕见的负载模式下显现。</simpara>
</listitem>
<listitem>
<simpara>运行时安全不防御并发数据竞争。请将这些工具与本书后面介绍的同步原语配对使用。</simpara>
</listitem>
<listitem>
<simpara>调用 C 代码时请记住，Zig 的检查止步于 FFI 边界；在信任不变量前，应先验证外部输入。<link xl:href="33__c-interop-import-export-abi.xml">33</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>