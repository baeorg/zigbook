////
changes: ["Initial CLI deep dive chapter"]
examples_compile: yes
keywords: ["cli", "commands", "tooling"]
last_updated: 2025-11-06
last_verified: 2025-11-06
next_chapter: "39__performance-and-inlining"
open_questions: []
previous_chapter: "37__illegal-behavior-and-safety-modes"
status: draft
xref_complete: true
////

= Zig CLI Deep Dive
:chapter-number: 38
:chapter-slug: zig-cli-deep-dive
:creative-commons:
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

We spent the previous chapter hardening invariants and fail-fast strategies (see xref:37__illegal-behavior-and-safety-modes.adoc[37]); now we turn that discipline toward the tooling that drives every Zig project. The `zig` command-line interface (CLI) is more than a compiler wrapper: it dispatches to build graph runners, drop-in toolchain shims, formatting pipelines, and metadata exporters that keep your codebase reproducible. See link:ZIG_DEEP_WIKI.md#entry-points-and-command-structure[#entry points and command structure].

The insights you gather here will feed directly into the upcoming performance tuning discussion, where CLI flags like `-OReleaseFast` and `--time-report` become essential measurement levers (see xref:39__performance-and-inlining.adoc[39]).

[[learning-goals]]
== Learning Goals

* Map the major command families exposed by the `zig` CLI and know when to reach for each.
* Drive compilation, testing, and sanitizers from the CLI while keeping outputs reproducible across targets.
* Combine diagnostic commands—`fmt`, `ast-check`, `env`, `targets`—into daily workflows that surface correctness issues early.

_Refs: link:https://ziglang.org/documentation/master/#Command-line-flags[#Command-line-flags]_

[[cli-topology]]
== Command Map of the `zig` Tool

Zig ships a single binary whose first positional argument selects the subsystem to execute. Understanding that dispatch table is the fastest route to mastering the CLI.

[source,markdown]
----
include::{sourcedir}/38__zig-cli-deep-dive/zig-help.md[]
----

[[cli-build-execute]]
=== Build and Execution Commands

Compilation-centric commands (`build-exe`, `build-lib`, `build-obj`, `run`, `test`, `test-obj`) all flow through the same build output machinery, offering consistent options for targets, optimization, sanitizers, and emission controls. `zig test-obj` (new in 0.15.2) now emits object files for embed-your-own test runners when you need to integrate with foreign harnesses (see link:https://ziglang.org/download/0.15.1/release-notes.html#compile-tests-to-object-file[#compile tests to object file]).

[[cli-toolchain-dropin]]
=== Toolchain Drop-in Modes

`zig cc`, `zig c++`, `zig ar`, `zig dlltool`, and friends let you replace Clang/LLVM utilities with Zig-managed shims, keeping cross-compilation assets, libc headers, and target triples consistent without juggling SDK installs. These commands honor the same cache directories you see in `zig env`, so the artifacts they produce land beside your native Zig outputs.

[[cli-package-init]]
=== Package Bootstrapping Commands

`zig init` and `zig fetch` handle project scaffolding and dependency pinning. Version 0.15.2 introduces `zig init --minimal`, which generates just a `build.zig` stub plus a valid `build.zig.zon` fingerprint for teams that already know how they want the build graph structured (see link:https://ziglang.org/download/0.15.1/release-notes.html#zig-init[#zig init]). Combined with `zig fetch`, you can warm the global cache before CI kicks off, avoiding first-run latency when `zig build` pulls modules from the package manager.

[[cli-driving-compilation]]
== Driving Compilation from the CLI

Once you know which command to call, the art lies in selecting the right flags and reading the metadata they surface. Zig's CLI mirrors the language's explicitness: every safety toggle and artifact knob is rendered as a flag, and the `@import("builtin")` namespace reflects back what the build saw.

[[cli-run-summary]]
=== Inspecting Build Context with `zig run`

The `zig run` wrapper accepts all compilation flags plus a `--` separator that forwards the remaining arguments to your program. This makes it ideal for quick experiments that still need deterministic target and optimization settings.

[source,zig]
----
include::{sourcedir}/38__zig-cli-deep-dive/01_cli_modes.zig[]
----

.Run
[source,shell]
----
$ zig run 01_cli_modes.zig -OReleaseFast -- --name zig --count 2
----

.Output
[source,shell]
----
optimize-mode: ReleaseFast
target-triple: x86_64-linux-gnu
single-threaded: false
user-args:
  arg[0] = --name
  arg[1] = zig
  arg[2] = --count
  arg[3] = 2
----

TIP: Pair `zig run` with `-fsanitize-c=trap` or `-fsanitize-c=full` to toggle UBSan-style diagnostics without touching source. These flags mirror the new module-level sanitizer controls added in 0.15.2 (see link:https://ziglang.org/download/0.15.1/release-notes.html#allow-configuring-ubsan-mode-at-the-module-level[#allow configuring ubsan mode at the module level]).

[[cli-test-filter]]
=== Filtering Test Suites on Demand

`zig test` accepts `--test-filter` to restrict which test names are compiled and executed, enabling tight edit-run loops even in monolithic suites. Combine it with `--summary all` or `--summary failing` when you need deterministic reporting in CI pipelines.

[source,zig]
----
include::{sourcedir}/38__zig-cli-deep-dive/02_cli_tests.zig[]
----

.Run
[source,shell]
----
$ zig test 02_cli_tests.zig --test-filter sum
----

.Output
[source,shell]
----
All 2 tests passed.
----

NOTE: When your build graph emits `zig test-obj`, reuse the same filters. The command `zig build test-obj --test-filter sum` forwards them to the underlying runner in exactly the same way.

[[cli-long-running]]
== Long-Running Builds and Reporting

Large projects often keep `zig build` running continuously, so understanding its watch mode, web UI, and reporting hooks pays dividends. macOS users finally get reliable file watching in 0.15.2 thanks to a rewritten `--watch` implementation (see link:https://ziglang.org/download/0.15.1/release-notes.html#macos-file-system-watching[#macos file system watching]). Pair it with incremental compilation (`-fincremental`) to turn rebuilds into sub-second operations when files change.

[[cli-webui]]
=== Web Interface and Time Reports

`zig build --webui` spins up a local dashboard that visualizes the build graph, active steps, and, when combined with `--time-report`, a breakdown of semantic analysis and code generation hotspots (see link:https://ziglang.org/download/0.15.1/release-notes.html#web-interface-and-time-report[#web interface and time report]). Use it when you suspect slow compile times: the "Declarations" table highlights which files or declarations consume the most analysis time, and those insights flow directly into the optimization work covered in the next chapter (see xref:39__performance-and-inlining.adoc[39]).

[[cli-diagnostics]]
== Diagnostics and Automation Helpers

Beyond compiling programs, the CLI offers tools that keep your repository tidy and introspectable: formatters, AST validators, environment reporters, and target enumerators (see link:ZIG_DEEP_WIKI.md#formatter-zig-fmt[#formatter zig fmt]).

[[cli-ast-check]]
=== Batch Syntax Validation with `zig ast-check`

`zig ast-check` parses files without emitting binaries, catching syntax and import issues faster than a full compile. This is handy for editor save hooks or pre-commit checks. The helper below returns cache and formatting defaults that build scripts can reuse; running `ast-check` against it ensures the file stays well-formed even if no executable ever imports it.

[source,zig]
----
include::{sourcedir}/38__zig-cli-deep-dive/03_cli_astcheck.zig[]
----

.Run
[source,shell]
----
$ zig ast-check 03_cli_astcheck.zig
----

.Output
[source,shell]
----
(no output)
----

TIP: Combine `zig ast-check` with `zig fmt --check --ast-check` to refuse commits that either violate style or fail to parse—the formatter already has an AST pass under the hood, so the extra flag keeps both stages in sync.

[[cli-env-targets]]
=== Introspection Commands Worth Scripting

`zig env` prints the paths, cache directories, and active target triple that the toolchain resolved, making it a perfect snapshot to capture in bug reports or CI logs. `zig targets` returns exhaustive architecture/OS/ABI matrices, which you can feed into `std.build` matrices to precompute release artifacts. Together they replace brittle environment variables with a single source of truth.

[[notes-caveats]]
== Notes & Caveats

* Prefer `zig build --build-file <path>` over copying projects into scratch directories; it lets you experiment with CLI options against isolated build graphs while keeping cache entries deterministic.
* macOS users still need to grant file system permissions for `--watch`. Without them, the builder falls back to polling and loses the new responsiveness in 0.15.2.
* Time reports can surface plenty of data. Capture them alongside sanitized builds so you know whether costly declarations are tied to debug assertions or optimizer work.

[[exercises]]
== Exercises

* Script `zig env` before and after `zig fetch` to verify the cache paths you rely on in CI remain unchanged across Zig releases.
* Extend the `zig ast-check` sample to walk a directory tree, then wire it into a `zig build` custom step so `zig build lint` validates syntax without compiling. xref:22__build-system-deep-dive.adoc[22]
* Use `zig build --webui --time-report --watch` on a medium project and record which declarations dominate the time report; refactor one hot declaration and re-run to quantify the improvement.

[[caveats-alternatives-edge-cases]]
== Alternatives & Edge Cases

* `zig run` always produces build artifacts in the cache. If you need a hermetic sandbox, favor `zig build-exe -femit-bin` into a throwaway directory and run the binary manually.
* The CLI's drop-in `zig cc` respects Zig's idea of the sysroot. If you need the platform vendor toolchain verbatim, invoke `clang` directly to avoid surprising header selections.
* `zig targets` output can be enormous. Filter it with `jq` or `grep` before piping into build scripts so that your automation remains stable even if future releases add new fields.
