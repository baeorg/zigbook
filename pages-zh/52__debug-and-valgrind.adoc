////
changes: ["Initial Debug and Valgrind chapter for Zig 0.15.2"]
examples_compile: yes
keywords: ["std.debug", "panic", "stack trace", "std.valgrind", "memcheck"]
last_updated: 2025-11-13
last_verified: 2025-11-13
previous_chapter: "51__mem-and-meta-utilities"
next_chapter: "53__project-top-k-word-frequency-analyzer"
status: draft
xref_complete: true
open_questions: []
////

= Debug and Valgrind
:chapter-number: 52
:chapter-slug: debug-and-valgrind
:creative-commons:
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

After building slice tooling and lightweight reflection in xref:51__mem-and-meta-utilities.adoc[the previous chapter], we now turn to what happens when things go wrong. Zig's diagnostics pipeline lives in `std.debug`, which controls panic strategies, offers stack unwinding, and exposes helpers for printing structured data. link:https://github.com/ziglang/zig/tree/master/lib/std/debug.zig[debug.zig] For memory instrumentation you have `std.valgrind`, a thin veneer over Valgrind's client request protocol that keeps your custom allocators visible to Memcheck without ruining portability. link:https://github.com/ziglang/zig/tree/master/lib/std/valgrind.zig[valgrind.zig] link:https://github.com/ziglang/zig/tree/master/lib/std/valgrind/memcheck.zig[memcheck.zig]

[[learning-goals]]
== Learning Goals

* Configure panic behavior and collect stack information with `std.debug`.
* Use stderr-aware writers and stack capture APIs without leaking unstable addresses into logs.
* Annotate custom allocations for Valgrind Memcheck and safely query leak counters at runtime.

[[std-debug-overview]]
== Diagnostics with `std.debug`

`std.debug` is the standard library's staging ground for assertions, panic hooks, and stack unwinding. The module keeps the default panic bridge (`std.debug.simple_panic`) alongside a configurable `FullPanic` helper that funnels every safety check into your own handler. link:https://github.com/ziglang/zig/tree/master/lib/std/debug/simple_panic.zig[simple_panic.zig] Whether you are instrumenting tests or tightening release builds, this is the layer that decides what happens when `unreachable` executes.

[[std-debug-panic-strategies]]
=== Panic strategies and safety modes

By default, a failed `std.debug.assert` or `unreachable` results in a call to `@panic`, which delegates to the active panic handler. You can override this globally by defining a root-level `pub fn panic(message: []const u8, trace: ?*std.builtin.StackTrace, ret_addr: ?usize) noreturn`, or compose a bespoke handler via `std.debug.FullPanic(custom)` to preserve Zig's rich error messages while swapping termination semantics. This is especially useful in embedded or service-mode binaries where you prefer logging and clean shutdowns over aborting the process. Remember that safety features are mode-dependent—`std.debug.runtime_safety` evaluates to `false` in ReleaseFast and ReleaseSmall, so instrumentation should check that flag before assuming invariants are enforced.

[[std-debug-stack-output]]
=== Capturing stack frames and managing stderr

The following program demonstrates several `std.debug` primitives: printing to stderr, locking stderr for multi-line output, capturing a stack trace without exposing raw addresses, and reporting build parameters.

[source,zig]
----
include::{sourcedir}/52__debug-and-valgrind/debug_diagnostics_station.zig[]
----

.Run
[source,shell]
----
$ zig run debug_diagnostics_station.zig
----

.Output
[source,shell]
----
[stderr] staged diagnostics
[stderr] stack capture incoming
frames captured -> 4
runtime_safety -> enabled
optimize_mode -> Debug
captured slice -> panic probe
----

A few callouts:

* `std.debug.print` always targets stderr, so it remains separate from any structured stdout reporting.
* Use `std.debug.lockStderrWriter` when you need atomic multi-line diagnostics; the helper temporarily clears `std.Progress` overlays.
* `std.debug.captureStackTrace` writes to a `std.builtin.StackTrace` buffer. Emitting only the frame count avoids leaking ASLR-sensitive addresses and keeps log output deterministic. link:https://github.com/ziglang/zig/tree/master/lib/std/builtin.zig[builtin.zig]
* Formatter access comes from the writer interface returned by `std.fs.File.stdout().writer()`, which mirrors the approach from earlier chapters.

[[std-debug-introspection]]
=== Introspecting symbols and binaries

`std.debug.getSelfDebugInfo()` opens the current binary’s DWARF or PDB tables on demand and caches them for subsequent lookups. With that handle you can resolve instruction addresses to `std.debug.Symbol` records that include function names, compilation units, and optional source locations. link:https://github.com/ziglang/zig/tree/master/lib/std/debug/SelfInfo.zig[SelfInfo.zig] You do not need to pay that cost in hot paths: store addresses (or stack snapshots) first, then resolve them lazily in telemetry tools or when generating a bug report. On platforms where debug info is stripped or unavailable, the API returns `error.MissingDebugInfo`, so wrap the lookup in a fallback that prints module names only.

[[std-valgrind-overview]]
== Instrumenting with `std.valgrind`

`std.valgrind` mirrors Valgrind’s client requests while compiling down to no-ops when `builtin.valgrind_support` is false, keeping your binaries portable. You can detect Valgrind at runtime via `std.valgrind.runningOnValgrind()` (useful for suppressing self-tests that spawn massive workloads) and query accumulated error counts with `std.valgrind.countErrors()`.

[[std-valgrind-memcheck]]
=== Marking custom allocations for Memcheck

When you roll your own allocator, Memcheck cannot infer which buffers are live unless you annotate them. The following example shows the canonical pattern: announce a block, adjust its definedness, run a quick leak check, and free the block when done.

[source,zig]
----
include::{sourcedir}/52__debug-and-valgrind/valgrind_integration_probe.zig[]
----

.Run
[source,shell]
----
$ zig run valgrind_integration_probe.zig
----

.Output
[source,shell]
----
running_on_valgrind -> no
leaks_bytes -> 0
errors_seen -> 0
----

Even outside Valgrind the calls succeed—every request degrades to a stub when client support is absent—so you can leave the instrumentation in release binaries without gating on build flags. The sequence worth memorizing is:

. `std.valgrind.mallocLikeBlock` immediately after you obtain memory from a custom allocator.
. `std.valgrind.memcheck.createBlock` with a zero-terminated label so Memcheck reports use the name you expect.
. Optional range adjustments such as `makeMemNoAccess` and `makeMemDefinedIfAddressable` when you deliberately poison or unpoison guard bytes.
. A matching `std.valgrind.freeLikeBlock` (and `memcheck.discard`) before the underlying allocator releases the memory.

[[notes-caveats]]
== Notes & Caveats

* Stack capture relies on debug info; in stripped builds or unsupported targets, `std.debug.captureStackTrace` falls back to empty results, so wrap diagnostics with graceful degradation.
* `std.debug.FullPanic` executes on every safety violation. Ensure the handler performs only async-signal-safe operations if you plan to log from multiple executor threads.
* Valgrind annotations are cheap in native runs but do not cover sanitizer-based tooling—prefer compiler sanitizers (ASan/TSan) when you need deterministic CI coverage. xref:37__illegal-behavior-and-safety-modes.adoc[37]

[[exercises]]
== Exercises

* Implement a custom panic handler that logs to a ring buffer using `std.debug.FullPanic`, then forwards to the default handler in debug mode.
* Extend `debug_diagnostics_station.zig` so that stack captures are resolved to symbol names via `std.debug.getSelfDebugInfo()`, caching results to avoid repeated lookups.
* Modify `valgrind_integration_probe.zig` to wrap a bump allocator: record every active span in a table, and call `std.valgrind.memcheck.doQuickLeakCheck()` only when the process shuts down. xref:10__allocators-and-memory-management.adoc[10]

[[caveats-alternatives-edge-cases]]
== Caveats, alternatives, edge cases

* `std.debug.dumpCurrentStackTrace` prints absolute addresses and source paths that vary per run because of ASLR; capture to an in-memory buffer and redact volatile fields before shipping telemetry.
* Valgrind's client requests depend on the `xchg`-based handshake and are no-ops on architectures that Valgrind does not support—`runningOnValgrind()` will always return zero there.
* Memcheck annotations do not replace structured testing; combine them with Zig's leak detection (`zig test --detect-leaks`) for deterministic regression coverage. xref:13__testing-and-leak-detection.adoc[13]
