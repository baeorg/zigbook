////
changes: ["Initial style and best practices chapter"]
examples_compile: yes
keywords: ["style", "best-practices", "testing"]
last_updated: 2025-11-06
last_verified: 2025-11-06
next_chapter: "37__illegal-behavior-and-safety-modes"
open_questions: []
previous_chapter: "35__project-gpu-compute-in-zig"
status: draft
xref_complete: true
////

= Style & Best Practices
:chapter-number: 36
:chapter-slug: style-and-best-practices
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Finishing the GPU compute project left us with a multi-file workspace that depends on consistent naming, predictable formatting, and steadfast tests (see xref:35__project-gpu-compute-in-zig.adoc[35]). This chapter explains how to keep that discipline as codebases evolve. We will pair `zig fmt` conventions with documentation hygiene, surface the idiomatic error-handling patterns that Zig expects, and lean on targeted invariants to keep future refactors safe (see link:https://ziglang.org/download/0.15.1/release-notes.html[v0.15.2]).

[[learning-goals]]
== Learning Goals

* Adopt formatting and naming conventions that communicate intent across modules.
* Structure documentation and tests so they form an executable spec for your APIs.
* Apply `defer`, `errdefer`, and invariant helpers to maintain resource safety and correctness in the long term.

_Refs: link:https://github.com/ziglang/zig/tree/master/lib/std/testing.zig[testing.zig]_

[[style-foundations]]
== Foundations: Consistency as a Feature

Formatting is not a cosmetic step: the standard formatter eliminates subjective whitespace debates and highlights semantic changes in diffs. `zig fmt` received incremental improvements in 0.15.x to ensure generated code matches what the compiler expects, so projects should wire formatting into editors and CI from the outset. Combine auto-formatting with descriptive identifiers, doc comments, and scoped error sets so readers can follow the control flow without rummaging through implementation details.

[[documenting-apis]]
=== Documenting APIs with Executable Tests

The following example assembles naming, documentation, and testing into a single file. It exposes a small statistics helper, expands the error set when printing, and demonstrates how tests can double as usage examples (see link:https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig[fmt.zig]).

[source,zig]
----
include::{sourcedir}/36__style-and-best-practices/01_style_baseline.zig[]
----

.Run
[source,shell]
----
$ zig test 01_style_baseline.zig
----

.Output
[source,shell]
----
All 3 tests passed.
----

TIP: Treat documentation comments plus unit tests as the minimum viable API reference—both are compiled on every run, so they stay in sync with the code you ship.

[[resource-patterns]]
== Resource Management & Error Patterns

Zig’s standard library favors explicit resource ownership; pairing `defer` with `errdefer` helps ensure that temporary allocations unwind correctly. When parsing user-supplied data, keep the error vocabulary small and deterministic so callers can route failure modes without inspecting strings. See link:https://github.com/ziglang/zig/tree/master/lib/std/fs.zig[fs.zig].

[source,zig]
----
include::{sourcedir}/36__style-and-best-practices/02_error_handling_patterns.zig[]
----

.Run
[source,shell]
----
$ zig test 02_error_handling_patterns.zig
----

.Output
[source,shell]
----
All 2 tests passed.
----

NOTE: Returning slices via `toOwnedSlice` keeps the lifetimes obvious and prevents leaking the backing allocation when parsing fails midway—`errdefer` makes the cleanup explicit (see link:https://github.com/ziglang/zig/tree/master/lib/std/mem.zig[mem.zig]).

[[maintainability]]
== Maintainability Checklist: Guarding Invariants

Data structures that defend their own invariants are easier to refactor safely. By isolating the checks in a helper and calling it before and after mutations, you create a single source of truth for correctness. `std.debug.assert` makes the contract visible in debug builds without penalizing release performance (see link:https://github.com/ziglang/zig/tree/master/lib/std/debug.zig[debug.zig]).

[source,zig]
----
include::{sourcedir}/36__style-and-best-practices/03_invariant_guard.zig[]
----

.Run
[source,shell]
----
$ zig test 03_invariant_guard.zig
----

.Output
[source,shell]
----
All 2 tests passed.
----

TIP: Capture invariants in unit tests as well—assertions guard developers, while tests stop regressions that slip past manual review.

[[notes-caveats]]
== Notes & Caveats

* `zig fmt` only touches syntax it understands; generated code or embedded strings may still need a manual glance.
* Expand error sets deliberately—combining the smallest possible unions keeps call sites precise and avoids accidental catch-alls (see link:https://github.com/ziglang/zig/tree/master/lib/std/error.zig[error.zig]).
* Remember to test under both debug and release builds so assertions and `std.debug` checks do not mask production-only issues (see link:https://github.com/ziglang/zig/tree/master/lib/std/build.zig[build.zig]).

[[exercises]]
== Exercises

* Wrap the statistics helper in a module that exposes both mean and variance; add doctests that demonstrate the API from a consumer’s perspective.
* Extend the loader to stream data instead of reading entire files; compare heap usage in release-safe builds to ensure you keep allocations bounded.
* Add a stress test to the ring buffer that interleaves pushes and pops across thousands of operations, then run it under `zig test -Drelease-safe` to confirm invariants survive in optimized builds.

[[caveats-alternatives-edge-cases]]
== Alternatives & Edge Cases

* Projects with generated code may need formatting exclusions—document those directories so contributors know when `zig fmt` is safe to run.
* Favor small helper functions (like `invariant`) over sprinkling assertions everywhere; centralized checks are easier to audit during reviews.
* When adding new dependencies, gate them behind feature flags or build options so style rules remain enforceable even in minimal configurations.
