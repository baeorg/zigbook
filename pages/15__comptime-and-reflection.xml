<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Comptime &amp; Reflection</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Zig lets you execute plain Zig at compile time. That single, quiet idea unlocks a lot: generate lookup tables, specialize code based on types or values, validate invariants before the program is ever run, and write generic utilities without macros or a separate metaprogramming language. Reflection completes the picture: with <literal>@TypeOf</literal>, <literal>@typeInfo</literal>, and friends, code can inspect types and construct behavior adaptively.</simpara>
<simpara>This chapter is a practitioner’s tour of compile-time execution and reflection in Zig 0.15.2. We’ll build small, self-contained examples you can run directly. Along the way, we’ll discuss what runs when (compile vs. run), how to keep code readable and fast, and when to prefer explicit parameters over clever reflection. For more detail, see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/meta.zig">meta.zig</link>.</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Use <literal>comptime</literal> expressions and blocks to compute data at build time and surface it at run time.</simpara>
</listitem>
<listitem>
<simpara>Introspect types using <literal>@TypeOf</literal>, <literal>@typeInfo</literal>, and <literal>@typeName</literal> to implement robust, generic helpers.</simpara>
</listitem>
<listitem>
<simpara>Apply <literal>inline fn</literal> and <literal>inline for/while</literal> judiciously, understanding code-size and performance trade-offs. <link xl:href="37__illegal-behavior-and-safety-modes.xml">37</link></simpara>
</listitem>
<listitem>
<simpara>Detect declarations and fields with <literal>@hasDecl</literal>, <literal>@hasField</literal>, and embed assets with <literal>@embedFile</literal>. <link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="comptime-basics">
<title>Compile-time basics: data now, print later</title>
<simpara>Compile-time work is just ordinary Zig evaluated earlier. The example below:</simpara>
<itemizedlist>
<listitem>
<simpara>Evaluates an expression at compile time.</simpara>
</listitem>
<listitem>
<simpara>Checks <literal>@inComptime()</literal> during runtime (it’s <literal>false</literal>).</simpara>
</listitem>
<listitem>
<simpara>Builds a small squares lookup table at compile time using an <literal>inline while</literal> and a comptime index.</simpara>
</listitem>
</itemizedlist>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 15__comptime-and-reflection.adoc - include::example$chapters-data/code/15__comptime-and-reflection/comptime_basics.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/15__comptime-and-reflection/comptime_basics.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">a (comptime 2+3) = 5
@inComptime() during runtime: false
squares[0..8): 0,1,4,9,16,25,36,49</programlisting>
</para>
</formalpara>
<tip>
<simpara><literal>inline while</literal> requires the condition to be known at compile time. Use a <literal>comptime var</literal> index for unrolled loops. Prefer ordinary loops unless you have a measured reason to unroll.</simpara>
</tip>
<section xml:id="comptime-tracking">
<title>How the compiler tracks comptime values</title>
<simpara>When you write comptime code, the compiler must determine which allocations and values are fully known at compile time. This tracking uses a mechanism in semantic analysis (Sema) that monitors all stores to allocated memory.</simpara>
<literallayout class="monospaced">graph TB
    subgraph "Key Structures"
        COMPTIMEALLOC["ComptimeAlloc&lt;br/&gt;val, is_const, alignment"]
        MAYBECOMPTIMEALLOC["MaybeComptimeAlloc&lt;br/&gt;runtime_index, stores[]"]
        BASEALLOC["base_allocs map&lt;br/&gt;derived ptr → base alloc"]
    end

    subgraph "Lifecycle"
        RUNTIMEALLOC["Runtime alloc instruction"]
        STORES["Store operations tracked"]
        MAKEPTRCONST["make_ptr_const instruction"]
        COMPTIMEVALUE["Determine comptime value"]
    end

    subgraph "MaybeComptimeAlloc Tracking"
        STORELIST["stores: MultiArrayList&lt;br/&gt;inst, src"]
        RUNTIMEINDEXFIELD["runtime_index&lt;br/&gt;Allocation point"]
    end

    subgraph "ComptimeAlloc Fields"
        VAL["val: MutableValue&lt;br/&gt;Current value"]
        ISCONST["is_const: bool&lt;br/&gt;Immutable after init"]
        ALIGNMENT["alignment&lt;br/&gt;Pointer alignment"]
        RUNTIMEINDEXALLOC["runtime_index&lt;br/&gt;Creation point"]
    end

    RUNTIMEALLOC --&gt; MAYBECOMPTIMEALLOC
    MAYBECOMPTIMEALLOC --&gt; STORELIST
    STORELIST --&gt; STORES
    STORES --&gt; MAKEPTRCONST
    MAKEPTRCONST --&gt; COMPTIMEVALUE
    COMPTIMEVALUE --&gt; COMPTIMEALLOC

    COMPTIMEALLOC --&gt; VAL
    COMPTIMEALLOC --&gt; ISCONST
    COMPTIMEALLOC --&gt; ALIGNMENT
    COMPTIMEALLOC --&gt; RUNTIMEINDEXALLOC

    BASEALLOC -.-&gt;|"tracks"| RUNTIMEALLOC</literallayout>
<simpara>When the compiler encounters an allocation during semantic analysis, it creates a <literal>MaybeComptimeAlloc</literal> entry to track all stores. If any store depends on runtime values or conditions, the allocation cannot be known at comptime and the entry is discarded. If all stores are known at comptime when the pointer becomes const, the compiler applies all stores at compile time and creates a <literal>ComptimeAlloc</literal> with the final value. This mechanism enables the compiler to evaluate complex initialization patterns at compile time while ensuring correctness. For implementation details, see <link xl:href="https://github.com/ziglang/zig/blob/master/src/Sema.zig">Sema.zig</link>.</simpara>
</section>
</chapter>
<chapter xml:id="reflection-typeinfo">
<title>Reflection: <literal>@TypeOf</literal>, <literal>@typeInfo</literal>, and friends</title>
<simpara>Reflection lets you write “generic-but-precise” code. Here we examine a <literal>struct</literal> and print its fields and their types, then construct a value in the usual way.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 15__comptime-and-reflection.adoc - include::example$chapters-data/code/15__comptime-and-reflection/type_info_introspect.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/15__comptime-and-reflection/type_info_introspect.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">type name: type_info_introspect.Person
fields: 3
  0. id: u32
  1. name: []const u8
  2. active: bool
example: id=42 name=Zig active=true</programlisting>
</para>
</formalpara>
<note>
<simpara>Use <literal>@typeInfo(T)</literal> at compile time to derive implementations (formatters, serializers, adapters). Keep the result in a local <literal>const</literal> for readability.</simpara>
</note>
<section xml:id="type-decomposition">
<title>Type decomposition with <literal>std.meta</literal></title>
<simpara>Beyond <literal>@typeInfo</literal>, the <literal>std.meta</literal> module provides specialized functions for extracting component types from composite types. These utilities make generic code cleaner by avoiding manual <literal>@typeInfo</literal> inspection.</simpara>
<literallayout class="monospaced">graph TB
    subgraph "Type Extractors"
        CHILD["Child(T)"]
        ELEM["Elem(T)"]
        SENTINEL["sentinel(T)"]
        TAG["Tag(T)"]
        ACTIVETAG["activeTag(union)"]
    end

    subgraph "Input Types"
        ARRAY["array"]
        VECTOR["vector"]
        POINTER["pointer"]
        OPTIONAL["optional"]
        UNION["union"]
        ENUM["enum"]
    end

    ARRAY --&gt; CHILD
    VECTOR --&gt; CHILD
    POINTER --&gt; CHILD
    OPTIONAL --&gt; CHILD

    ARRAY --&gt; ELEM
    VECTOR --&gt; ELEM
    POINTER --&gt; ELEM

    ARRAY --&gt; SENTINEL
    POINTER --&gt; SENTINEL

    UNION --&gt; TAG
    ENUM --&gt; TAG
    UNION --&gt; ACTIVETAG</literallayout>
<simpara>Key type extraction functions:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Child(T)</literal>: Extracts the child type from arrays, vectors, pointers, and optionals—useful for generic functions operating on containers.</simpara>
</listitem>
<listitem>
<simpara><literal>Elem(T)</literal>: Gets the element type from memory span types (arrays, slices, pointers)—cleaner than manual <literal>@typeInfo</literal> field access.</simpara>
</listitem>
<listitem>
<simpara><literal>sentinel(T)</literal>: Returns the sentinel value, if present, enabling generic handling of null-terminated data.</simpara>
</listitem>
<listitem>
<simpara><literal>Tag(T)</literal>: Gets the tag type from enums and unions for switch-based dispatch.</simpara>
</listitem>
<listitem>
<simpara><literal>activeTag(u)</literal>: Returns the active tag of a union value at runtime.</simpara>
</listitem>
</itemizedlist>
<simpara>These functions compose well: <literal>std.meta.Child(std.meta.Child(T))</literal> extracts the element type from <literal>[][]u8</literal>. Use them to write generic algorithms that adapt to type structure without verbose <literal>switch (@typeInfo(T))</literal> blocks. <link xl:href="https://github.com/ziglang/zig/blob/master/lib/std/meta.zig">meta.zig</link></simpara>
</section>
<section xml:id="field-declaration-introspection">
<title>Field and declaration introspection</title>
<simpara>For structured access to container internals, <literal>std.meta</literal> provides higher-level alternatives to manual <literal>@typeInfo</literal> navigation:</simpara>
<literallayout class="monospaced">graph TB
    subgraph "Container Introspection"
        FIELDS["fields(T)"]
        FIELDINFO["fieldInfo(T, field)"]
        FIELDNAMES["fieldNames(T)"]
        TAGS["tags(T)"]
        FIELDENUM["FieldEnum(T)"]
    end

    subgraph "Declaration Introspection"
        DECLARATIONS["declarations(T)"]
        DECLINFO["declarationInfo(T, name)"]
        DECLENUM["DeclEnum(T)"]
    end

    subgraph "Applicable Types"
        STRUCT["struct"]
        UNION["union"]
        ENUMP["enum"]
        ERRORSET["error_set"]
    end

    STRUCT --&gt; FIELDS
    UNION --&gt; FIELDS
    ENUMP --&gt; FIELDS
    ERRORSET --&gt; FIELDS

    STRUCT --&gt; DECLARATIONS
    UNION --&gt; DECLARATIONS
    ENUMP --&gt; DECLARATIONS

    FIELDS --&gt; FIELDINFO
    FIELDS --&gt; FIELDNAMES
    FIELDS --&gt; FIELDENUM
    ENUMP --&gt; TAGS</literallayout>
<simpara>The introspection API provides:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>fields(T)</literal>: Returns compile-time field information for any struct, union, enum, or error set—iterate with <literal>inline for</literal> to process each field.</simpara>
</listitem>
<listitem>
<simpara><literal>fieldInfo(T, field)</literal>: Gets detailed information (name, type, default value, alignment) for a specific field.</simpara>
</listitem>
<listitem>
<simpara><literal>FieldEnum(T)</literal>: Creates an enum with variants for each field name, enabling switch-based field dispatch.</simpara>
</listitem>
<listitem>
<simpara><literal>declarations(T)</literal>: Returns compile-time declaration info for functions and constants in a type—useful for finding optional interface methods.</simpara>
</listitem>
</itemizedlist>
<simpara>Example pattern: <literal>inline for (std.meta.fields(MyStruct)) |field| { &#8230;&#8203; }</literal> lets you write generic serialization, formatting, or comparison functions without hand-coding field access. The <literal>FieldEnum(T)</literal> helper is particularly useful for switch statements over field names. <link xl:href="https://github.com/ziglang/zig/blob/master/lib/std/meta.zig">meta.zig</link></simpara>
</section>
</chapter>
<chapter xml:id="inline-and-unrolling">
<title>Inline functions and inline loops: power and cost</title>
<simpara><literal>inline fn</literal> forces inlining, and <literal>inline for</literal> unrolls compile-time-known iterations. Both increase code size. Use them when you’ve profiled and determined a hot path benefits from unrolling or call-overhead elimination.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 15__comptime-and-reflection.adoc - include::example$chapters-data/code/15__comptime-and-reflection/inline_for_inline_fn.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/15__comptime-and-reflection/inline_for_inline_fn.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">acc=26</programlisting>
</para>
</formalpara>
<caution>
<simpara>Inline is not a performance cheat code. It trades instruction cache and binary size for potential speed. Measure before and after. <link xl:href="39__performance-and-inlining.xml">39</link></simpara>
</caution>
</chapter>
<chapter xml:id="decl-field-embedfile">
<title>Capabilities: <literal>@hasDecl</literal>, <literal>@hasField</literal>, and <literal>@embedFile</literal></title>
<simpara>Compile-time capability tests let you adapt to types without overfitting APIs. Asset embedding keeps small resources close to the code with no runtime I/O.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 15__comptime-and-reflection.adoc - include::example$chapters-data/code/15__comptime-and-reflection/has_decl_field_embedfile.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/15__comptime-and-reflection/has_decl_field_embedfile.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">has greet: true
has field x: true
message: compile-time constant
embedded:
Hello from @embedFile!
This text is compiled into the binary at build time.</programlisting>
</para>
</formalpara>
<tip>
<simpara>Place assets next to the source that uses them and reference with a relative path in <literal>@embedFile</literal>. For larger assets or user-supplied data, prefer runtime I/O. <link xl:href="28__filesystem-and-io.xml">28</link></simpara>
</tip>
</chapter>
<chapter xml:id="anytype-generics">
<title><literal>anytype</literal> and explicit type parameters: pragmatic generics</title>
<simpara>Zig’s generics are just functions with <literal>comptime</literal> parameters. Use explicit type parameters for clarity; use <literal>anytype</literal> in leaf helpers that forward types. Reflection (<literal>@TypeOf</literal>, <literal>@typeName</literal>) helps with diagnostics when you accept flexible inputs.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 15__comptime-and-reflection.adoc - include::example$chapters-data/code/15__comptime-and-reflection/anytype_and_generics.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/15__comptime-and-reflection/anytype_and_generics.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">sum(u32,[1,2,3,4]) = 10
sum(u64,[10,20]) = 30
value of type u8: 42
value of type *const [5:0]u8: { 104, 101, 108, 108, 111 }</programlisting>
</para>
</formalpara>
<important>
<simpara>Prefer explicit <literal>comptime T: type</literal> parameters for public APIs; restrict <literal>anytype</literal> to helpers that transparently forward the concrete type and don’t constrain semantics.</simpara>
</important>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>Compile-time execution runs in the compiler; be mindful of complexity. Keep heavy work out of tight incremental loops to preserve fast rebuilds. <link xl:href="38__zig-cli-deep-dive.xml">38</link></simpara>
</listitem>
<listitem>
<simpara>Inline loops require compile-time-known bounds. When in doubt, use runtime loops and let the optimizer do its job. <link xl:href="39__performance-and-inlining.xml">39</link></simpara>
</listitem>
<listitem>
<simpara>Reflection is powerful but can obscure control flow. Prefer straightforward parameters for clarity, and reflect only where ergonomics justify it. <link xl:href="36__style-and-best-practices.xml">36</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Write a <literal>formatFields</literal> helper that uses <literal>@typeInfo</literal> to print any struct’s field names and values. Try it with nested structs and slices. <link xl:href="45__text-formatting-and-unicode.xml">47</link></simpara>
</listitem>
<listitem>
<simpara>Build a compile-time computed <literal>sin</literal>/<literal>cos</literal> lookup table for integer angles and benchmark against <literal>std.math</literal> calls in a tight loop. Measure code size and runtime. <link xl:href="50__random-and-math.xml">50</link></simpara>
</listitem>
<listitem>
<simpara>Add a <literal>hasToString</literal> check: if a type <literal>T</literal> has a <literal>format</literal> method, print with <literal>{f}</literal>, otherwise print with <literal>{any}</literal>. Clarify behavior in a short doc comment.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Alternatives &amp; Edge Cases</title>
<itemizedlist>
<listitem>
<simpara><literal>@inComptime()</literal> is <literal>true</literal> in comptime contexts only; don’t rely on it for runtime behavior switches. Keep such switches in values/parameters.</simpara>
</listitem>
<listitem>
<simpara><literal>@embedFile</literal> increases binary size; avoid embedding large resources. For configs/logos, it’s great. For datasets, stream from disk or network. <link xl:href="28__filesystem-and-io.xml">28</link></simpara>
</listitem>
<listitem>
<simpara>Avoid <literal>inline fn</literal> on large functions; it can balloon code. Use it on leaf arithmetic helpers or very small combinators where profiling shows wins. <link xl:href="39__performance-and-inlining.xml">39</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>