<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Compression and Archives</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Zig trims its compression APIs down to the pragmatic core: high-quality decompressors that plug into the new <literal>std.Io.Reader</literal>/<literal>Writer</literal> interfaces and feed formats like TAR and ZIP without hidden side effects. <link xl:href="https://ziglang.org/download/0.15.1/release-notes.html#reworked-stdcompressflate">#reworked stdcompressflate</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/compress/flate.zig">flate.zig</link> Bringing these pieces together lets you revive logs, package assets, or slurp registries straight into memory while keeping the same explicit resource management discipline.</simpara>
<simpara>Because Zig treats archives as simple byte streams, the challenge shifts from magic helper functions to composing the right iterators, buffers, and metadata checks. Mastering the decompression building blocks here prepares you for the package pipelines and deployment tooling. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/tar.zig">tar.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/zip.zig">zip.zig</link></simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Drive <literal>std.compress.flate.Decompress</literal>, <literal>std.compress.lzma2.decompress</literal>, and friends directly against <literal>std.Io.Reader</literal>/<literal>Writer</literal> endpoints.<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/compress/flate/Decompress.zig">Decompress.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/compress/lzma2.zig">lzma2.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Io/Writer.zig">Writer.zig</link></simpara>
</listitem>
<listitem>
<simpara>Choose history buffers, streaming limits, and allocators that keep decompression memory-safe under both debug and release builds.<link xl:href="10__allocators-and-memory-management.xml">10</link></simpara>
</listitem>
<listitem>
<simpara>Generate small TAR archives on the fly and iterate them without touching disk state.<link xl:href="28__filesystem-and-io.xml">28</link></simpara>
</listitem>
<listitem>
<simpara>Inspect and extract ZIP central directory entries while enforcing filesystem hygiene and compression-method constraints.<link xl:href="36__style-and-best-practices.xml">36</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="streaming-decompression">
<title>Streaming Decompression Interfaces</title>
<simpara>Zig&#8217;s decompressors speak the same streaming dialect: you hand them any reader, optionally supply a scratch buffer, and they emit their payload into a writer you already own. That design leaves full control over allocation, error propagation, and flushing behavior.<link xl:href="22__build-system-deep-dive.xml">22</link></simpara>
<section xml:id="streaming-decompression-flate">
<title>Flate Containers in Practice</title>
<simpara>Deflate-style payloads (raw, zlib, gzip) rely on a history window up to 32 KiB. Zig 0.15.2 lets you skip allocating that window when you pipe data straight into another writer—pass <literal>&amp;.{}</literal>, and the decoder will call <literal>streamRemaining</literal> with minimal buffering.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 49__compression-and-archives.adoc - include::example$chapters-data/code/49__compression-and-archives/inflate_greeting.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run inflate_greeting.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">decoded (49 bytes): Streaming decompression keeps tools predictable.</programlisting>
</para>
</formalpara>
<tip>
<simpara><literal>std.Io.Writer.fixed</literal> provides a stack-allocated sink with deterministic capacity; always flush manual stdout buffers afterwards to avoid losing output when the process exits.<link xl:href="01__boot-basics.xml">1</link></simpara>
</tip>
</section>
<section xml:id="streaming-decompression-lzma2">
<title>LZMA2 Without External Tooling</title>
<simpara>Some registries still ship LZMA2 frames for deterministic byte-for-byte payloads. Zig wraps the decoder behind a single helper that grows an <literal>std.Io.Writer.Allocating</literal> for you—perfect for short configuration bundles or firmware blocks.<link xl:href="12__config-as-data.xml">12</link></simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 49__compression-and-archives.adoc - include::example$chapters-data/code/49__compression-and-archives/lzma2_memory_decode.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run lzma2_memory_decode.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">lzma2 decoded (13 bytes):
Hello
World!</programlisting>
</para>
</formalpara>
<note>
<simpara><literal>std.heap.GeneralPurposeAllocator</literal> now reports leaks via an enum—assert on <literal>.ok</literal> during teardown so corrupted archives fail loudly under debug builds.<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/heap.zig">heap.zig</link> <link xl:href="13__testing-and-leak-detection.xml">13</link></simpara>
</note>
</section>
<section xml:id="streaming-decompression-other-codecs">
<title>Window Sizing Across zstd, xz, and Friends</title>
<simpara><literal>std.compress.zstd.Decompress</literal> defaults to an 8 MiB window, while <literal>std.compress.xz.Decompress</literal> performs checksum validation as part of stream finalization.<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/compress/zstd.zig">zstd.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/compress/xz.zig">xz.zig</link> When wiring unfamiliar data sources, start with empty scratch buffers to minimize peak memory, then profile with <literal>ReleaseFast</literal> builds before opting into persistent ring buffers.<link xl:href="39__performance-and-inlining.xml">39</link></simpara>
</section>
</chapter>
<chapter xml:id="archive-workflows">
<title>Archive Workflows</title>
<simpara>With decompression primitives in hand, archives become composition exercises: format-specific iterators hand you metadata, and you decide whether to buffer, discard, or stream to disk.<link xl:href="28__filesystem-and-io.xml">28</link></simpara>
<section xml:id="archive-workflows-tar">
<title>TAR Roundtrip Entirely in Memory</title>
<simpara><literal>std.tar.Writer</literal> emits deterministic 512-byte blocks, so you can assemble small bundles in RAM, inspect them, and only then decide whether to persist them.<link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 49__compression-and-archives.adoc - include::example$chapters-data/code/49__compression-and-archives/tar_roundtrip.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run tar_roundtrip.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">tar archive is 1536 bytes and holds:
- reports (directory, 0 bytes)
- reports/summary.txt (file, 19 bytes)
  contents: cpu=28%
mem=512MiB</programlisting>
</para>
</formalpara>
<tip>
<simpara>After calling <literal>Iterator.next</literal> on a regular file, you must drain the payload with <literal>streamRemaining</literal>; otherwise, the next header will be misaligned and the iterator throws <literal>error.UnexpectedEndOfStream</literal>.</simpara>
</tip>
</section>
<section xml:id="archive-workflows-zip">
<title>Peeking Into ZIP Central Directories Safely</title>
<simpara>ZIP support exposes the central directory via <literal>std.zip.Iterator</literal>, leaving extraction policy to you. Routing entries through <literal>std.testing.tmpDir</literal> keeps artifacts isolated while you validate compression methods and inspect contents.<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/testing.zig">testing.zig</link></simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 49__compression-and-archives.adoc - include::example$chapters-data/code/49__compression-and-archives/zip_iterator_preview.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run zip_iterator_preview.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">zip archive contains:
- demo/readme.txt (store, 34 bytes)
  text: Decompression from Zig streaming.

- demo/raw.bin (store, 4 bytes)
  bytes:
    00 01 02 03</programlisting>
</para>
</formalpara>
<note>
<simpara><literal>std.zip.Entry.extract</literal> only supports <literal>store</literal> and <literal>deflate</literal>; reject other methods up front or shell out to a third-party library when interoperability demands it.</simpara>
</note>
</section>
<section xml:id="archive-workflows-patterns">
<title>Pattern Catalog for Mixed Sources</title>
<simpara>Blend these techniques to hydrate manifests from package registries, decompress release artifacts before signature checks, or stage binary blobs for GPU uploads—all without leaving Zig&#8217;s standard toolbox.<link xl:href="35__project-gpu-compute-in-zig.xml">35</link></simpara>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>Passing a zero-length buffer to <literal>std.compress.flate.Decompress.init</literal> disables history reuse, but large archives benefit from reusing a <literal>[flate.max_window_len]u8</literal> scratch array.</simpara>
</listitem>
<listitem>
<simpara>TAR iterators keep state about unread file bytes; always stream or discard them before advancing to the next header.</simpara>
</listitem>
<listitem>
<simpara>ZIP extraction normalizes backslashes only when <literal>allow_backslashes = true</literal>; enforce forward slashes to avoid directory traversal bugs on Windows.<link xl:href="33__c-interop-import-export-abi.xml">33</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Rework the flate example to stream directly into <literal>std.fs.File.stdout().writer</literal> without a fixed buffer and profile the difference across build modes.<link xl:href="39__performance-and-inlining.xml">39</link></simpara>
</listitem>
<listitem>
<simpara>Extend the TAR roundtrip demo to attach a generated checksum footer file summarizing every entry length.<link xl:href="43__stdlib-index.xml">43</link></simpara>
</listitem>
<listitem>
<simpara>Add a <literal>verify_checksums</literal> pass to the ZIP iterator by computing CRC32 over extracted data and comparing it to the central directory record.<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/hash/crc.zig">crc.zig</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Caveats, Alternatives, Edge Cases</title>
<itemizedlist>
<listitem>
<simpara>Compression backends (especially zstd) may require larger buffers on older CPUs without BMI2; detect <literal>builtin.cpu.features</literal> before choosing lean windows.<link xl:href="41__cross-compilation-and-wasm.xml">41</link></simpara>
</listitem>
<listitem>
<simpara>LZMA2 decoding still allocates internal state; stash a shared decoder if you process many small frames to avoid heap churn.<link xl:href="10__allocators-and-memory-management.xml">10</link></simpara>
</listitem>
<listitem>
<simpara>For reproducible release archives, pin file ordering and timestamps explicitly—host filesystem metadata leaks otherwise.<link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>