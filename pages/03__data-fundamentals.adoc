////
changes: ["Initial draft for Data Fundamentals chapter"]
examples_compile: yes
keywords: ["arrays", "slices", "pointers"]
last_updated: 2025-11-01
last_verified: 2025-11-01
next_chapter: "04__errors-resource-cleanup"
open_questions: []
previous_chapter: "02__control-flow-essentials"
status: reviewed
xref_complete: true
////

= Data Fundamentals
:chapter-number: 3
:chapter-slug: data-fundamentals
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Control flow is only as useful as the data it pilots, so this chapter grounds Zig's core collection typesâ€”arrays, slices, and sentinel-terminated stringsâ€”in practical usage while keeping value semantics explicit. See link:https://ziglang.org/documentation/master/#Arrays[#Arrays] and link:https://ziglang.org/documentation/master/#Slices[#Slices] for reference.

We also make pointers, optionals, and alignment-friendly casts feel routine, showing how to safely reinterpret memory while retaining bounds checks and clarity about mutability. See link:https://ziglang.org/documentation/master/#Pointers[#Pointers] and link:https://ziglang.org/documentation/master/#alignCast[#alignCast] for details.

[[type-system-context]]
=== Zig's Type System Categories

Before diving into specific collection types, it's helpful to understand where arrays, slices, and pointers fit within Zig's type system. Every type in Zig belongs to a category, and each category provides specific operations:

[mermaid]
....
graph TB
    subgraph "Type Categories"
        PRIMITIVE["Primitive Types<br/>bool, u8, i32, f64, void, ..."]
        POINTER["Pointer Types<br/>*T, [*]T, []T, [:0]T"]
        AGGREGATE["Aggregate Types<br/>struct, array, tuple"]
        FUNCTION["Function Types<br/>fn(...) ReturnType"]
        SPECIAL["Special Types<br/>anytype, type, comptime_int"]
    end

    subgraph "Common Type Operations"
        ABISIZE["abiSize()<br/>Byte size in memory"]
        ABIALIGN["abiAlignment()<br/>Required alignment"]
        HASRUNTIME["hasRuntimeBits()<br/>Has runtime storage?"]
        ELEMTYPE["elemType()<br/>Element type (arrays/slices)"]
    end

    PRIMITIVE --> ABISIZE
    POINTER --> ABISIZE
    AGGREGATE --> ABISIZE
    
    PRIMITIVE --> ABIALIGN
    POINTER --> ABIALIGN
    AGGREGATE --> ABIALIGN
    
    POINTER --> ELEMTYPE
    AGGREGATE --> ELEMTYPE
....

Key insights for this chapter:

* *Arrays* are aggregate types with compile-time-known lengthâ€”their size is `element_size * length`
* *Slices* are pointer types that store both a pointer and runtime lengthâ€”always 2 Ã— pointer size
* *Pointers* come in multiple shapes (single-item `pass:[*T]`, many-item `pass:[[*\]T]`, slice `[]T`) with different safety guarantees
* All types expose their size and alignment, which affect struct layout and memory allocation

This type-aware design lets the compiler enforce bounds checking on slices while allowing pointer arithmetic on many-item pointers when you explicitly opt out of safety.

[[learning-goals]]
== Learning Goals

* Distinguish array value semantics from slice views, including zero-length idioms for safe fallbacks.
* Navigate pointer shapes (`pass:[*T]`, `pass:[[*\]T]`, `pass:[?*T]`) and unwrap optionals without sacrificing safety instrumentation (see link:https://ziglang.org/documentation/master/#Optionals[#Optionals]).
* Apply sentinel-terminated strings and alignment-aware casts (`@alignCast`, `@bitCast`, `@intCast`) when interoperating with other APIs (see link:https://ziglang.org/documentation/master/#Sentinel-Terminated-Pointers[#Sentinel-Terminated-Pointers] and link:https://ziglang.org/documentation/master/#Explicit-Casts[#Explicit-Casts]).

[[section-1]]
== Structuring Collections in Memory

Arrays own storage while slices borrow it, so the compiler enforces different guarantees around length, mutability, and lifetimes; mastering their interplay keeps iteration predictable and moves most bounds checks into debug builds.

[[section-1-sub-a]]
=== Arrays as Owned Storage

Arrays carry length in their type, copy by value, and give you a mutable baseline from which to carve read-only and read-write slices.

[source,zig]
----

include::{sourcedir}/03__data-fundamentals/arrays_and_slices.zig[]

----

.Run
[source,shell]
----
$ zig run arrays_and_slices.zig
----

.Output
[source,shell]
----
array len=4 allows mutation
mutable_slice: len=4 head=-3
prefix: len=2 head=-3
values[0] after slice write = -3
empty slice len=0 is zero-length
copy[0]=-1 owned[0]=1
zero slice len=0 from literal
----

[NOTE]
The mutable slice and the original array share storage, while the `[]const` prefix resists writesâ€”an intentional boundary that forces read-only consumers to stay honest.

==== Memory Layout: Arrays vs Slices

Understanding how arrays and slices are laid out in memory clarifies why "arrays own storage while slices borrow it" and why array-to-slice coercion is a cheap operation:

[mermaid]
....
graph TB
    subgraph "Array in Memory"
        ARRAY_DECL["const values: [4]i32 = .{1, 2, 3, 4}"]
        ARRAY_MEM["Memory Layout (16 bytes)\n\nstack frame\n| 1 | 2 | 3 | 4 |"]
        
        ARRAY_DECL --> ARRAY_MEM
    end
    
    subgraph "Slice in Memory"
        SLICE_DECL["const slice: []const i32 = &values"]
        SLICE_MEM["Memory Layout (16 bytes on 64-bit)\n\nstack frame\n|    ptr    |   len=4   |"]
        POINTS["ptr points to array data"]
        
        SLICE_DECL --> SLICE_MEM
        SLICE_MEM --> POINTS
    end
    
    POINTS -.->|"references"| ARRAY_MEM
    
    subgraph "Key Differences"
        DIFF1["Array: Stores data inline<br/>Size = elem_size Ã— length"]
        DIFF2["Slice: Stores pointer + length<br/>Size = 2 Ã— pointer_size (16 bytes on 64-bit)"]
        DIFF3["Coercion: &array â†’ slice<br/>Just creates {ptr, len} pair"]
    end
....

**Why this matters:**

* Arrays have **value semantics**: assigning an array copies all elements
* Slices have **reference semantics**: assigning a slice copies just the pointer and length
* Array-to-slice coercion (`&array`) is cheapâ€”it doesn't copy data, just creates a descriptor
* Slices are "fat pointers": they carry runtime length information, enabling bounds checking

This is why functions typically accept slices as parametersâ€”they can work with arrays, slices, and portions of either without copying the underlying data.

[[section-1-sub-b]]
=== Strings and Sentinels in Practice

Sentinel-terminated arrays bridge to C APIs without forfeiting the safety of slices; you can reinterpret the byte stream with `std.mem.span` and still mutate the underlying buffer when the sentinel convention is preserved.

[source,zig]
----
    
include::{sourcedir}/03__data-fundamentals/sentinel_strings.zig[]

----

.Run
[source,shell]
----
$ zig run sentinel_strings.zig
----

.Output
[source,shell]
----
literal len=17 contents="data fundamentals"
trimmed slice len=4 -> Labe
full label after mutation: LabeX
----

The sentinel slice keeps the trailing zero intact, so taking a `pass:[[*:0\]u8]` for FFI remains sound even after local mutations, while the plain slice gives ergonomic iteration within Zig (see link:https://ziglang.org/documentation/master/#Type-Coercion[#Type-Coercion]).

TIP: `std.mem.span` converts sentinel pointers into ordinary slices without cloning data, making it ideal when you temporarily need bounds checks or slice helpers before returning to pointer APIs.

[[section-1-sub-c]]
=== Immutable and Mutable Views

Prefer `[]const T` when callers only inspect dataâ€”Zig will gladly coerce a mutable slice to a const view, giving you API clarity and keeping accidental writes from compiling in the first place.

[[section-2]]
== Pointer Patterns and Cast Workflows

Pointers surface when you share storage, interoperate with foreign layouts, or step outside slice bounds; by leaning on optional wrappers and explicit casts, you keep intent clear and allow safety checks to fire whenever assumptions break.

[[pointer-shapes]]
=== Pointer Shape Reference

Zig offers multiple pointer types, each with different safety guarantees and use cases. Understanding when to use each shape is essential for writing safe, efficient code:

[mermaid]
....
graph TB
    subgraph "Pointer Shapes"
        SINGLE["*T<br/>Single-Item Pointer"]
        MANY["[*]T<br/>Many-Item Pointer"]
        SLICE["[]T<br/>Slice"]
        OPTIONAL["?*T<br/>Optional Pointer"]
        SENTINEL_PTR["[*:0]T<br/>Sentinel Many-Item"]
        SENTINEL_SLICE["[:0]T<br/>Sentinel Slice"]
    end
    
    subgraph "Characteristics"
        SINGLE --> S_BOUNDS["âœ“ Bounds: Single element<br/>âœ“ Safety: Dereference checked<br/>ðŸ“ Use: Function parameters, references"]
        
        MANY --> M_BOUNDS["âš  Bounds: Unknown length<br/>âœ— Safety: No bounds checking<br/>ðŸ“ Use: C interop, tight loops"]
        
        SLICE --> SL_BOUNDS["âœ“ Bounds: Runtime length<br/>âœ“ Safety: Bounds checked<br/>ðŸ“ Use: Most Zig code, iteration"]
        
        OPTIONAL --> O_BOUNDS["âœ“ Bounds: May be null<br/>âœ“ Safety: Must unwrap first<br/>ðŸ“ Use: Optional references"]
        
        SENTINEL_PTR --> SP_BOUNDS["âœ“ Bounds: Until sentinel<br/>~ Safety: Sentinel must exist<br/>ðŸ“ Use: C strings, null-terminated"]
        
        SENTINEL_SLICE --> SS_BOUNDS["âœ“ Bounds: Length + sentinel<br/>âœ“ Safety: Both length and sentinel<br/>ðŸ“ Use: Zig â†” C string bridge"]
    end
....

**Comparison Table:**

|===
| Shape | Example | Length Known? | Bounds Checked? | Common Use

| `*T`
| `*i32`
| Single element
| Yes (implicit)
| Reference to one item

| `[*]T`
| `[*]i32`
| Unknown
| **No**
| C arrays, pointer arithmetic

| `[]T`
| `[]i32`
| Runtime (in slice)
| **Yes**
| Primary Zig collection type

| `?*T`
| `?*i32`
| Single (if non-null)
| Yes + null check
| Optional references

| `[*:0]T`
| `[*:0]u8`
| Until sentinel
| Sentinel must exist
| C strings (`char*`)

| `[:0]T`
| `[:0]u8`
| Runtime + sentinel
| Yes + sentinel guarantee
| Zig strings for C APIs
|===

**Guidelines:**

* **Default to slices** (`[]T`) for all Zig codeâ€”they provide safety and convenience
* **Use single-item pointers** (`pass:[*T]`) when you need to mutate a single value or pass by reference
* **Avoid many-item pointers** (`pass:[[*\]T]`) unless interfacing with C or in performance-critical inner loops
* **Use optional pointers** (`pass:[?*T]`) when null is a meaningful state, not for error handling
* **Use sentinel types** (`pass:[[*:0\]T]`, `[:0]T`) at the C boundary, convert to slices internally

[[workflow-1]]
=== Optional Pointers for Shared Mutability

Optional single-item pointers expose mutability without guessing at lifetimesâ€”capture them only when present, mutate through the dereference, and fall back gracefully when the pointer is absent.

[source,zig]
----

include::{sourcedir}/03__data-fundamentals/pointers_and_optionals.zig[]

----

.Run
[source,shell]
----
$ zig run pointers_and_optionals.zig
----

.Output
[source,shell]
----
alias -> reading 42
optional pointer empty
optional pointer mutated to 52
slice view len=4
samples[2] via many pointer = 42
----

The `pass:[?*Sensor]` gate keeps mutation behind pattern matching, while the many-item pointer (`pass:[[*\]i32]`) documents aliasing risk by dropping bounds checksâ€”a deliberate trade-off reserved for tight loops and FFI.

[[workflow-2]]
=== Aligning and Reinterpreting Data

When you must reinterpret raw bytes, use the casting builtins to promote alignment, change pointer element types, and keep integer/float conversions explicit so debug builds can catch undefined assumptions (see link:https://ziglang.org/documentation/master/#bitCast[#bitCast]).

[source,zig]
----
    
include::{sourcedir}/03__data-fundamentals/alignment_and_casts.zig[]

----

.Run
[source,shell]
----
$ zig run alignment_and_casts.zig
----

.Output
[source,shell]
----
32-bit value = 0x11223344
bitcast copy = 0x11223344
truncate -> 0x44, widen -> 287454020
floatCast ratio -> 1.875
----

By chaining `@alignCast`, `@ptrCast`, and `@bitCast` you assert layout relationships explicitly, and the subsequent `@truncate`/`@intCast` conversions keep integer widths honest when narrowing or widening across APIs.

[[notes-caveats]]
== Notes & Caveats

* Sentinel-terminated pointers are great for C bridges, but within Zig prefer slices so bounds checks stay available and APIs expose lengths.
* Upgrading pointer alignment with `@alignCast` still traps in Debug mode if the address is misalignedâ€”prove the precondition before promoting.
* Many-item pointers (`pass:[[*\]T]`) drop bounds checks; reach for them sparingly and document invariants that a safe slice would have enforced.

[[exercises]]
== Exercises

* Extend `arrays_and_slices.zig` to create a zero-length mutable slice from a runtime array, then append via `std.ArrayList` to observe how slice views remain valid.
* Modify `sentinel_strings.zig` to accept a user-supplied `[:0]u8` and guard against inputs missing the sentinel by returning an error union.
* Enhance `alignment_and_casts.zig` by adding a branch that rejects values whose low byte is zero before truncation, surfacing how `@intCast` depends on caller-supplied range guarantees.
