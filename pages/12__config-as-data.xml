<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Config as Data</title>
<subtitle>Struct-Based Config</subtitle>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Configuration files eventually become ordinary data in memory. By giving that data a rich type—complete with defaults, enums, and optionals—you can reason about misconfigurations at compile time, validate invariants with determinism, and hand-tuned settings to downstream code without stringly-typed glue (see <link xl:href="11__project-dynamic-string-builder.xml">11</link> and <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/meta.zig">meta.zig</link>).</simpara>
<simpara>This chapter establishes a playbook for struct-based configuration: start with default-heavy structs, overlay layered overrides such as environment or command-line flags, then enforce guardrails with explicit error sets so the eventual CLI in the next project can trust its inputs (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/log.zig">log.zig</link>).</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Model nested configuration structs with enums, optionals, and sensible defaults to capture application intent.</simpara>
</listitem>
<listitem>
<simpara>Layer profile, environment, and runtime overrides using reflection helpers such as <literal>std.meta.fields</literal> while keeping merges type-safe.</simpara>
</listitem>
<listitem>
<simpara>Validate configs with dedicated error sets, structured reporting, and inexpensive diagnostics so downstream systems can fail fast. <link xl:href="04__errors-resource-cleanup.xml">04</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="config-structs">
<title>Structs as Configuration Contracts</title>
<simpara>Typed configuration mirrors the invariants you expect in production. Zig structs let you declare defaults inline, encode modes with enums, and group related knobs so callers cannot accidentally pass malformed tuples. Leaning on standard-library enums, log levels, and writers keeps the API ergonomic while honoring the I/O interface overhaul in <link xl:href="https://ziglang.org/download/0.15.1/release-notes.html">v0.15.2</link>.</simpara>
<section xml:id="config-structs-defaults">
<title>Default-rich struct definitions</title>
<simpara>The baseline configuration provides defaults for every field, including nested structs. Consumers can use designated initializers to selectively override values without losing the rest of the defaults.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 12__config-as-data.adoc - include::example$chapters-data/code/12__config-as-data/default_config.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run default_config.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">defaults -&gt;
  host = 127.0.0.1
  port = 8080
  log_level = info
  instrumentation = false
  theme = system
  timeouts = .{ connect_ms = 200, read_ms = 1200 }

overrides -&gt;
  host = 0.0.0.0
  port = 9090
  log_level = debug
  instrumentation = true
  theme = dark
  timeouts = .{ connect_ms = 75, read_ms = 1500 }</programlisting>
</para>
</formalpara>
</section>
<section xml:id="config-structs-optionals">
<title>Optionals versus sentinel defaults</title>
<note>
<simpara>Only fields that truly need tri-state semantics become optionals (<literal>?[]const u8</literal> for TLS file paths later in the chapter); everything else sticks to concrete defaults. Combining nested structs (here, <literal>Timeouts</literal>) with <literal>[]const u8</literal> strings supplies immutable references that remain valid for the lifetime of the configuration (see <link xl:href="03__data-fundamentals.xml">03</link>).</simpara>
</note>
</section>
<section xml:id="config-structs-initializers">
<title>Designated overrides stay readable</title>
<simpara>Since designated initializers allow you to override just the fields you care about, you can keep configuration declarations near call sites without sacrificing discoverability. Treat the struct literal as documentation: group related overrides together and lean on enums (like <literal>Theme</literal>) to keep magic strings out of your build. <link xl:href="02__control-flow-essentials.xml">02</link>, <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/enums.zig">enums.zig</link></simpara>
<section xml:id="parsing-enum-values">
<title>Parsing Enum Values from Strings</title>
<simpara>When loading configuration from JSON, YAML, or environment variables, you&#8217;ll often need to convert strings to enum values. Zig&#8217;s <literal>std.meta.stringToEnum</literal> handles this with compile-time optimization based on enum size.</simpara>
<literallayout class="monospaced">graph LR
    STRINGTOENUM["stringToEnum(T, str)"]

    subgraph "Small Enums"
        SMALL["fields.len &lt;= 100"]
        MAP["StaticStringMap"]
        STRINGTOENUM --&gt; SMALL
        SMALL --&gt; MAP
    end

    subgraph "Large Enums"
        LARGE["fields.len &gt; 100"]
        INLINE["inline for loop"]
        STRINGTOENUM --&gt; LARGE
        LARGE --&gt; INLINE
    end

    RESULT["?T"]
    MAP --&gt; RESULT
    INLINE --&gt; RESULT</literallayout>
<simpara>For small enums (≤100 fields), <literal>stringToEnum</literal> builds a compile-time <literal>StaticStringMap</literal> for O(1) lookups. Larger enums use an inline loop to avoid compilation slowdowns from massive switch statements. The function returns <literal>?T</literal> (optional enum value), allowing you to handle invalid strings gracefully:</simpara>
<programlisting language="zig" linenumbering="unnumbered">const theme_str = "dark";
const theme = std.meta.stringToEnum(Theme, theme_str) orelse .system;</programlisting>
<simpara><emphasis role="strong">This pattern is essential for config loaders:</emphasis> parse the string, fall back to a sensible default if invalid. The optional return forces you to handle the error case explicitly, preventing silent failures from typos in config files (see <link xl:href="https://github.com/ziglang/zig/blob/master/lib/std/meta.zig">meta.zig</link>).</simpara>
</section>
</section>
</chapter>
<chapter xml:id="config-layering">
<title>Layering and Overrides</title>
<simpara>Real deployments pull configuration from multiple sources. By representing each layer as a struct of optionals, you can merge them deterministically: reflection bridges make it easy to iterate across fields without hand-writing boilerplate for every knob. <link xl:href="05__project-tempconv-cli.xml">05</link></simpara>
<section xml:id="config-layering-example">
<title>Merging layered overrides</title>
<simpara>This program applies profile, environment, and command-line overrides where they exist, falling back to defaults otherwise. The merge order becomes explicit in <literal>apply</literal>, and the resulting struct stays fully typed.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 12__config-as-data.adoc - include::example$chapters-data/code/12__config-as-data/merge_overrides.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/12__config-as-data/merge_overrides.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">defaults:
  host = 127.0.0.1
  port = 8080
  log = info
  instrumentation = false
  theme = system
  timeouts = .{ .connect_ms = 200, .read_ms = 1200 }
profile:
  host = 0.0.0.0
  port = 9000
  log = debug
  instrumentation = true
  theme = dark
  timeouts = .{ .connect_ms = 100, .read_ms = 1500 }
env:
  host = config.internal
  port = 9443
  log = warn
  instrumentation = false
  theme = system
  timeouts = .{ .connect_ms = 60, .read_ms = 1100 }
command_line:
  host = 127.0.0.1
  port = 8080
  log = info
  instrumentation = false
  theme = light
  timeouts = .{ .connect_ms = 200, .read_ms = 1200 }

resolved:
  host = config.internal
  port = 9443
  log = warn
  instrumentation = false
  theme = light
  timeouts = .{ .connect_ms = 60, .read_ms = 1100 }</programlisting>
</para>
</formalpara>
<simpara>See <link xl:href="10__allocators-and-memory-management.xml">10</link> for allocator background relevant to layered configuration.</simpara>
<section xml:id="field-introspection">
<title>How Field Iteration Works Under the Hood</title>
<simpara>The <literal>apply</literal> function uses <literal>std.meta.fields</literal> to iterate over struct fields at compile time. Zig&#8217;s reflection API provides a rich set of introspection capabilities that make generic config merging possible without hand-written boilerplate for each field.</simpara>
<literallayout class="monospaced">graph TB
    subgraph "Container Introspection"
        FIELDS["fields(T)"]
        FIELDINFO["fieldInfo(T, field)"]
        FIELDNAMES["fieldNames(T)"]
        TAGS["tags(T)"]
        FIELDENUM["FieldEnum(T)"]
    end

    subgraph "Declaration Introspection"
        DECLARATIONS["declarations(T)"]
        DECLINFO["declarationInfo(T, name)"]
        DECLENUM["DeclEnum(T)"]
    end

    subgraph "Applicable Types"
        STRUCT["struct"]
        UNION["union"]
        ENUMP["enum"]
        ERRORSET["error_set"]
    end

    STRUCT --&gt; FIELDS
    UNION --&gt; FIELDS
    ENUMP --&gt; FIELDS
    ERRORSET --&gt; FIELDS

    STRUCT --&gt; DECLARATIONS
    UNION --&gt; DECLARATIONS
    ENUMP --&gt; DECLARATIONS

    FIELDS --&gt; FIELDINFO
    FIELDS --&gt; FIELDNAMES
    FIELDS --&gt; FIELDENUM
    ENUMP --&gt; TAGS</literallayout>
<simpara>The introspection API provides:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong"><literal>fields(T)</literal></emphasis>: Returns compile-time field information for any struct, union, enum, or error set</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><literal>fieldInfo(T, field)</literal></emphasis>: Gets detailed information for a specific field (name, type, default value, alignment)</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><literal>FieldEnum(T)</literal></emphasis>: Creates an enum with variants for each field name, useful for switch statements over fields</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong"><literal>declarations(T)</literal></emphasis>: Returns compile-time declaration info for functions and constants in a type</simpara>
</listitem>
</itemizedlist>
<simpara>When you see <literal>inline for (std.meta.fields(Config))</literal> in the merge logic, Zig unrolls this loop at compile time, generating specialized code for each field. This eliminates runtime overhead while maintaining type safety—the compiler verifies that all field types match between layers (see <link xl:href="https://github.com/ziglang/zig/blob/master/lib/std/meta.zig">meta.zig</link>).</simpara>
</section>
</section>
<section xml:id="config-layering-precedence">
<title>Making precedence explicit</title>
<simpara>Because <literal>apply</literal> copies the merged struct on each iteration, the order of the slice literal reads top-to-bottom precedence: later entries win. If you need lazy evaluation or short-circuit merging, swap <literal>apply</literal> for a version that stops once a field is set—just remember to keep defaults immutable so earlier layers cannot accidentally mutate shared state. <link xl:href="07__project-safe-file-copier.xml">07</link></simpara>
<section xml:id="deep-equality">
<title>Deep Structural Equality with std.meta.eql</title>
<simpara>For advanced config scenarios like detecting whether a reload is needed, <literal>std.meta.eql(a, b)</literal> performs deep structural comparison. This function handles nested structs, unions, error unions, and optionals recursively:</simpara>
<literallayout class="monospaced">graph TB
    subgraph "Type Comparison"
        EQL["eql(a, b)"]

        STRUCT_EQL["Struct comparison"]
        UNION_EQL["Union comparison"]
        ERRORUNION_EQL["Error union comparison"]
        OPTIONAL_EQL["Optional comparison"]

        EQL --&gt; STRUCT_EQL
        EQL --&gt; UNION_EQL
        EQL --&gt; ERRORUNION_EQL
        EQL --&gt; OPTIONAL_EQL
    end</literallayout>
<simpara>The <literal>eql(a, b)</literal> function performs deep structural equality comparison, handling nested structs, unions, and error unions recursively. This is useful for detecting "no-op" config updates:</simpara>
<programlisting language="zig" linenumbering="unnumbered">const old_config = loadedConfig;
const new_config = parseConfigFile("app.conf");

if (std.meta.eql(old_config, new_config)) {
    // Skip reload, nothing changed
    return;
}
// Apply new config</programlisting>
<simpara>The comparison works field-by-field for structs (including nested <literal>Timeouts</literal>), compares tags and payloads for unions, and handles error unions and optionals correctly (see <link xl:href="https://github.com/ziglang/zig/blob/master/lib/std/meta.zig">meta.zig</link>).</simpara>
</section>
</section>
</chapter>
<chapter xml:id="config-validation">
<title>Validation and Guardrails</title>
<simpara>Typed configs become trustworthy once you defend their invariants. Zig&#8217;s error sets turn validation failures into actionable diagnostics, and helper functions keep reporting consistent whether you&#8217;re logging or surfacing feedback to a CLI (see <link xl:href="04__errors-resource-cleanup.xml">04</link> and <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/debug.zig">debug.zig</link>).</simpara>
<section xml:id="config-validation-example">
<title>Encoding invariants with error sets</title>
<simpara>This validator checks port ranges, TLS prerequisites, and timeout ordering. Each failure maps to a dedicated error tag so callers can react accordingly.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 12__config-as-data.adoc - include::example$chapters-data/code/12__config-as-data/validate_config.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/12__config-as-data/validate_config.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">production: ok
insecure: error InsecureProduction
misordered: error TimeoutOrdering
missing_tls_material: error MissingTlsMaterial</programlisting>
</para>
</formalpara>
<simpara><link xl:href="04__errors-resource-cleanup.xml">04__errors-resource-cleanup.xml</link></simpara>
</section>
<section xml:id="config-validation-reporting">
<title>Reporting helpful diagnostics</title>
<simpara>Use <literal>@errorName</literal> (or structured enums for richer data) when printing validation errors so operators see the exact invariant that failed. Pair that with a shared reporting helper—like <literal>report</literal> in the example—to unify formatting across tests, logging, and CLI feedback (see <link xl:href="03__data-fundamentals.xml">03</link> and <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Io/Writer.zig">Writer.zig</link>).</simpara>
<section xml:id="error-message-format">
<title>Error Message Formatting Standards</title>
<simpara>For production-grade diagnostics, follow the compiler&#8217;s error message format to provide consistent, parsable output. The standard format matches what users expect from Zig tooling:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">Component</entry>
<entry align="left" valign="top">Format</entry>
<entry align="left" valign="top">Description</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Location</simpara></entry>
<entry align="left" valign="top"><simpara><literal>:line:col:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Line and column numbers (1-indexed)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Severity</simpara></entry>
<entry align="left" valign="top"><simpara><literal>error:</literal> or <literal>note:</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Message severity level</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Message</simpara></entry>
<entry align="left" valign="top"><simpara>Text</simpara></entry>
<entry align="left" valign="top"><simpara>The actual error or note message</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Example error messages:</simpara>
<screen>config.toml:12:8: error: port must be between 1024 and 65535
config.toml:15:1: error: TLS enabled but cert_file not specified
config.toml:15:1: note: set cert_file and key_file when tls = true</screen>
<simpara>The colon-separated format allows tools to parse error locations for IDE integration, and the severity levels (<literal>error:</literal> vs <literal>note:</literal>) help users distinguish between problems and helpful context. When validating configuration files, include the filename, line number (if available from your parser), and a clear description of the invariant violation. This consistency makes your config errors feel native to the Zig ecosystem.</simpara>
</section>
</section>
<section xml:id="config-validation-comptime">
<title>Compile-time helpers for schema drift</title>
<simpara>For larger systems, consider wrapping your config struct in a comptime function that verifies field presence with <literal>@hasField</literal> or generates documentation from defaults. This keeps runtime code small while guaranteeing that evolving schemas stay in sync with generated config files (see <link xl:href="15__comptime-and-reflection.xml">15</link>).</simpara>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>Keep immutable <literal>[]const u8</literal> slices for string settings so they can safely alias compile-time literals without extra copies (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/mem.zig">mem.zig</link>).</simpara>
</listitem>
<listitem>
<simpara>Remember to flush buffered writers after emitting configuration diagnostics, especially when mixing stdout with process pipelines.</simpara>
</listitem>
<listitem>
<simpara>When layering overrides, clone mutable sub-structs (like allocator-backed lists) before mutation to avoid cross-layer aliasing. <link xl:href="10__allocators-and-memory-management.xml">10</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Extend <literal>AppConfig</literal> with an optional telemetry endpoint (<literal>?[]const u8</literal>) and update the validator to ensure it is set whenever instrumentation is enabled.</simpara>
</listitem>
<listitem>
<simpara>Implement a <literal>fromArgs</literal> helper that parses key-value command-line pairs into an overrides struct, reusing the layering function to apply them. <link xl:href="05__project-tempconv-cli.xml">05</link></simpara>
</listitem>
<listitem>
<simpara>Generate a Markdown table summarizing defaults by iterating over <literal>std.meta.fields(AppConfig)</literal> at comptime and writing rows to a buffered writer. <link xl:href="11__project-dynamic-string-builder.xml">11</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Alternatives &amp; Edge Cases</title>
<itemizedlist>
<listitem>
<simpara>For massive configs, stream JSON/YAML data into arena-backed structs instead of building everything on the stack to avoid exhausting temporary buffers (see <link xl:href="10__allocators-and-memory-management.xml">10</link>).</simpara>
</listitem>
<listitem>
<simpara>If you need dynamic keys, pair struct-based configs with <literal>std.StringHashMap</literal> lookups so you can keep typed defaults while still honoring user-provided extras (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/hash_map.zig">hash_map.zig</link>).</simpara>
</listitem>
<listitem>
<simpara>Consider <literal>std.io.Reader</literal> pipelines when validating files uploaded over the network; this lets you short-circuit before materializing the entire config (see <link xl:href="28__filesystem-and-io.xml">28</link>).</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>