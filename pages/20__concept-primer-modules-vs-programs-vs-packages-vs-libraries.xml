<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Concept Primer</title>
<subtitle>Modules vs Programs vs Packages vs Libraries</subtitle>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara><link xl:href="19__modules-and-imports-root-builtin-discovery.xml">Chapter 19</link> mapped the compiler’s module graph; this chapter names the roles those modules can play so you know when a file is merely a helper, when it graduates to a program, and when it becomes the nucleus of a reusable package or library.</simpara>
<simpara>We will also preview how the Zig CLI registers modules for consumers, setting the stage for build graph authoring in <link xl:href="21__zig-init-and-package-metadata.xml">Chapter 21</link> and in <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/build.zig">build.zig</link>.</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Distinguish modules, programs, packages, and libraries, and explain how Zig treats each during compilation.</simpara>
</listitem>
<listitem>
<simpara>Use the <literal>--dep</literal> and <literal>-M</literal> flags (and their build graph equivalents) to register named modules for consumers.</simpara>
</listitem>
<listitem>
<simpara>Apply a practical checklist for picking the right unit when starting a new artifact or refactoring an existing one. <link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="vocabulary">
<title>Building a shared vocabulary</title>
<simpara><emphasis role="strong">Before you wire build scripts or register dependencies, settle on consistent language:</emphasis> In Zig, a <emphasis role="strong">module</emphasis> is any compilation unit returned by <literal>@import</literal>, a <emphasis role="strong">program</emphasis> is a module graph with an entry point, a <emphasis role="strong">package</emphasis> bundles modules plus metadata, and a <emphasis role="strong">library</emphasis> is a package intended for reuse without a root <literal>main</literal>.
<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/start.zig">start.zig</link></simpara>
<section xml:id="modules-programs">
<title>Modules and programs in practice</title>
<simpara>This demo starts with a root module that exports a manifest for a library but also declares <literal>main</literal>, so the runtime treats the graph as a program while the helper module introspects public symbols to keep terminology honest. <link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc - include::example$chapters-data/code/20__concept-primer-modules-vs-programs-vs-packages-vs-libraries/module_role_map.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run module_role_map.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">== Module vocabulary demo ==
root exports main? yes → treat as program
root public surface: 3 declarations
library 'widgetlib' v0.1.0 exports main? no
library modules listed: 2
intent cheat sheet:
  - ship a CLI entry point → program
  - publish reusable code → package + library
  - share type definitions inside a workspace → module</programlisting>
</para>
</formalpara>
<tip>
<simpara>Keep root exports minimal and document them in one place (<literal>PublicSurface</literal> here) so helper modules can reason about intent without relying on undocumented globals.</simpara>
</tip>
</section>
<section xml:id="modules-programs-entrypoints">
<title>Under the hood: entry points and programs</title>
<simpara>Whether a module graph behaves as a program or a library depends on whether it ultimately exports an entry point symbol. <literal>std.start</literal> decides which symbol to export based on platform, link mode, and a few <literal>builtin</literal> fields, so the presence of <literal>main</literal> is only part of the story.</simpara>
<section xml:id="_entry_point_symbol_table">
<title>Entry point symbol table</title>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Platform</entry>
<entry align="left" valign="top">Link Mode</entry>
<entry align="left" valign="top">Conditions</entry>
<entry align="left" valign="top">Exported Symbol</entry>
<entry align="left" valign="top">Handler Function</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>POSIX/Linux</simpara></entry>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><literal>_start</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>_start()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>POSIX/Linux</simpara></entry>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara>Linking libc</simpara></entry>
<entry align="left" valign="top"><simpara><literal>main</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>main()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><literal>wWinMainCRTStartup</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>WinStartup()</literal> / <literal>wWinMainCRTStartup()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Windows</simpara></entry>
<entry align="left" valign="top"><simpara>Dynamic Library</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><literal>_DllMainCRTStartup</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>_DllMainCRTStartup()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>UEFI</simpara></entry>
<entry align="left" valign="top"><simpara>Executable</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><literal>EfiMain</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>EfiMain()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WASI</simpara></entry>
<entry align="left" valign="top"><simpara>Executable (command)</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><literal>_start</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>wasi_start()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WASI</simpara></entry>
<entry align="left" valign="top"><simpara>Executable (reactor)</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><literal>_initialize</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>wasi_start()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WebAssembly</simpara></entry>
<entry align="left" valign="top"><simpara>Freestanding</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><literal>_start</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>wasm_freestanding_start()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>WebAssembly</simpara></entry>
<entry align="left" valign="top"><simpara>Linking libc</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><literal>__main_argc_argv</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>mainWithoutEnv()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>OpenCL/Vulkan</simpara></entry>
<entry align="left" valign="top"><simpara>Kernel</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><literal>main</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>spirvMain2()</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>MIPS</simpara></entry>
<entry align="left" valign="top"><simpara>Any</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><literal>__start</literal></simpara></entry>
<entry align="left" valign="top"><simpara>(same as <literal>_start</literal>)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Sources:</emphasis> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/start.zig">start.zig</link></simpara>
</section>
<section xml:id="_compile_time_entry_point_logic">
<title>Compile-time entry point logic</title>
<simpara>At compile time, <literal>std.start</literal> runs a small decision tree over <literal>builtin.output_mode</literal>, <literal>builtin.os</literal>, <literal>link_libc</literal>, and the target architecture to export exactly one of the symbols above:</simpara>
<literallayout class="monospaced">graph TB
  Start["comptime block&lt;br/&gt;(start.zig:28)"]
  CheckMode["Check builtin.output_mode"]
  CheckSimplified["simplified_logic?&lt;br/&gt;(stage2 backends)"]

  CheckLinkC["link_libc or&lt;br/&gt;object_format == .c?"]
  CheckWindows["builtin.os == .windows?"]
  CheckUEFI["builtin.os == .uefi?"]
  CheckWASI["builtin.os == .wasi?"]
  CheckWasm["arch.isWasm() &amp;&amp;&lt;br/&gt;os == .freestanding?"]

  ExportMain["@export(&amp;main, 'main')"]
  ExportWinMain["@export(&amp;WinStartup,&lt;br/&gt;'wWinMainCRTStartup')"]
  ExportStart["@export(&amp;_start, '_start')"]
  ExportEfi["@export(&amp;EfiMain, 'EfiMain')"]
  ExportWasi["@export(&amp;wasi_start,&lt;br/&gt;wasm_start_sym)"]
  ExportWasmStart["@export(&amp;wasm_freestanding_start,&lt;br/&gt;'_start')"]

  Start --&gt; CheckMode
  CheckMode --&gt;|".Exe or has main"| CheckSimplified
  CheckSimplified --&gt;|"true"| Simple["Simplified logic&lt;br/&gt;(lines 33-51)"]
  CheckSimplified --&gt;|"false"| CheckLinkC

  CheckLinkC --&gt;|"yes"| ExportMain
  CheckLinkC --&gt;|"no"| CheckWindows
  CheckWindows --&gt;|"yes"| ExportWinMain
  CheckWindows --&gt;|"no"| CheckUEFI
  CheckUEFI --&gt;|"yes"| ExportEfi
  CheckUEFI --&gt;|"no"| CheckWASI
  CheckWASI --&gt;|"yes"| ExportWasi
  CheckWASI --&gt;|"no"| CheckWasm
  CheckWasm --&gt;|"yes"| ExportWasmStart
  CheckWasm --&gt;|"no"| ExportStart</literallayout>
<simpara><emphasis role="strong">Sources:</emphasis> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/start.zig">lib/std/start.zig:28-100</link></simpara>
</section>
</section>
<section xml:id="library-manifests">
<title>Library manifests and internal reuse</title>
<simpara>The manifest recorded in <literal>pkg/manifest.zig</literal> models what eventually becomes package metadata: a name, semantic version, a list of modules, and an explicit statement that no entry point is exported.</simpara>
</section>
</chapter>
<chapter xml:id="packages">
<title>Packages as distribution contracts</title>
<simpara>Packages are agreements between producers and consumers: producers register module names and expose metadata; consumers import those names without touching filesystem paths, trusting the build graph to supply the right code.</simpara>
<section xml:id="registering-modules">
<title>Registering modules with -M and --dep</title>
<simpara>Zig 0.15.2 replaces legacy <literal>--pkg-begin/--pkg-end</literal> syntax with <literal>-M</literal> (module definition) and <literal>--dep</literal> (import table entry), mirroring what <literal>std.build</literal> does when it wires workspaces (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build.zig">Build.zig</link>).</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc - include::example$chapters-data/code/20__concept-primer-modules-vs-programs-vs-packages-vs-libraries/package_overlay_demo.zig[]</programlisting>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc - include::example$chapters-data/code/20__concept-primer-modules-vs-programs-vs-packages-vs-libraries/overlay_widget.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe --dep overlay -Mroot=package_overlay_demo.zig -Moverlay=overlay_widget.zig -femit-bin=overlay_demo &amp;&amp; ./overlay_demo</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">registered package: overlay
role advertised: library package
optimize mode: Debug
target os: linux
resolved module namespace: overlay → pub decls: 2</programlisting>
</para>
</formalpara>
<important>
<simpara><literal>--dep overlay</literal> must precede the module declaration that consumes it; otherwise the import table stays empty and the compiler cannot resolve <literal>@import("overlay")</literal>.<footnote><simpara><literal>--dep</literal> writes the dependency list for the next <literal>-M</literal> entry, mirroring how <literal>std.build.Module.addImport</literal> queues dependencies before the module materializes.</simpara></footnote></simpara>
</important>
<section xml:id="_case_study_compiler_bootstrap_command">
<title>Case study: compiler bootstrap command</title>
<simpara>The Zig compiler itself is built using the same <literal>-M</literal>/<literal>--dep</literal> machinery. During the bootstrap from <literal>zig1</literal> to <literal>zig2</literal>, the command line wires multiple named modules and their dependencies:</simpara>
<screen>zig1 &lt;lib-dir&gt; build-exe -ofmt=c -lc -OReleaseSmall \
  --name zig2 \
  -femit-bin=zig2.c \
  -target &lt;host-triple&gt; \
  --dep build_options \
  --dep aro \
  -Mroot=src/main.zig \
  -Mbuild_options=config.zig \
  -Maro=lib/compiler/aro/aro.zig</screen>
<simpara>Here, each <literal>--dep</literal> line queues a dependency for the next <literal>-M</literal> module declaration, just like in the small overlay demo but at compiler scale.</simpara>
</section>
<section xml:id="_from_cli_flags_to_build_graph">
<title>From CLI flags to build graph</title>
<simpara>Once you move from ad-hoc <literal>zig build-exe</literal> commands to a <literal>build.zig</literal> file, the same concepts reappear as <literal>std.Build</literal> and <literal>std.Build.Module</literal> nodes in a build graph. The diagram below summarizes how the native build system&#8217;s entry point wires compiler compilation, tests, docs, and installation.</simpara>
<literallayout class="monospaced">graph TB
  subgraph "Build Entry Point"
    BUILD_FN["build(b: *std.Build)"] --&gt; OPTIONS["Parse Build Options"]
    OPTIONS --&gt; COMPILER["addCompilerStep()"]
    OPTIONS --&gt; TEST_SETUP["Test Suite Setup"]
    OPTIONS --&gt; DOCS["Documentation Steps"]
  end

  subgraph "Compiler Compilation"
    COMPILER --&gt; EXE["std.Build.CompileStep&lt;br/&gt;(zig executable)"]
    EXE --&gt; COMPILER_MOD["addCompilerMod()"]
    EXE --&gt; BUILD_OPTIONS["build_options&lt;br/&gt;(generated config)"]
    EXE --&gt; LLVM_INTEGRATION["LLVM/Clang/LLD&lt;br/&gt;linking"]
  end

  subgraph "Test Steps"
    TEST_SETUP --&gt; TEST_CASES["test-cases&lt;br/&gt;tests.addCases()"]
    TEST_SETUP --&gt; TEST_MODULES["test-modules&lt;br/&gt;tests.addModuleTests()"]
    TEST_SETUP --&gt; TEST_UNIT["test-unit&lt;br/&gt;compiler unit tests"]
    TEST_SETUP --&gt; TEST_STANDALONE["test-standalone"]
    TEST_SETUP --&gt; TEST_CLI["test-cli"]
  end

  subgraph "Documentation"
    DOCS --&gt; LANGREF_GEN["generateLangRef()&lt;br/&gt;(tools/docgen.zig)"]
    DOCS --&gt; STD_DOCS["autodoc_test&lt;br/&gt;(lib/std/std.zig)"]
  end

  subgraph "Installation"
    EXE --&gt; INSTALL_BIN["stage3/bin/zig"]
    INSTALL_LIB_DIR["lib/ directory"] --&gt; INSTALL_LIB_TARGET["stage3/lib/zig/"]
    LANGREF_GEN --&gt; INSTALL_LANGREF["stage3/doc/langref.html"]
    STD_DOCS --&gt; INSTALL_STD_DOCS["stage3/doc/std/"]
  end</literallayout>
</section>
</section>
<section xml:id="package-intent">
<title>Documenting package intent</title>
<simpara>Beyond the CLI flags, intent lives in documentation: describe which modules are public, whether you expect downstream entry points, and how the package should be consumed by other build graphs (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build/Module.zig">Module.zig</link>).</simpara>
</section>
</chapter>
<chapter xml:id="choosing-unit">
<title>Choosing the right unit fast</title>
<simpara>Use the cheat sheet below when deciding what to create next; it is intentionally opinionated so teams develop shared defaults. <link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="33.3333*"/>
<colspec colname="col_2" colwidth="33.3333*"/>
<colspec colname="col_3" colwidth="33.3334*"/>
<thead>
<row>
<entry align="left" valign="top">You want to…</entry>
<entry align="left" valign="top">Prefer</entry>
<entry align="left" valign="top">Rationale</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Publish reusable algorithms with no entry point</simpara></entry>
<entry align="left" valign="top"><simpara>Package + library</simpara></entry>
<entry align="left" valign="top"><simpara>Bundle modules with metadata so consumers can import by name and stay decoupled from paths.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Ship a command-line tool</simpara></entry>
<entry align="left" valign="top"><simpara>Program</simpara></entry>
<entry align="left" valign="top"><simpara>Export a <literal>main</literal> (or <literal>_start</literal>) and keep helper modules private unless you intend to share them.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Share types across files inside one repo</simpara></entry>
<entry align="left" valign="top"><simpara>Module</simpara></entry>
<entry align="left" valign="top"><simpara>Use plain <literal>@import</literal> to expose namespaces without coupling build metadata prematurely. <link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<section xml:id="_artifact_types_at_a_glance">
<title>Artifact types at a glance</title>
<simpara>The compiler&#8217;s <literal>output_mode</literal> and <literal>link_mode</literal> choices determine the concrete artifact form that backs each conceptual role. Programs usually build as executables, while libraries use <literal>Lib</literal> outputs that can be static or dynamic.</simpara>
<literallayout class="monospaced">graph LR
  subgraph "Output Mode + Link Mode = Artifact Type"
    Exe_static["output_mode: Exe&lt;br/&gt;link_mode: static"] --&gt; ExeStatic["Static executable"]
    Exe_dynamic["output_mode: Exe&lt;br/&gt;link_mode: dynamic"] --&gt; ExeDynamic["Dynamic executable"]

    Lib_static["output_mode: Lib&lt;br/&gt;link_mode: static"] --&gt; LibStatic["Static library (.a)"]
    Lib_dynamic["output_mode: Lib&lt;br/&gt;link_mode: dynamic"] --&gt; LibDynamic["Shared library (.so/.dll)"]

    Obj["output_mode: Obj&lt;br/&gt;link_mode: N/A"] --&gt; ObjFile["Object file (.o)"]
  end</literallayout>
<simpara><emphasis role="strong">Sources:</emphasis> <link xl:href="https://github.com/ziglang/zig/tree/master/src/Compilation/Config.zig">Config.zig</link>, <link xl:href="https://github.com/ziglang/zig/tree/master/src/main.zig">main.zig</link>, <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/builtin.zig">builtin.zig</link></simpara>
<simpara>You can combine the vocabulary from this chapter with these artifact types using a simple mapping:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="3">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="50*"/>
<thead>
<row>
<entry align="left" valign="top">Role</entry>
<entry align="left" valign="top">Typical artifact</entry>
<entry align="left" valign="top">Notes</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Program</simpara></entry>
<entry align="left" valign="top"><simpara><literal>output_mode: Exe</literal> (static or dynamic)</simpara></entry>
<entry align="left" valign="top"><simpara>Exposes an entry point; may also export helper modules internally.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Library package</simpara></entry>
<entry align="left" valign="top"><simpara><literal>output_mode: Lib</literal> (static or shared)</simpara></entry>
<entry align="left" valign="top"><simpara>Intended for reuse; no root <literal>main</literal>, consumers import modules by name.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>Internal module</simpara></entry>
<entry align="left" valign="top"><simpara>Depends on context</simpara></entry>
<entry align="left" valign="top"><simpara>Often compiled as part of an executable or library; exposed via <literal>@import</literal> rather than a standalone artifact.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>Record manifest-like data even in ad-hoc modules so later promotion to a package is mechanical.</simpara>
</listitem>
<listitem>
<simpara>When you convert a program into a library, delete or guard the entry point; otherwise consumers get conflicting roots. <link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara>
</listitem>
<listitem>
<simpara>The <literal>-M</literal>/<literal>--dep</literal> workflow is a thin veneer over <literal>std.build.Module</literal>, so prefer the build graph once your project exceeds a single binary. <link xl:href="21__zig-init-and-package-metadata.xml">21</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Extend <literal>module_role_map.zig</literal> so the cheat sheet is driven by data loaded from a JSON manifest, then compare the ergonomics with direct Zig structs. <link xl:href="12__config-as-data.xml">12</link>, <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/json.zig">json.zig</link></simpara>
</listitem>
<listitem>
<simpara>Modify the overlay demo to register two external modules and emit their declaration counts, reinforcing how <literal>--dep</literal> queues multiple imports.</simpara>
</listitem>
<listitem>
<simpara>Draft a <literal>zig build</literal> script that wraps the overlay example, verifying that the CLI flags map cleanly to <literal>b.addModule</literal> and <literal>module.addImport</literal>. <link xl:href="21__zig-init-and-package-metadata.xml">21</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Caveats, alternatives, edge cases</title>
<itemizedlist>
<listitem>
<simpara>Cross-compiling packages may expose <literal>target</literal>-specific modules; document conditional imports to prevent surprise name resolution failures.</simpara>
</listitem>
<listitem>
<simpara>If you register a module name twice in the same build graph, the zig CLI reports a collision—treat that as a signal to refactor rather than relying on ordering. <link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara>
</listitem>
<listitem>
<simpara>Some tooling still expects the deprecated <literal>--pkg-begin</literal> syntax; upgrade scripts in tandem with the compiler to keep dependency registration consistent. <link xl:href="https://ziglang.org/download/0.15.1/release-notes.html">v0.15.2</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>