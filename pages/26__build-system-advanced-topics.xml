<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Build System Advanced Topics</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Module resolution gave us the vocabulary for reasoning about the compiler&#8217;s graph. Now we turn that vocabulary into infrastructure. This chapter digs into <literal>std.Build</literal> beyond the basics, exploring artifact tours and library/executable workspaces. We will register modules intentionally, compose multi-package workspaces, generate build outputs without touching shell scripts, and drive cross-target matrices from a single <literal>build.zig</literal>. See <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build.zig">Build.zig</link>.</simpara>
<simpara>You will learn how named write-files, anonymous modules, and <literal>resolveTargetQuery</literal> feed the build runner, how to keep vendored code isolated from registry dependencies, and how to wire CI jobs that prove your graph behaves in Debug and Release builds alike. See <link xl:href="https://github.com/ziglang/zig/blob/master/lib/compiler/build_runner.zig">build_runner.zig</link>.</simpara>
<section xml:id="_how_the_build_system_executes">
<title>How the Build System Executes</title>
<simpara>Before diving into advanced patterns, it&#8217;s essential to understand how <literal>std.Build</literal> executes. The following diagram shows the complete flow from the Zig compiler invoking your <literal>build.zig</literal> script through to final artifact installation:</simpara>
<literallayout class="monospaced">graph TB
    subgraph "CMake Stage (stage2)"
        CMAKE["CMake"]
        ZIG2_C["zig2.c&lt;br/&gt;(generated C code)"]
        ZIGCPP["zigcpp&lt;br/&gt;(C++ LLVM/Clang wrapper)"]
        ZIG2["zig2 executable"]

        CMAKE --&gt; ZIG2_C
        CMAKE --&gt; ZIGCPP
        ZIG2_C --&gt; ZIG2
        ZIGCPP --&gt; ZIG2
    end

    subgraph "Native Build System (stage3)"
        BUILD_ZIG["build.zig&lt;br/&gt;Native Build Script"]
        BUILD_FN["build() function"]
        COMPILER_STEP["addCompilerStep()"]
        EXE["std.Build.Step.Compile&lt;br/&gt;(compiler executable)"]
        INSTALL["Installation Steps"]

        BUILD_ZIG --&gt; BUILD_FN
        BUILD_FN --&gt; COMPILER_STEP
        COMPILER_STEP --&gt; EXE
        EXE --&gt; INSTALL
    end

    subgraph "Build Arguments"
        ZIG_BUILD_ARGS["ZIG_BUILD_ARGS&lt;br/&gt;--zig-lib-dir&lt;br/&gt;-Dversion-string&lt;br/&gt;-Dtarget&lt;br/&gt;-Denable-llvm&lt;br/&gt;-Doptimize"]
    end

    ZIG2 --&gt;|"zig2 build"| BUILD_ZIG
    ZIG_BUILD_ARGS --&gt; BUILD_FN

    subgraph "Output"
        STAGE3_BIN["stage3/bin/zig"]
        STD_LIB["stage3/lib/zig/std/"]
        LANGREF["stage3/doc/langref.html"]
    end

    INSTALL --&gt; STAGE3_BIN
    INSTALL --&gt; STD_LIB
    INSTALL --&gt; LANGREF</literallayout>
<simpara>Your <literal>build.zig</literal> is a regular Zig program compiled and executed by the compiler. The <literal>build()</literal> function is the entry point, receiving a <literal>*std.Build</literal> instance that provides the API for defining steps, artifacts, and dependencies. Build arguments (<literal>-D</literal> flags) are parsed by <literal>b.option()</literal> and flow into your build logic as compile-time constants. The build runner then traverses the step dependency graph you&#8217;ve declared, executing only the steps needed to satisfy the requested target (defaulting to the install step). This declarative model ensures reproducibility: the same inputs always produce the same build graph.</simpara>
</section>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Register reusable modules and anonymous packages explicitly, controlling which names appear in the import namespace. <link xl:href="25__module-resolution-and-discovery-deep.xml">25</link></simpara>
</listitem>
<listitem>
<simpara>Generate deterministic artifacts (reports, manifests) from the build graph using named write-files instead of ad-hoc shell scripting.</simpara>
</listitem>
<listitem>
<simpara>Coordinate multi-target builds with <literal>resolveTargetQuery</literal>, including host sanity checks and cross-compilation pipelines. <link xl:href="22__build-system-deep-dive.xml">22</link>, <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build/Step/Compile.zig">Compile.zig</link></simpara>
</listitem>
<listitem>
<simpara>Structure composite workspaces so vendored modules remain private while registry packages stay self-contained. <link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</listitem>
<listitem>
<simpara>Capture reproducibility guarantees in CI: install steps, run steps, and generated artifacts all hang off <literal>std.Build.Step</literal> dependencies.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="workspace-surface">
<title>Building a Workspace Surface</title>
<simpara>A workspace is just a build graph with clear namespace boundaries. The following example promotes three modules—<literal>analytics</literal>, <literal>reporting</literal>, and a vendored <literal>adapters</literal> helper—and shows how a root executable consumes them. We emphasize which modules are globally registered, which remain anonymous, and how to emit documentation straight from the build graph.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 26__build-system-advanced-topics.adoc - include::example$chapters-data/code/26__build-system-advanced-topics/01_workspace_build.zig[]</programlisting>
<simpara>The <literal>build()</literal> function follows a deliberate cadence:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>b.addModule("analytics", …)</literal> registers a public name so the entire workspace can <literal>@import("analytics")</literal>. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build/Module.zig">Module.zig</link></simpara>
</listitem>
<listitem>
<simpara><literal>b.createModule</literal> creates a private module (<literal>adapters</literal>) that only the root executable sees—ideal for vendored code that consumers should not reach. <link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</listitem>
<listitem>
<simpara><literal>b.addNamedWriteFiles("workspace-graph")</literal> produces a <literal>module-graph.txt</literal> file in <literal>zig-out/</literal>, documenting the namespace mapping without bespoke tooling.</simpara>
</listitem>
<listitem>
<simpara>Every dependency is threaded through <literal>.imports</literal>, so the compiler never falls back to filesystem guessing. <link xl:href="25__module-resolution-and-discovery-deep.xml">25</link></simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Run workspace app</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build --build-file 01_workspace_build.zig run</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">metric: response_ms
count: 6
mean: 12.95
deviation: 1.82
profile: stable
json export: {
  "name": "response_ms",
  "mean": 12.950,
  "deviation": 1.819,
  "profile": "stable"
}</programlisting>
</para>
</formalpara>
<formalpara>
<title>Generate module graph</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build --build-file 01_workspace_build.zig graph</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">No stdout expected.</programlisting>
</para>
</formalpara>
<note>
<simpara>Named write-files obey the cache: rerunning <literal>zig build … graph</literal> without changes is instant. Check <literal>zig-out/graph/module-graph.txt</literal> to see the mapping emitted by the build runner.</simpara>
</note>
<section xml:id="workspace-library-code">
<title>Library code for the workspace</title>
<simpara>To keep this example self-contained, the modules live next to the build script. Feel free to adapt them to your needs or swap in registry dependencies declared in <literal>build.zig.zon</literal>.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 26__build-system-advanced-topics.adoc - include::example$chapters-data/code/26__build-system-advanced-topics/workspace/analytics/lib.zig[]</programlisting>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 26__build-system-advanced-topics.adoc - include::example$chapters-data/code/26__build-system-advanced-topics/workspace/reporting/lib.zig[]</programlisting>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 26__build-system-advanced-topics.adoc - include::example$chapters-data/code/26__build-system-advanced-topics/workspace/adapters/vendored.zig[]</programlisting>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 26__build-system-advanced-topics.adoc - include::example$chapters-data/code/26__build-system-advanced-topics/workspace/app/main.zig[]</programlisting>
<tip>
<simpara><literal>std.fmt.allocPrint</literal> pairs well with allocator plumbing when you want build-time helpers to operate without heap globals. Prefer it over ad-hoc <literal>ArrayList</literal> usage when emitting CSV or JSON snapshots in Zig 0.15.2. See <link xl:href="https://ziglang.org/download/0.15.1/release-notes.html#upgrading-stdiogetstdoutwriterprint">v0.15.2</link> and <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig">fmt.zig</link>.</simpara>
</tip>
</section>
<section xml:id="dependency-hygiene">
<title>Dependency hygiene checklist</title>
<itemizedlist>
<listitem>
<simpara>Register vendored modules with distinct names and share them only via <literal>.imports</literal>. Do <emphasis role="strong">not</emphasis> leak them through <literal>b.addModule</literal> unless consumers are expected to import them directly.</simpara>
</listitem>
<listitem>
<simpara>Treat <literal>zig-out/workspace-graph/module-graph.txt</literal> as living documentation. Commit outputs for CI verification or diff them to catch accidental namespace changes.</simpara>
</listitem>
<listitem>
<simpara>For registry dependencies, forward <literal>b.dependency()</literal> handles exactly once and wrap them in local modules. This keeps upgrade churn isolated. <link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_build_options_as_configuration">
<title>Build Options as Configuration</title>
<simpara>Build options provide a powerful mechanism for making your workspace configurable. The following diagram shows how command-line <literal>-D</literal> flags flow through <literal>b.option()</literal>, get added to a generated module via <literal>b.addOptions()</literal>, and become compile-time constants accessible via <literal>@import("build_options")</literal>:</simpara>
<literallayout class="monospaced">graph LR
    subgraph "Command Line"
        CLI["-Ddebug-allocator&lt;br/&gt;-Denable-llvm&lt;br/&gt;-Dversion-string&lt;br/&gt;etc."]
    end

    subgraph "build.zig"
        PARSE["b.option()&lt;br/&gt;Parse options"]
        OPTIONS["exe_options =&lt;br/&gt;b.addOptions()"]
        ADD["exe_options.addOption()"]

        PARSE --&gt; OPTIONS
        OPTIONS --&gt; ADD
    end

    subgraph "Generated Module"
        BUILD_OPTIONS["build_options&lt;br/&gt;(auto-generated)"]
        CONSTANTS["pub const mem_leak_frames = 4;&lt;br/&gt;pub const have_llvm = true;&lt;br/&gt;pub const version = '0.16.0';&lt;br/&gt;etc."]

        BUILD_OPTIONS --&gt; CONSTANTS
    end

    subgraph "Compiler Source"
        IMPORT["@import('build_options')"]
        USE["if (build_options.have_llvm) { ... }"]

        IMPORT --&gt; USE
    end

    CLI --&gt; PARSE
    ADD --&gt; BUILD_OPTIONS
    BUILD_OPTIONS --&gt; IMPORT</literallayout>
<simpara>This pattern is essential for parameterized workspaces. Use <literal>b.option(bool, "feature-x", "Enable feature X")</literal> to declare options, then call <literal>options.addOption("feature_x", feature_x)</literal> to make them available at compile time. The generated module is automatically rebuilt when options change, ensuring your binaries always reflect the current configuration. This technique works for version strings, feature flags, debug settings, and any other build-time constant your code needs.</simpara>
</section>
</chapter>
<chapter xml:id="target-matrix">
<title>Target Matrices and Release Channels</title>
<simpara>Complex projects often ship multiple binaries: debug utilities for contributors, ReleaseFast builds for production, and WASI artifacts for automation. Rather than duplicating build logic per target, assemble a matrix that iterates over <literal>std.Target.Query</literal> definitions.</simpara>
<section xml:id="_understanding_target_resolution">
<title>Understanding Target Resolution</title>
<simpara>Before iterating over targets, it&#8217;s important to understand how <literal>b.resolveTargetQuery</literal> transforms partial specifications into fully-resolved targets. The following diagram shows the resolution process:</simpara>
<literallayout class="monospaced">graph LR
    subgraph "User Input"
        Query["Target.Query"]
        Query --&gt; QCpu["cpu_arch: ?Cpu.Arch"]
        Query --&gt; QModel["cpu_model: CpuModel"]
        Query --&gt; QOs["os_tag: ?Os.Tag"]
        Query --&gt; QAbi["abi: ?Abi"]
    end

    subgraph "Resolution Process"
        Resolve["resolveTargetQuery()"]
        Query --&gt; Resolve
        Detection["Native Detection"]
        Defaults["Apply Defaults"]
        Detection --&gt; Resolve
        Defaults --&gt; Resolve
    end

    subgraph "Fully Resolved"
        Target["Target"]
        Resolve --&gt; Target
        Target --&gt; TCpu["cpu: Cpu"]
        Target --&gt; TOs["os: Os"]
        Target --&gt; TAbi["abi: Abi"]
        Target --&gt; TOfmt["ofmt: ObjectFormat"]
    end</literallayout>
<simpara>When you pass a <literal>Target.Query</literal> with <literal>null</literal> CPU or OS fields, the resolver detects your native platform and fills in concrete values. Similarly, if you specify an OS without an ABI, the resolver applies the default ABI for that OS (e.g., <literal>.gnu</literal> for Linux, <literal>.msvc</literal> for Windows). This resolution happens once per query and produces a <literal>ResolvedTarget</literal> containing the fully-specified <literal>Target</literal> plus metadata about whether values came from native detection. Understanding this distinction is crucial for cross-compilation: a query with <literal>.cpu_arch = .x86_64</literal> and <literal>.os_tag = .linux</literal> yields a different resolved target on each host platform due to CPU model and feature detection.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 26__build-system-advanced-topics.adoc - include::example$chapters-data/code/26__build-system-advanced-topics/02_multi_target_matrix.zig[]</programlisting>
<simpara>Key techniques:</simpara>
<itemizedlist>
<listitem>
<simpara>Predeclare a slice of <literal>{ name, query, optimize }</literal> combos. Queries match <literal>zig build -Dtarget</literal> semantics but stay type-checked.</simpara>
</listitem>
<listitem>
<simpara><literal>b.resolveTargetQuery</literal> converts each query into a <literal>ResolvedTarget</literal> so the module inherits canonical CPU/OS defaults.</simpara>
</listitem>
<listitem>
<simpara>Aggregating everything under a <literal>matrix</literal> step keeps CI wiring clean: call <literal>zig build -Drelease-mode=fast matrix</literal> (or leave defaults) and let dependencies ensure artefacts exist.</simpara>
</listitem>
<listitem>
<simpara>Running the first (host) target as part of the matrix catches regressions without cross-runner emulation. For deeper coverage, enable <literal>b.enable_qemu</literal> / <literal>b.enable_wasmtime</literal> before calling <literal>addRunArtifact</literal>.</simpara>
</listitem>
</itemizedlist>
<formalpara>
<title>Run matrix build</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build --build-file 02_multi_target_matrix.zig matrix</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output (host variant)</title>
<para>
<screen>target: x86_64-linux-gnu
optimize: Debug</screen>
</para>
</formalpara>
</section>
<section xml:id="_running_cross_compiled_targets">
<title>Running Cross-Compiled Targets</title>
<simpara>When your matrix includes cross-compilation targets, you&#8217;ll need external executors to actually run the binaries. The build system automatically selects the appropriate executor based on host/target compatibility:</simpara>
<literallayout class="monospaced">flowchart TD
    Start["getExternalExecutor(host, candidate)"]

    CheckMatch{"OS + CPU\ncompatible?"}
    CheckDL{"link_libc &amp;&amp;\nhas dynamic_linker?"}
    DLExists{"Dynamic linker\nexists on host?"}

    Native["Executor.native"]

    CheckRosetta{"macOS + arm64 host\n&amp;&amp; x86_64 target?"}
    Rosetta["Executor.rosetta"]

    CheckQEMU{"OS matches &amp;&amp;\nallow_qemu?"}
    QEMU["Executor.qemu\n(e.g., 'qemu-aarch64')"]

    CheckWasmtime{"target.isWasm() &amp;&amp;\nallow_wasmtime?"}
    Wasmtime["Executor.wasmtime"]

    CheckWine{"target.os == .windows\n&amp;&amp; allow_wine?"}
    Wine["Executor.wine"]

    CheckDarling{"target.os.isDarwin()\n&amp;&amp; allow_darling?"}
    Darling["Executor.darling"]

    BadDL["Executor.bad_dl"]
    BadOsCpu["Executor.bad_os_or_cpu"]

    Start --&gt; CheckMatch
    CheckMatch --&gt; |Yes|CheckDL
    CheckMatch --&gt; |No|CheckRosetta

    CheckDL --&gt; |No libc|Native
    CheckDL --&gt; |Has libc|DLExists
    DLExists --&gt; |Yes|Native
    DLExists --&gt; |No|BadDL

    CheckRosetta --&gt; |Yes|Rosetta
    CheckRosetta --&gt; |No|CheckQEMU

    CheckQEMU --&gt; |Yes|QEMU
    CheckQEMU --&gt; |No|CheckWasmtime

    CheckWasmtime --&gt; |Yes|Wasmtime
    CheckWasmtime --&gt; |No|CheckWine

    CheckWine --&gt; |Yes|Wine
    CheckWine --&gt; |No|CheckDarling

    CheckDarling --&gt; |Yes|Darling
    CheckDarling --&gt; |No|BadOsCpu</literallayout>
<simpara>Enable emulators in your build script by setting <literal>b.enable_qemu = true</literal> or <literal>b.enable_wasmtime = true</literal> before calling <literal>addRunArtifact</literal>. On macOS ARM hosts, x86_64 targets automatically use Rosetta 2. For Linux cross-architecture testing, QEMU user-mode emulation runs ARM/RISC-V/MIPS binaries transparently when the OS matches. WASI targets require Wasmtime, while Windows binaries on Linux can use Wine. If no executor is available, the run step will fail with <literal>Executor.bad_os_or_cpu</literal>—detect this early by testing matrix coverage on representative CI hosts.</simpara>
<caution>
<simpara>Cross targets that rely on native system libraries (e.g. glibc) need appropriate sysroot packs. Populate <literal>ZIG_LIBC</literal> or configure <literal>b.libc_file</literal> before adding those combos to production pipelines.</simpara>
</caution>
</section>
</chapter>
<chapter xml:id="vendoring-vs-registry">
<title>Vendoring vs Registry Dependencies</title>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Registry-first approach</emphasis>: keep <literal>build.zig.zon</literal> hashes authoritative, then register each dependency module via <literal>b.dependency()</literal> and <literal>module.addImport()</literal>. <link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Vendor-first approach</emphasis>: drop sources into <literal>deps/&lt;name&gt;/</literal> and wire them with <literal>b.addAnonymousModule</literal> or <literal>b.createModule</literal>. Document the provenance in <literal>module-graph.txt</literal> so collaborators know which code is pinned locally.</simpara>
</listitem>
<listitem>
<simpara>Whichever strategy you choose, record a policy in CI: a step that fails if <literal>zig out/workspace-graph/module-graph.txt</literal> changes unexpectedly, or a lint that checks vendored directories for LICENSE files.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="ci-scenarios">
<title>CI Scenarios and Automation Hooks</title>
<section xml:id="_step_dependencies_in_practice">
<title>Step Dependencies in Practice</title>
<simpara>CI pipelines benefit from understanding how build steps compose. The following diagram shows a real-world step dependency graph from the Zig compiler&#8217;s own build system:</simpara>
<literallayout class="monospaced">graph TB
    subgraph "Installation Step (default)"
        INSTALL["b.getInstallStep()"]
    end

    subgraph "Compiler Artifacts"
        EXE_STEP["exe.step&lt;br/&gt;(compile compiler)"]
        INSTALL_EXE["install_exe.step&lt;br/&gt;(install binary)"]
    end

    subgraph "Documentation"
        LANGREF["generateLangRef()"]
        INSTALL_LANGREF["install_langref.step"]
        STD_DOCS_GEN["autodoc_test"]
        INSTALL_STD_DOCS["install_std_docs.step"]
    end

    subgraph "Library Files"
        LIB_FILES["installDirectory(lib/)"]
    end

    subgraph "Test Steps"
        TEST["test step"]
        FMT["test-fmt step"]
        CASES["test-cases step"]
        MODULES["test-modules step"]
    end

    INSTALL --&gt; INSTALL_EXE
    INSTALL --&gt; INSTALL_LANGREF
    INSTALL --&gt; LIB_FILES

    INSTALL_EXE --&gt; EXE_STEP
    INSTALL_LANGREF --&gt; LANGREF
    INSTALL --&gt; INSTALL_STD_DOCS
    INSTALL_STD_DOCS --&gt; STD_DOCS_GEN

    TEST --&gt; EXE_STEP
    TEST --&gt; FMT
    TEST --&gt; CASES
    TEST --&gt; MODULES

    CASES --&gt; EXE_STEP
    MODULES --&gt; EXE_STEP</literallayout>
<simpara>Notice how the default install step (<literal>zig build</literal>) depends on binary installation, documentation, and library files—but <emphasis role="strong">not</emphasis> tests. Meanwhile, the test step depends on compilation plus all test substeps. This separation lets CI run <literal>zig build</literal> for release artifacts and <literal>zig build test</literal> for validation in parallel jobs. Each step only executes when its dependencies change, thanks to content-addressed caching. You can inspect this graph locally with <literal>zig build --verbose</literal> or by adding a custom step that dumps dependencies.</simpara>
</section>
<section xml:id="_automation_patterns">
<title>Automation Patterns</title>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Artifact verification</emphasis>: Add a <literal>zig build graph</literal> job that uploads <literal>module-graph.txt</literal> alongside compiled binaries. Consumers can diff namespaces between releases.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Matrix extension</emphasis>: Parameterize the combos array via build options (<literal>-Dinclude-windows=true</literal>). Use <literal>b.option(bool, "include-windows", …)</literal> to let CI toggle extra targets without editing source.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Security posture</emphasis>: Pipe <literal>zig build --fetch</literal> (Chapter 24) into the matrix run so caches populate before cross jobs run offline. See <link xl:href="24__zig-package-manager-deep.xml">24</link>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Reproducibility</emphasis>: Teach CI to run <literal>zig build install</literal> twice and assert no files change between runs. Because <literal>std.Build</literal> respects content hashing, the second invocation should no-op unless inputs changed.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="_advanced_test_organization">
<title>Advanced Test Organization</title>
<simpara>For comprehensive projects, organizing tests into categories with matrix application requires careful step composition. The following diagram shows a production-grade test hierarchy:</simpara>
<literallayout class="monospaced">graph TB
    subgraph "Test Steps"
        TEST_STEP["test step&lt;br/&gt;(umbrella step)"]
        FMT["test-fmt&lt;br/&gt;Format checking"]
        CASES["test-cases&lt;br/&gt;Compiler test cases"]
        MODULES["test-modules&lt;br/&gt;Per-target module tests"]
        UNIT["test-unit&lt;br/&gt;Compiler unit tests"]
        STANDALONE["Standalone tests"]
        CLI["CLI tests"]
        STACK_TRACE["Stack trace tests"]
        ERROR_TRACE["Error trace tests"]
        LINK["Link tests"]
        C_ABI["C ABI tests"]
        INCREMENTAL["test-incremental&lt;br/&gt;Incremental compilation"]
    end

    subgraph "Module Tests"
        BEHAVIOR["behavior tests&lt;br/&gt;test/behavior.zig"]
        COMPILER_RT["compiler_rt tests&lt;br/&gt;lib/compiler_rt.zig"]
        ZIGC["zigc tests&lt;br/&gt;lib/c.zig"]
        STD["std tests&lt;br/&gt;lib/std/std.zig"]
        LIBC_TESTS["libc tests"]
    end

    subgraph "Test Configuration"
        TARGET_MATRIX["test_targets array&lt;br/&gt;Different architectures&lt;br/&gt;Different OSes&lt;br/&gt;Different ABIs"]
        OPT_MODES["Optimization modes:&lt;br/&gt;Debug, ReleaseFast&lt;br/&gt;ReleaseSafe, ReleaseSmall"]
        FILTERS["test-filter&lt;br/&gt;test-target-filter"]
    end

    TEST_STEP --&gt; FMT
    TEST_STEP --&gt; CASES
    TEST_STEP --&gt; MODULES
    TEST_STEP --&gt; UNIT
    TEST_STEP --&gt; STANDALONE
    TEST_STEP --&gt; CLI
    TEST_STEP --&gt; STACK_TRACE
    TEST_STEP --&gt; ERROR_TRACE
    TEST_STEP --&gt; LINK
    TEST_STEP --&gt; C_ABI
    TEST_STEP --&gt; INCREMENTAL

    MODULES --&gt; BEHAVIOR
    MODULES --&gt; COMPILER_RT
    MODULES --&gt; ZIGC
    MODULES --&gt; STD

    TARGET_MATRIX --&gt; MODULES
    OPT_MODES --&gt; MODULES
    FILTERS --&gt; MODULES</literallayout>
<simpara>The umbrella test step aggregates all test categories, letting you run the full suite with <literal>zig build test</literal>. Individual categories can be invoked separately (<literal>zig build test-fmt</literal>, <literal>zig build test-modules</literal>) for faster iteration. Notice how only the module tests receive matrix configuration—format checking and CLI tests don&#8217;t vary by target. Use <literal>b.option([]const u8, "test-filter", …)</literal> to let CI run subsets, and apply optimization modes selectively based on test type. This pattern scales to hundreds of test files while keeping build times manageable through parallel execution and caching.</simpara>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara><literal>b.addModule</literal> registers a name globally for the current build graph; <literal>b.createModule</literal> keeps the module private. Mixing them up leads to surprising imports or missing symbols. <link xl:href="25__module-resolution-and-discovery-deep.xml">25</link></simpara>
</listitem>
<listitem>
<simpara>Named write-files respect the cache. Delete <literal>.zig-cache</literal> if you need to regenerate them from scratch; otherwise the step can trick you into thinking a change landed when it actually hit the cache.</simpara>
</listitem>
<listitem>
<simpara>When iterating matrices, always prune stale binaries with <literal>zig build uninstall</literal> (or a custom <literal>Step.RemoveDir</literal>) to avoid cross-version confusion.</simpara>
</listitem>
</itemizedlist>
<section xml:id="_under_the_hood_dependency_tracking">
<title>Under the Hood: Dependency Tracking</title>
<simpara>The build system&#8217;s caching and incremental behavior relies on the compiler&#8217;s sophisticated dependency tracking infrastructure. Understanding this helps explain why cached builds are so fast and why certain changes trigger broader rebuilds than expected.</simpara>
<literallayout class="monospaced">graph TB
    subgraph "InternPool - Dependency Storage"
        SRCHASHDEPS["src_hash_deps&lt;br/&gt;Map: TrackedInst.Index → DepEntry.Index"]
        NAVVALDEPS["nav_val_deps&lt;br/&gt;Map: Nav.Index → DepEntry.Index"]
        NAVTYDEPS["nav_ty_deps&lt;br/&gt;Map: Nav.Index → DepEntry.Index"]
        INTERNEDDEPS["interned_deps&lt;br/&gt;Map: Index → DepEntry.Index"]
        ZONFILEDEPS["zon_file_deps&lt;br/&gt;Map: FileIndex → DepEntry.Index"]
        EMBEDFILEDEPS["embed_file_deps&lt;br/&gt;Map: EmbedFile.Index → DepEntry.Index"]
        NSDEPS["namespace_deps&lt;br/&gt;Map: TrackedInst.Index → DepEntry.Index"]
        NSNAMEDEPS["namespace_name_deps&lt;br/&gt;Map: NamespaceNameKey → DepEntry.Index"]

        FIRSTDEP["first_dependency&lt;br/&gt;Map: AnalUnit → DepEntry.Index"]
        DEPENTRIES["dep_entries&lt;br/&gt;ArrayListUnmanaged&lt;DepEntry&gt;"]
        FREEDEP["free_dep_entries&lt;br/&gt;ArrayListUnmanaged&lt;DepEntry.Index&gt;"]
    end

    subgraph "DepEntry Structure"
        DEPENTRY["DepEntry&lt;br/&gt;{depender: AnalUnit,&lt;br/&gt;next_dependee: DepEntry.Index.Optional,&lt;br/&gt;next_depender: DepEntry.Index.Optional}"]
    end

    SRCHASHDEPS --&gt; DEPENTRIES
    NAVVALDEPS --&gt; DEPENTRIES
    NAVTYDEPS --&gt; DEPENTRIES
    INTERNEDDEPS --&gt; DEPENTRIES
    ZONFILEDEPS --&gt; DEPENTRIES
    EMBEDFILEDEPS --&gt; DEPENTRIES
    NSDEPS --&gt; DEPENTRIES
    NSNAMEDEPS --&gt; DEPENTRIES
    FIRSTDEP --&gt; DEPENTRIES

    DEPENTRIES --&gt; DEPENTRY
    FREEDEP -.-&gt;|"reuses indices from"| DEPENTRIES</literallayout>
<simpara>The compiler tracks dependencies at multiple granularities: source file hashes (<literal>src_hash_deps</literal>), navigation values (<literal>nav_val_deps</literal>), types (<literal>nav_ty_deps</literal>), interned constants, ZON files, embedded files, and namespace membership. All these maps point into a shared <literal>dep_entries</literal> array containing <literal>DepEntry</literal> structures that form linked lists. Each entry participates in two lists: one linking all analysis units that depend on a particular dependee (traversed during invalidation), and one linking all dependees of a particular analysis unit (traversed during cleanup). When you modify a source file, the compiler hashes it, looks up dependents in <literal>src_hash_deps</literal>, and marks only those analysis units as outdated. This granular tracking is why changing a private function in one file doesn&#8217;t rebuild unrelated modules—the dependency graph precisely captures what actually depends on what. The build system leverages this infrastructure through content addressing: step outputs are cached by their input hashes, and reused when inputs haven&#8217;t changed.</simpara>
</section>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Extend <literal>01_workspace_build.zig</literal> so the <literal>graph</literal> step emits both a human-readable table and a JSON document. Hint: call <literal>graph_files.add("module-graph.json", …)</literal> with <literal>std.json</literal> output. See <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/json.zig">json.zig</link>.</simpara>
</listitem>
<listitem>
<simpara>Add a <literal>-Dtarget-filter</literal> option to <literal>02_multi_target_matrix.zig</literal> that limits matrix execution to a comma-separated allowlist. Use <literal>std.mem.splitScalar</literal> to parse the value. <link xl:href="22__build-system-deep-dive.xml">22</link></simpara>
</listitem>
<listitem>
<simpara>Introduce a registry dependency via <literal>b.dependency("logging", .{})</literal> and expose it to the workspace with <literal>module.addImport("logging", dep.module("logging"))</literal>. Document the new namespace in <literal>module-graph.txt</literal>.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Caveats, alternatives, edge cases</title>
<itemizedlist>
<listitem>
<simpara>Large workspaces might exceed default install directory limits. Use <literal>b.setInstallPrefix</literal> or <literal>b.setLibDir</literal> before adding artifacts to route outputs into per-target directories.</simpara>
</listitem>
<listitem>
<simpara>On Windows, <literal>resolveTargetQuery</literal> requires <literal>abi = .msvc</literal> if you expect MSVC-compatible artifacts; the default <literal>.gnu</literal> ABI yields MinGW binaries.</simpara>
</listitem>
<listitem>
<simpara>If you supply anonymous modules to dependencies, remember they are not deduplicated. Reuse the same <literal>b.createModule</literal> instance when multiple artefacts need the same vendored code.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="summary">
<title>Summary</title>
<itemizedlist>
<listitem>
<simpara>Workspaces stay predictable when you register every module explicitly and document the mapping via named write-files.</simpara>
</listitem>
<listitem>
<simpara><literal>resolveTargetQuery</literal> and iteration-friendly combos let you scale to multiple targets without copy/pasting build logic.</simpara>
</listitem>
<listitem>
<simpara>CI jobs benefit from <literal>std.Build</literal> primitives: steps articulate dependencies, run artefacts gate sanity checks, and named artefacts capture reproducible metadata.</simpara>
</listitem>
</itemizedlist>
<simpara>Together with Chapters 22–25, you now have the tools to craft deterministic Zig build graphs that scale across packages, targets, and release channels.</simpara>
</chapter>
</book>