<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Zig Init &amp; Package Metadata</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Chapter 20 settled the vocabulary distinguishing modules from programs, packages, and libraries; this chapter shows how <literal>zig init</literal> bootstraps that vocabulary into actual files, and how <literal>build.zig.zon</literal> codifies package identity, version constraints, and dependency metadata so the build system and package manager can resolve imports reliably. See <link xl:href="20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.xml">20</link> and <link xl:href="https://ziglang.org/download/0.15.1/release-notes.html">v0.15.2</link>.</simpara>
<simpara>We focus on package metadata structure before diving into build graph authoring in Chapter 22, ensuring you understand what each field in <literal>build.zig.zon</literal> controls and why Zig&#8217;s fingerprint mechanism replaced earlier UUID-based schemes. See <link xl:href="22__build-system-deep-dive.xml">22</link>, <link xl:href="https://github.com/ziglang/zig/blob/master/lib/init/build.zig.zon">build.zig.zon</link>, and <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build.zig">Build.zig</link>.</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Use <literal>zig init</literal> and <literal>zig init --minimal</literal> to scaffold new projects with appropriate boilerplate for modules, executables, and tests.</simpara>
</listitem>
<listitem>
<simpara>Interpret every field in <literal>build.zig.zon</literal>: name, version, fingerprint, minimum Zig version, dependencies, and paths.</simpara>
</listitem>
<listitem>
<simpara>Distinguish remote dependencies (URL + hash), local dependencies (path), and lazy dependencies (deferred fetch).</simpara>
</listitem>
<listitem>
<simpara>Explain why fingerprints provide globally unique package identity and how they prevent hostile fork confusion.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="zig-init-basics">
<title>Scaffolding projects with <literal>zig init</literal></title>
<simpara>Zig 0.15.2 updated the default <literal>zig init</literal> template to encourage splitting reusable modules from executable entry points, addressing a common newcomer confusion where library code was unnecessarily compiled as static archives instead of being exposed as pure Zig modules. See <link xl:href="https://github.com/ziglang/zig/blob/master/lib/init/build.zig">build.zig</link>.</simpara>
<section xml:id="default-template">
<title>Default Template: Module + Executable</title>
<simpara>Running <literal>zig init</literal> in an empty directory generates four files demonstrating the recommended pattern for projects that want both a reusable module and a CLI tool:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ mkdir myproject &amp;&amp; cd myproject
$ zig init
info: created build.zig
info: created build.zig.zon
info: created src/main.zig
info: created src/root.zig
info: see `zig build --help` for a menu of options</programlisting>
<simpara>The generated structure separates concerns:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>src/root.zig</literal>: Reusable module exposing public API (e.g., <literal>bufferedPrint</literal>, <literal>add</literal>)</simpara>
</listitem>
<listitem>
<simpara><literal>src/main.zig</literal>: Executable entry point importing and using the module</simpara>
</listitem>
<listitem>
<simpara><literal>build.zig</literal>: Build graph wiring both the module and executable artifacts</simpara>
</listitem>
<listitem>
<simpara><literal>build.zig.zon</literal>: Package metadata including name, version, and fingerprint</simpara>
</listitem>
</itemizedlist>
<simpara>This layout makes it trivial for external packages to depend on your module without inheriting unnecessary executable code, while still providing a convenient CLI for local development or distribution. <link xl:href="20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.xml">20</link></simpara>
<tip>
<simpara>If you only need a module or only need an executable, delete the files you don&#8217;t need and simplify <literal>build.zig</literal> accordingly—the template is a starting point, not a mandate.</simpara>
</tip>
</section>
<section xml:id="minimal-template">
<title>Minimal Template: Stub for Experienced Users</title>
<simpara>For users who know the build system and want minimal boilerplate, <literal>zig init --minimal</literal> generates only <literal>build.zig.zon</literal> and a stub <literal>build.zig</literal>:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ mkdir minimal-project &amp;&amp; cd minimal-project
$ zig init --minimal
info: successfully populated 'build.zig.zon' and 'build.zig'</programlisting>
<simpara>The resulting <literal>build.zig.zon</literal> is compact:</simpara>
<programlisting language="zig" linenumbering="unnumbered">.{
    .name = .minimal_project,
    .version = "0.0.1",
    .minimum_zig_version = "0.15.2",
    .paths = .{""},
    .fingerprint = 0x52714d1b5f619765,
}</programlisting>
<simpara>The stub <literal>build.zig</literal> is equally terse:</simpara>
<programlisting language="zig" linenumbering="unnumbered">const std = @import("std");

pub fn build(b: *std.Build) void {
    _ = b; // stub
}</programlisting>
<simpara>This mode is intended for cases where you have a clear build strategy in mind and want to avoid deleting boilerplate comments and example code.</simpara>
</section>
</chapter>
<chapter xml:id="build-zig-zon-anatomy">
<title>Anatomy of <literal>build.zig.zon</literal></title>
<simpara>Zig Object Notation (ZON) is a strict subset of Zig syntax used for data literals; <literal>build.zig.zon</literal> is the canonical file the build runner parses to resolve package metadata before invoking your <literal>build.zig</literal> script. See <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/zon.zig">zon.zig</link> and <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/zig/Zoir.zig">Zoir.zig</link>.</simpara>
<section xml:id="zon-parse-modes">
<title>How ZON files are parsed</title>
<simpara>From the parser&#8217;s point of view, <literal>.zon</literal> manifests are just another mode of <literal>Ast.parse()</literal>. The tokenizer is shared between <literal>.zig</literal> and <literal>.zon</literal> files, but <literal>.zig</literal> is parsed as a container of declarations while <literal>.zon</literal> is parsed as a single expression—exactly what <literal>build.zig.zon</literal> contains.</simpara>
<literallayout class="monospaced">graph TD
  START["Ast.parse()"] --&gt; TOKENIZE["Tokenize source"]
  TOKENIZE --&gt; MODE{Mode?}

  MODE --&gt;|".zig"| PARSEROOT["Parse.parseRoot()"]
  MODE --&gt;|".zon"| PARSEZON["Parse.parseZon()"]

  PARSEROOT --&gt; CONTAINERMEMBERS["parseContainerMembers()"]
  CONTAINERMEMBERS --&gt; ROOTAST["Root AST&lt;br/&gt;(container decls)"]

  PARSEZON --&gt; EXPR["expectExpr()"]
  EXPR --&gt; EXPRAST["Root AST&lt;br/&gt;(single expression)"]

  ROOTAST --&gt; ASTRETURN["Return Ast struct"]
  EXPRAST --&gt; ASTRETURN</literallayout>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Zig mode</emphasis> (<literal>.zig</literal> files): Parses a full source file as a container with declarations</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">ZON mode</emphasis> (<literal>.zon</literal> files): Parses a single expression (Zig Object Notation)</simpara>
</listitem>
</itemizedlist>
<simpara>Sources: <link xl:href="">lib/std/zig/Parse.zig:192-205</link>, <link xl:href="">lib/std/zig/Parse.zig:208-228</link></simpara>
</section>
<section xml:id="zon-required-fields">
<title>Required Fields</title>
<simpara>Every <literal>build.zig.zon</literal> must define these core fields:</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 21__zig-init-and-package-metadata.adoc - include::example$chapters-data/code/21__zig-init-and-package-metadata/minimal_zon.zon[]</programlisting>
<itemizedlist>
<listitem>
<simpara><literal>.name</literal>: A symbol literal (e.g., <literal>.myproject</literal>) used as the default dependency key; conventionally lowercase, omitting redundant "zig" prefixes since the package already lives in the Zig namespace.</simpara>
</listitem>
<listitem>
<simpara><literal>.version</literal>: A semantic version string (<literal>"MAJOR.MINOR.PATCH"</literal>) that the package manager will eventually use for deduplication. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/SemanticVersion.zig">SemanticVersion.zig</link></simpara>
</listitem>
<listitem>
<simpara><literal>.minimum_zig_version</literal>: The earliest Zig release that this package supports; older compilers will refuse to build it.</simpara>
</listitem>
<listitem>
<simpara><literal>.paths</literal>: An array of file/directory paths (relative to the build root) included in the package&#8217;s content hash; only these files are distributed and cached.</simpara>
</listitem>
<listitem>
<simpara><literal>.fingerprint</literal>: A 64-bit hexadecimal integer serving as the package&#8217;s globally unique identifier, generated once by the toolchain and never changed (except in hostile fork scenarios).</simpara>
</listitem>
</itemizedlist>
<simpara>The following demo shows how these fields map to runtime introspection patterns (though in practice the build runner handles this automatically):</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 21__zig-init-and-package-metadata.adoc - include::example$chapters-data/code/21__zig-init-and-package-metadata/zon_field_demo.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run zon_field_demo.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">=== build.zig.zon Field Demo ===
Sample ZON structure:
.{
    .name = .demo,
    .version = "0.1.0",
    .minimum_zig_version = "0.15.2",
    .fingerprint = 0x1234567890abcdef,
    .paths = .{"build.zig", "src"},
    .dependencies = .{},
}

Field explanations:
  .name: Package identifier (symbol literal)
  .version: Semantic version string
  .minimum_zig_version: Minimum supported Zig
  .fingerprint: Unique package ID (hex integer)
  .paths: Files included in package distribution
  .dependencies: External packages required

Note: Zig 0.15.2 uses .fingerprint for unique identity
      (Previously used UUID-style identifiers)</programlisting>
</para>
</formalpara>
<note>
<simpara>Zig 0.15.2 replaced the old UUID-style <literal>.id</literal> field with the more compact <literal>.fingerprint</literal> field, simplifying generation and comparison while maintaining global uniqueness guarantees.<footnote><simpara>See Zig 0.15.2 release notes, section "Zig Init".</simpara></footnote></simpara>
</note>
</section>
<section xml:id="fingerprint-identity">
<title>Fingerprint: Global Identity and Fork Detection</title>
<simpara>The <literal>.fingerprint</literal> field is the linchpin of package identity: it is generated once when you first run <literal>zig init</literal>, and should never change for the lifetime of the package unless you are deliberately forking it into a new identity.</simpara>
<simpara>Changing the fingerprint of an actively maintained upstream project is considered a <emphasis role="strong">hostile fork</emphasis>—an attempt to hijack the package&#8217;s identity and redirect users to different code. Legitimate forks (where the upstream is abandoned) should regenerate the fingerprint to establish a new identity, while maintaining forks (backports, security patches) preserve the original fingerprint to signal continuity.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 21__zig-init-and-package-metadata.adoc - include::example$chapters-data/code/21__zig-init-and-package-metadata/fingerprint_demo.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run fingerprint_demo.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">=== Package Identity Validation ===

Package: mylib
Version: 1.0.0
Fingerprint: 0xabcdef1234567890

Version format valid: true

Fingerprint ensures:
  - Globally unique package identity
  - Unambiguous version detection
  - Fork detection (hostile vs. legitimate)

WARNING: Changing fingerprint of a maintained project
         is considered a hostile fork attempt!</programlisting>
</para>
</formalpara>
<important>
<simpara>The inline comment <literal>// Changing this has security and trust implications.</literal> in the generated <literal>.zon</literal> file is deliberately preserved to surface during code review if someone modifies the fingerprint without understanding the consequences.</simpara>
</important>
</section>
<section xml:id="dependencies-field">
<title>Dependencies: Remote, Local, and Lazy</title>
<simpara>The <literal>.dependencies</literal> field is a struct literal mapping dependency names to fetch specifications; each entry is either a remote URL dependency, a local filesystem path dependency, or a lazily-fetched optional dependency.</simpara>
<section xml:id="annotated-dependencies">
<title>Annotated Dependency Examples</title>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 21__zig-init-and-package-metadata.adoc - include::example$chapters-data/code/21__zig-init-and-package-metadata/annotated_zon.zon[]</programlisting>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Remote dependencies</emphasis> specify <literal>.url</literal> (a tarball/zip archive location) and <literal>.hash</literal> (a multihash-format content hash). The hash is the source of truth: even if the URL changes or mirrors are added, the package identity remains tied to the hash.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Local dependencies</emphasis> specify <literal>.path</literal> (a relative directory from the build root). No hash is computed because the filesystem is the authority; this is useful for monorepo layouts or during development before publishing.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Lazy dependencies</emphasis> add <literal>.lazy = true</literal> to defer fetching until the dependency is actually imported by a build script. This reduces bandwidth for optional features or platform-specific code paths.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="dependency-types-demo">
<title>Dependency Types in Practice</title>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 21__zig-init-and-package-metadata.adoc - include::example$chapters-data/code/21__zig-init-and-package-metadata/dependency_types.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run dependency_types.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">=== Dependency Types Comparison ===

Dependency 1: remote_package
  Type: remote
  Lazy: false
  URL: https://example.com/pkg.tar.gz
  Hash: 122012345678...
  (Fetched from network, cached locally)

Dependency 2: local_package
  Type: local
  Lazy: false
  Path: ../local-lib
  (No hash needed, relative to build root)

Dependency 3: lazy_optional
  Type: remote
  Lazy: true
  URL: https://example.com/opt.tar.gz
  Hash: 1220abcdef...
  (Fetched from network, cached locally)

Key differences:
  - Remote: Uses hash as source of truth
  - Local: Direct filesystem path
  - Lazy: Only fetched when actually imported</programlisting>
</para>
</formalpara>
<tip>
<simpara>Use local paths during active development across multiple packages in the same workspace, then switch to remote URLs with hashes when publishing for external consumers. <link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</tip>
<simpara>Chapter 24 revisits these concepts in depth by walking through a package resolution pipeline that starts from <literal>build.zig.zon</literal>. <link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</section>
</section>
<section xml:id="paths-field">
<title>Paths: Controlling Package Distribution</title>
<simpara>The <literal>.paths</literal> field specifies which files and directories are included when computing the package hash and distributing the package; everything not listed is excluded from the cached artifact.</simpara>
<simpara>Typical patterns:</simpara>
<programlisting language="zig" linenumbering="unnumbered">.paths = .{
    "build.zig",        // Build script is always needed
    "build.zig.zon",    // Metadata file itself
    "src",              // Source code directory (recursive)
    "LICENSE",          // Legal requirement
    "README.md",        // Documentation
}</programlisting>
<simpara>Listing a directory includes all files within it recursively; listing the empty string <literal>""</literal> includes the build root itself (equivalent to listing every file individually, which is rarely desired).</simpara>
<important>
<simpara>Exclude generated artifacts (<literal>zig-cache/</literal>, <literal>zig-out/</literal>), large assets not needed for compilation, and internal development tools from <literal>.paths</literal> to keep package downloads small and deterministic.</simpara>
</important>
</section>
<section xml:id="_under_the_hood_zon_files_in_dependency_tracking">
<title>Under the hood: ZON files in dependency tracking</title>
<simpara>The compiler&#8217;s incremental dependency tracker treats ZON files as a distinct <emphasis role="strong">dependee</emphasis> category alongside source hashes, embedded files, and declaration-based dependencies. The core storage is an <literal>InternPool</literal> that owns multiple maps into a shared <literal>dep_entries</literal> array:</simpara>
<literallayout class="monospaced">graph TB
    subgraph "InternPool - Dependency Storage"
      SRCHASHDEPS["src_hash_deps&lt;br/&gt;Map: TrackedInst.Index → DepEntry.Index"]
      NAVVALDEPS["nav_val_deps&lt;br/&gt;Map: Nav.Index → DepEntry.Index"]
      NAVTYDEPS["nav_ty_deps&lt;br/&gt;Map: Nav.Index → DepEntry.Index"]
      INTERNEDDEPS["interned_deps&lt;br/&gt;Map: Index → DepEntry.Index"]
      ZONFILEDEPS["zon_file_deps&lt;br/&gt;Map: FileIndex → DepEntry.Index"]
      EMBEDFILEDEPS["embed_file_deps&lt;br/&gt;Map: EmbedFile.Index → DepEntry.Index"]
      NSDEPS["namespace_deps&lt;br/&gt;Map: TrackedInst.Index → DepEntry.Index"]
      NSNAMEDEPS["namespace_name_deps&lt;br/&gt;Map: NamespaceNameKey → DepEntry.Index"]

        FIRSTDEP["first_dependency&lt;br/&gt;Map: AnalUnit â†’ DepEntry.Index"]
        DEPENTRIES["dep_entries&lt;br/&gt;ArrayListUnmanaged&lt;DepEntry&gt;"]
        FREEDEP["free_dep_entries&lt;br/&gt;ArrayListUnmanaged&lt;DepEntry.Index&gt;"]
    end

    subgraph "DepEntry Structure"
        DEPENTRY["DepEntry&lt;br/&gt;{depender: AnalUnit,&lt;br/&gt;next_dependee: DepEntry.Index.Optional,&lt;br/&gt;next_depender: DepEntry.Index.Optional}"]
    end

    SRCHASHDEPS --&gt; DEPENTRIES
    NAVVALDEPS --&gt; DEPENTRIES
    NAVTYDEPS --&gt; DEPENTRIES
    INTERNEDDEPS --&gt; DEPENTRIES
    ZONFILEDEPS --&gt; DEPENTRIES
    EMBEDFILEDEPS --&gt; DEPENTRIES
    NSDEPS --&gt; DEPENTRIES
    NSNAMEDEPS --&gt; DEPENTRIES
    FIRSTDEP --&gt; DEPENTRIES

    DEPENTRIES --&gt; DEPENTRY
    FREEDEP -.-&gt;|"reuses indices from"| DEPENTRIES</literallayout>
<simpara>The dependency tracking system uses multiple hash maps to look up dependencies by different <emphasis role="strong">dependee</emphasis> types. All maps point into a shared <literal>dep_entries</literal> array, which stores the actual <literal>DepEntry</literal> structures forming linked lists of dependencies.</simpara>
<simpara>Sources: <link xl:href="">src/InternPool.zig:34-85</link></simpara>
<literallayout class="monospaced">graph LR
    subgraph "Source-Level Dependencies"
        SRCHASH["Source Hash&lt;br/&gt;TrackedInst.Index&lt;br/&gt;src_hash_deps"]
        ZONFILE["ZON File&lt;br/&gt;FileIndex&lt;br/&gt;zon_file_deps"]
        EMBEDFILE["Embedded File&lt;br/&gt;EmbedFile.Index&lt;br/&gt;embed_file_deps"]
    end

    subgraph "Nav Dependencies"
        NAVVAL["Nav Value&lt;br/&gt;Nav.Index&lt;br/&gt;nav_val_deps"]
        NAVTY["Nav Type&lt;br/&gt;Nav.Index&lt;br/&gt;nav_ty_deps"]
    end

    subgraph "Type/Value Dependencies"
        INTERNED["Interned Value&lt;br/&gt;Index&lt;br/&gt;interned_deps&lt;br/&gt;runtime funcs, container types"]
    end

    subgraph "Namespace Dependencies"
        NSFULL["Full Namespace&lt;br/&gt;TrackedInst.Index&lt;br/&gt;namespace_deps"]
        NSNAME["Namespace Name&lt;br/&gt;NamespaceNameKey&lt;br/&gt;namespace_name_deps"]
    end

    subgraph "Memoized State"
        MEMO["Memoized Fields&lt;br/&gt;panic_messages, etc."]
    end</literallayout>
<simpara>Each category tracks a different kind of dependee:</simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Dependee Type</entry>
<entry align="left" valign="top">Map Name</entry>
<entry align="left" valign="top">Key Type</entry>
<entry align="left" valign="top">When Invalidated</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Source Hash</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>src_hash_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TrackedInst.Index</literal></simpara></entry>
<entry align="left" valign="top"><simpara>ZIR instruction body changes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Nav Value</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>nav_val_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Nav.Index</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Declaration value changes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Nav Type</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>nav_ty_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Nav.Index</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Declaration type changes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Interned Value</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>interned_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>Index</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Function IES changes, container type recreated</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">ZON File</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>zon_file_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>FileIndex</literal></simpara></entry>
<entry align="left" valign="top"><simpara>ZON file imported via <literal>@import</literal> changes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Embedded File</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>embed_file_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>EmbedFile.Index</literal></simpara></entry>
<entry align="left" valign="top"><simpara>File content accessed via <literal>@embedFile</literal> changes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Full Namespace</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>namespace_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>TrackedInst.Index</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Any name added/removed in namespace</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Namespace Name</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>namespace_name_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>NamespaceNameKey</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Specific name existence changes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Memoized State</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><literal>memoized_state_*_deps</literal></simpara></entry>
<entry align="left" valign="top"><simpara>N/A (single entry)</simpara></entry>
<entry align="left" valign="top"><simpara>Compiler state fields change</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Sources: <link xl:href="">src/InternPool.zig:34-71</link></simpara>
</section>
<section xml:id="minimum-zig-version">
<title>Minimum Zig Version: Compatibility Bounds</title>
<simpara>The <literal>.minimum_zig_version</literal> field declares the earliest Zig release that the package can build with; older compilers will refuse to proceed, preventing silent miscompilations due to missing features or changed semantics.</simpara>
<simpara>When the language stabilizes at 1.0.0, this field will interact with semantic versioning to provide compatibility guarantees; before 1.0.0, it serves as a forward-looking compatibility declaration even though breaking changes happen every release.</simpara>
</section>
<section xml:id="version-field">
<title>Version: Semantic Versioning for Deduplication</title>
<simpara>The <literal>.version</literal> field currently documents the package&#8217;s semantic version but does not yet enforce compatibility ranges or automatic deduplication; that functionality is planned for post-1.0.0 when the language stabilizes.</simpara>
<simpara>Follow semantic versioning conventions:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">MAJOR</emphasis>: Increment for incompatible API changes</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">MINOR</emphasis>: Increment for backward-compatible feature additions</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">PATCH</emphasis>: Increment for backward-compatible bug fixes</simpara>
</listitem>
</itemizedlist>
<simpara>This discipline will pay off once the package manager can auto-resolve compatible versions within dependency trees. <link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</section>
</chapter>
<chapter xml:id="zig-init-workflow">
<title>Practical Workflow: From Init to First Build</title>
<simpara>A typical project initialization sequence looks like this:</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ mkdir mylib &amp;&amp; cd mylib
$ zig init
info: created build.zig
info: created build.zig.zon
info: created src/main.zig
info: created src/root.zig

$ zig build
$ zig build test
All 3 tests passed.

$ zig build run
All your codebase are belong to us.
Run `zig build test` to run the tests.</programlisting>
<simpara>At this point, you have:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>A reusable module (<literal>src/root.zig</literal>) exposing <literal>bufferedPrint</literal> and <literal>add</literal></simpara>
</listitem>
<listitem>
<simpara>An executable (<literal>src/main.zig</literal>) importing and using the module</simpara>
</listitem>
<listitem>
<simpara>Tests for both the module and executable</simpara>
</listitem>
<listitem>
<simpara>Package metadata (<literal>build.zig.zon</literal>) ready for publishing</simpara>
</listitem>
</orderedlist>
<simpara>To share your module with other packages, you would publish the repository with a tagged release, document the URL and hash, and consumers would add it to their <literal>.dependencies</literal> table.</simpara>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>The fingerprint is generated from a random seed; regenerating <literal>build.zig.zon</literal> will produce a different fingerprint unless you preserve the original.</simpara>
</listitem>
<listitem>
<simpara>Changing <literal>.name</literal> does not change the fingerprint; the name is a convenience alias while the fingerprint is the identity.</simpara>
</listitem>
<listitem>
<simpara>Local path dependencies bypass the hash-based content addressing entirely; they are trusted based on filesystem state at build time.</simpara>
</listitem>
<listitem>
<simpara>The package manager caches fetched dependencies in a global cache directory; subsequent builds with the same hash skip re-downloading.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Run <literal>zig init</literal> in a new directory, then modify <literal>build.zig.zon</literal> to add a fake remote dependency with a placeholder hash; observe the error when running <literal>zig build --fetch</literal>.</simpara>
</listitem>
<listitem>
<simpara>Create two packages in sibling directories, configure one as a local path dependency of the other, and verify that changes in the dependency are immediately visible without re-fetching.</simpara>
</listitem>
<listitem>
<simpara>Generate a <literal>build.zig.zon</literal> with <literal>zig init --minimal</literal>, then manually add a <literal>.dependencies</literal> table and compare the resulting structure with the annotated example in this chapter.</simpara>
</listitem>
<listitem>
<simpara>Fork a hypothetical package by regenerating the fingerprint (delete the field and run <literal>zig build</literal>), then document in a README why this is a new identity rather than a hostile takeover.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Caveats, alternatives, edge cases</title>
<itemizedlist>
<listitem>
<simpara>If you omit <literal>.paths</literal>, the package manager may include unintended files in the distribution, inflating download size and exposing internal implementation details.</simpara>
</listitem>
<listitem>
<simpara>Remote dependency URLs can become stale if the host moves or removes the archive; consider mirroring critical dependencies or using content-addressed storage systems. <link xl:href="24__zig-package-manager-deep.xml">24</link></simpara>
</listitem>
<listitem>
<simpara>The <literal>zig fetch --save &lt;url&gt;</literal> command automates adding a remote dependency to <literal>.dependencies</literal> by downloading, hashing, and inserting the correct entry—use it instead of hand-typing hashes.</simpara>
</listitem>
<listitem>
<simpara>Lazy dependencies require build script cooperation: if your <literal>build.zig</literal> unconditionally references a lazy dependency without checking availability, the build will fail with a "dependency not available" error.</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>