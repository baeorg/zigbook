<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Project</title>
<subtitle>Hexdump</subtitle>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>This project turns raw bytes into a tidy, alignment-aware hex view. We’ll read a file incrementally, format each line as <literal>OFFSET: HEX  ASCII</literal>, and keep output stable across platforms. The writer interface uses buffered stdout via <literal>std.fs.File.writer</literal> and <literal>std.Io.Writer</literal>, as described in <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fs/File.zig">File.zig</link> and <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Io.zig">Io.zig</link>.</simpara>
<simpara>The formatter prints 16 bytes per line by default and can be configured with <literal>--width N</literal> (4..32). Bytes are grouped <literal>8|8</literal> to ease scanning, and non-printable ASCII becomes a dot in the right-hand gutter, as described in <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig">fmt.zig</link> and <link xl:href="https://ziglang.org/documentation/master/#Command-line-flags">#Command-line-flags</link>.</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Parse CLI flags and validate numbers with <literal>std.fmt.parseInt</literal>.</simpara>
</listitem>
<listitem>
<simpara>Stream a file with a fixed buffer and assemble exact-width output lines.</simpara>
</listitem>
<listitem>
<simpara>Use the non-deprecated <literal>File.Writer</literal> + <literal>Io.Writer</literal> to buffer stdout and flush cleanly.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="building">
<title>Building the Dump</title>
<simpara>We’ll wire three pieces: a tiny CLI parser, a line formatter, and a loop that feeds the formatter in exact-width chunks. The implementation leans on Zig’s slices and explicit lifetimes (dup the path before freeing args) to stay robust; see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/process.zig">process.zig</link> and <link xl:href="https://ziglang.org/documentation/master/#Error-Handling">#Error-Handling</link>.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 09__project-hexdump.adoc - include::example$chapters-data/code/09__project-hexdump/hexdump.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run hexdump.zig -- sample.txt</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">00000000: 48 65 6C 6C 6F 2C 20 48  65 78 64 75 6D 70 21 0A   Hello, Hexdump!.</programlisting>
</para>
</formalpara>
<note>
<simpara>The ASCII gutter replaces non-printable bytes with <literal>.</literal>; the newline at the end of the file shows up as <literal>0A</literal> and a dot on the right.</simpara>
</note>
</chapter>
<chapter xml:id="width">
<title>Width and Grouping</title>
<simpara>Pass <literal>--width N</literal> to change bytes per line. Grouping still splits the line in half (<literal>N/2</literal>) to keep the eye anchored.</simpara>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run hexdump.zig -- --width 8 sample.txt</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">00000000: 48 65 6C 6C  6F 2C 20 48   Hello, H
00000008: 65 78 64 75  6D 70 21 0A   exdump!.</programlisting>
</para>
</formalpara>
<tip>
<simpara>The line formatter pads both the hex and ASCII regions so that the columns align nicely on the last line, where bytes may not fill a complete width.</simpara>
</tip>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>Avoid deprecated I/O surfaces; this example uses <literal>File.writer</literal> plus an <literal>Io.Writer</literal> buffer and calls <literal>end()</literal> to flush and set the final position.</simpara>
</listitem>
<listitem>
<simpara>Hex formatting is kept simple—no <literal>-C</literal>-style index columns beyond the offset. Extending the formatter is an easy follow-on exercise.</simpara>
</listitem>
<listitem>
<simpara>Argument lifetimes matter: duplicate the path string if you free <literal>args</literal> before using <literal>cli.path</literal>.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Add <literal>--group N</literal> to control the extra space position (currently <literal>N = width/2</literal>).</simpara>
</listitem>
<listitem>
<simpara>Support <literal>--offset 0xNN</literal> to start addresses at a base other than zero.</simpara>
</listitem>
<listitem>
<simpara>Include a right-hand hex checksum per line and a final footer (e.g., total bytes).</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Alternatives &amp; Edge Cases</title>
<itemizedlist>
<listitem>
<simpara>Large files: the code streams in fixed-size blocks and assembles lines; adjust buffer sizes to match your I/O environment.</simpara>
</listitem>
<listitem>
<simpara>Non-ASCII encodings: the ASCII gutter is deliberately crude. For UTF-8 awareness, you’d need a more careful renderer; see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/unicode.zig">unicode.zig</link>.</simpara>
</listitem>
<listitem>
<simpara>Binary pipes: read from <literal>stdin</literal> when no path is provided; adapt the open/loop accordingly if you want to support pipelines.</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>