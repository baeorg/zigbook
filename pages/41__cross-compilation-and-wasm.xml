<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Cross-Compilation &amp; WASM</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Having tightened our feedback loop with profiling and safeguards, <link xl:href="40__profiling-optimization-hardening.xml">40</link> we are ready to ship those binaries to other platforms. This chapter walks through target discovery, native cross-compilation, and the essentials for emitting WASI modules, using the same CLI instrumentation we relied on earlier. <link xl:href="ZIG_DEEP_WIKI.md#entry-points-and-command-structure">#entry points and command structure</link></simpara>
<simpara>The very next chapter turns these mechanics into a full WASI project, so treat this as your hands-on preflight. <link xl:href="42__project-wasi-build-and-run.xml">42</link></simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Interpret target triples and query Zig&#8217;s built-in metadata for alternate architectures. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Target/Query.zig">Query.zig</link></simpara>
</listitem>
<listitem>
<simpara>Cross-compile native executables with <literal>zig build-exe</literal> and verify artifacts without leaving Linux.</simpara>
</listitem>
<listitem>
<simpara>Produce WASI binaries that share the same source as native code, ready for the project build pipeline. <link xl:href="https://ziglang.org/documentation/master/#Command-line-flags">#Command-line-flags</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="target-discovery">
<title>Mapping Target Triples</title>
<simpara>Zig&#8217;s <literal>@import("builtin")</literal> exposes the compiler&#8217;s current idea of the world, while <literal>std.Target.Query.parse</literal> lets you inspect hypothetical targets without building them. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Target.zig">Target.zig</link></simpara>
<simpara>This is the foundation for tailoring build graphs or ENT files before you touch <literal>zig build</literal>.</simpara>
<section xml:id="_understanding_the_target_structure">
<title>Understanding the Target Structure</title>
<simpara>Before parsing target triples, it&#8217;s valuable to understand how Zig represents compilation targets internally. The following diagram shows the complete <literal>std.Target</literal> structure:</simpara>
<literallayout class="monospaced">graph TB
    subgraph "std.Target Structure"
        TARGET["std.Target"]
        CPU["cpu: Cpu"]
        OS["os: Os"]
        ABI["abi: Abi"]
        OFMT["ofmt: ObjectFormat"]
        DYNLINKER["dynamic_linker: DynamicLinker"]

        TARGET --&gt; CPU
        TARGET --&gt; OS
        TARGET --&gt; ABI
        TARGET --&gt; OFMT
        TARGET --&gt; DYNLINKER
    end

    subgraph "Cpu Components"
        CPU --&gt; ARCH["arch: Cpu.Arch"]
        CPU --&gt; MODEL["model: *const Cpu.Model"]
        CPU --&gt; FEATURES["features: Feature.Set"]

        ARCH --&gt; ARCHEX["x86_64, aarch64, wasm32, etc"]
        MODEL --&gt; MODELEX["generic, native, specific variants"]
        FEATURES --&gt; FEATEX["CPU feature flags"]
    end

    subgraph "Os Components"
        OS --&gt; OSTAG["tag: Os.Tag"]
        OS --&gt; VERSION["version_range: VersionRange"]

        OSTAG --&gt; OSEX["linux, windows, macos, wasi, etc"]
        VERSION --&gt; VERUNION["linux: LinuxVersionRange&lt;br/&gt;windows: WindowsVersion.Range&lt;br/&gt;semver: SemanticVersion.Range&lt;br/&gt;none: void"]
    end

    subgraph "Abi and Format"
        ABI --&gt; ABIEX["gnu, musl, msvc, none, etc"]
        OFMT --&gt; OFMTEX["elf, macho, coff, wasm, c, spirv"]
    end</literallayout>
<simpara>This structure reveals how target triples map to concrete configuration. When you specify <literal>-target wasm32-wasi</literal>, you&#8217;re setting CPU architecture to <literal>wasm32</literal>, OS tag to <literal>wasi</literal>, and implicitly ObjectFormat to <literal>wasm</literal>. The triple <literal>x86_64-windows-gnu</literal> maps to arch <literal>x86_64</literal>, OS <literal>windows</literal>, ABI <literal>gnu</literal>, and format <literal>coff</literal> (Windows PE).</simpara>
<simpara>Each component affects code generation: the CPU arch determines instruction sets and calling conventions, the OS tag selects system call interfaces and runtime expectations, the ABI specifies calling conventions and name mangling, and the ObjectFormat chooses the linker (ELF for Linux, Mach-O for Darwin, COFF for Windows, WASM for web/WASI). Understanding this mapping helps you decode <literal>std.Target.Query.parse</literal> results, predict cross-compilation behavior, and troubleshoot target-specific issues. The CPU features field captures architecture-specific capabilities (AVX on x86_64, SIMD on ARM) that the optimizer uses for code generation.</simpara>
</section>
<section xml:id="_target_resolution_flow">
<title>Target Resolution Flow</title>
<simpara>Target queries (user input) get resolved into concrete targets through a systematic process:</simpara>
<literallayout class="monospaced">graph TB
    subgraph "Resolution Flow"
        QUERY["std.Target.Query&lt;br/&gt;user input with defaults"]
        RESOLVE["resolveTargetQuery()"]
        TARGET["std.Target&lt;br/&gt;fully resolved"]

        QUERY --&gt; RESOLVE
        RESOLVE --&gt; TARGET
    end

    subgraph "Query Sources"
        CMDLINE["-target flag&lt;br/&gt;command line"]
        DEFAULT["native detection&lt;br/&gt;std.zig.system"]
        MODULE["Module.resolved_target"]

        CMDLINE --&gt; QUERY
        DEFAULT --&gt; QUERY
    end

    subgraph "Native Detection"
        DETECT["std.zig.system detection"]
        CPUDETECT["CPU: cpuid, /proc/cpuinfo"]
        OSDETECT["OS: uname, NT version"]
        ABIDETECT["ABI: ldd, platform defaults"]

        DETECT --&gt; CPUDETECT
        DETECT --&gt; OSDETECT
        DETECT --&gt; ABIDETECT
    end

    TARGET --&gt; COMP["Compilation.root_mod&lt;br/&gt;.resolved_target.result"]</literallayout>
<simpara>Target queries come from three sources: command-line <literal>-target</literal> flags (explicit user choice), native detection when no target is specified (reads host CPU via cpuid or /proc/cpuinfo, OS via uname or NT APIs, and ABI via ldd or platform defaults), or module configuration in build scripts.</simpara>
<simpara>The <literal>resolveTargetQuery()</literal> function converts queries (which may contain "native" or "default" placeholders) into fully concrete <literal>std.Target</literal> instances by filling in all missing details. This resolution happens during compilation initialization before any code generation occurs.</simpara>
<simpara>When you omit <literal>-target</literal>, Zig automatically detects your host system and builds a native target. When you specify a partial triple like <literal>wasm32-wasi</literal>, resolution fills in the ABI (typically <literal>musl</literal> for WASI) and object format (<literal>wasm</literal>). The resolved target then flows into the compilation module where it controls every aspect of code generation, from instruction selection to runtime library choices.</simpara>
</section>
<section xml:id="target-query-example">
<title>Example: comparing host and cross targets from code</title>
<simpara>The sample introspects the host triple and then parses two cross targets, printing the resolved architecture, OS, and ABI.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 41__cross-compilation-and-wasm.adoc - include::example$chapters-data/code/41__cross-compilation-and-wasm/01_target_matrix.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run 01_target_matrix.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">host triple: x86_64-linux-gnu
pointer width: 64 bits
query wasm32-wasi: arch=wasm32 os=wasi abi=gnu
query x86_64-windows-gnu: arch=x86_64 os=windows abi=gnu
single-threaded: false</programlisting>
</para>
</formalpara>
<note>
<simpara>The parser obeys the same syntax as <literal>-Dtarget</literal> or <literal>zig build-exe -target</literal>; recycle the output to seed build configurations before invoking the compiler.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="native-cross">
<title>Cross-Compiling Native Executables</title>
<simpara>With a triple in hand, cross-compiling is a matter of swapping the target flag. Zig 0.15.2 ships with self-contained libc integrations, so producing Windows or macOS binaries on Linux no longer requires additional SDKs. <link xl:href="https://ziglang.org/download/0.15.1/release-notes.html">v0.15.2</link></simpara>
<simpara>Use <literal>file</literal> or similar tooling to confirm artifacts without booting another OS.</simpara>
<section xml:id="windows-example">
<title>Example: <literal>zig build-exe</literal> to Windows from Linux</title>
<simpara>We keep the source identical, run it natively for sanity, then emit a Windows PE binary and inspect it in place.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 41__cross-compilation-and-wasm.adoc - include::example$chapters-data/code/41__cross-compilation-and-wasm/02_cross_greeter.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run 02_cross_greeter.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">hello from x86_64-linux-gnu!
default executable suffix:</programlisting>
</para>
</formalpara>
<formalpara>
<title>Cross-compile</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe 02_cross_greeter.zig -target x86_64-windows-gnu -OReleaseFast -femit-bin=greeter-windows.exe
$ file greeter-windows.exe</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">greeter-windows.exe: PE32+ executable (console) x86-64, for MS Windows, 7 sections</programlisting>
</para>
</formalpara>
<tip>
<simpara>Pair <literal>-target</literal> with <literal>-mcpu=baseline</literal> when you need portable binaries for older hardware; the <literal>std.Target.Query</literal> output above shows which CPU model Zig will assume.</simpara>
</tip>
</section>
</chapter>
<chapter xml:id="wasi-modules">
<title>Emitting WASI Modules</title>
<simpara>WebAssembly System Interface (WASI) builds share most of the native pipeline with a different object format. The same Zig source can print diagnostics on Linux and emit a <literal>.wasm</literal> payload when cross-compiled, thanks to shared libc pieces introduced in this release.</simpara>
<section xml:id="_object_formats_and_linker_selection">
<title>Object Formats and Linker Selection</title>
<simpara>Before generating WASI binaries, it&#8217;s important to understand how object formats determine compilation output. The following diagram shows the relationship between ABIs and object formats:</simpara>
<literallayout class="monospaced">graph TB
    subgraph "Common ABIs"
        ABI["Abi enum"]

        ABI --&gt; GNU["gnu&lt;br/&gt;GNU toolchain"]
        ABI --&gt; MUSL["musl&lt;br/&gt;musl libc"]
        ABI --&gt; MSVC["msvc&lt;br/&gt;Microsoft Visual C++"]
        ABI --&gt; NONE["none&lt;br/&gt;freestanding"]
        ABI --&gt; ANDROID["android, gnueabi, etc&lt;br/&gt;platform variants"]
    end

    subgraph "Object Formats"
        OFMT["ObjectFormat enum"]

        OFMT --&gt; ELF["elf&lt;br/&gt;Linux, BSD"]
        OFMT --&gt; MACHO["macho&lt;br/&gt;Darwin systems"]
        OFMT --&gt; COFF["coff&lt;br/&gt;Windows PE"]
        OFMT --&gt; WASM["wasm&lt;br/&gt;WebAssembly"]
        OFMT --&gt; C["c&lt;br/&gt;C source output"]
        OFMT --&gt; SPIRV["spirv&lt;br/&gt;Shaders"]
    end</literallayout>
<simpara>The object format determines which linker implementation Zig uses to produce final binaries. <emphasis role="strong">ELF</emphasis> (Executable and Linkable Format) is used for Linux and BSD systems, producing <literal>.so</literal> shared libraries and standard executables. <emphasis role="strong">Mach-O</emphasis> targets Darwin systems (macOS, iOS), generating <literal>.dylib</literal> libraries and Mach executables. <emphasis role="strong">COFF</emphasis> (Common Object File Format) produces Windows PE binaries (<literal>.exe</literal>, <literal>.dll</literal>) when targeting Windows. <emphasis role="strong">WASM</emphasis> (WebAssembly) is a unique format that produces <literal>.wasm</literal> modules for web browsers and WASI runtimes. Unlike traditional formats, WASM modules are platform-independent bytecode designed for sandboxed execution. <emphasis role="strong">C</emphasis> and <emphasis role="strong">SPIRV</emphasis> are specialized: C outputs source code for integration with C build systems, while SPIRV produces GPU shader bytecode.</simpara>
<simpara>When you build for <literal>-target wasm32-wasi</literal>, Zig selects the WASM object format and invokes the WebAssembly linker (<literal>link/Wasm.zig</literal>), which handles WASM-specific concepts like function imports/exports, memory management, and table initialization. This is fundamentally different from the ELF linker (symbol resolution, relocations) or COFF linker (import tables, resource sections). The same source code compiles to different object formats transparentlyâ€”your Zig code remains identical whether targeting native Linux (ELF), Windows (COFF), or WASI (WASM).</simpara>
</section>
<section xml:id="wasi-example">
<title>Example: single source, native run, WASI artifact</title>
<simpara>Our pipeline logs the execution stages and branches on <literal>builtin.target.os.tag</literal> so the WASI build announces its own entry point.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 41__cross-compilation-and-wasm.adoc - include::example$chapters-data/code/41__cross-compilation-and-wasm/03_wasi_pipeline.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run 03_wasi_pipeline.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">stage: parse-args
stage: render-payload
stage: native-entry
stage: linux</programlisting>
</para>
</formalpara>
<formalpara>
<title>WASI build</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe 03_wasi_pipeline.zig -target wasm32-wasi -OReleaseSmall -femit-bin=wasi-pipeline.wasm
$ ls -lh wasi-pipeline.wasm</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">-rwxr--r-- 1 zkevm zkevm 4.6K Nov  6 13:40 wasi-pipeline.wasm</programlisting>
</para>
</formalpara>
<note>
<simpara>Run the resulting module with your preferred runtime (Wasmtime, Wasmer, browsers) or hand it to the build graph from the next chapter. No source changes required.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara><literal>zig targets</literal> provides the authoritative matrix of supported triples. Script it to validate your build matrix before dispatching jobs.</simpara>
</listitem>
<listitem>
<simpara>Some targets default to <literal>ReleaseSmall</literal>-style safety. Explicitly set <literal>-Doptimize</literal> when you require consistent runtime checks across architectures. <link xl:href="https://ziglang.org/documentation/master/#releasefast">#releasefast</link></simpara>
</listitem>
<listitem>
<simpara>When cross-linking to glibc, populate <literal>ZIG_LIBC</literal> or use <literal>zig fetch</literal> to cache sysroot artifacts so the linker does not reach for host headers unexpectedly.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Extend the greeter program with <literal>--cpu</literal> and <literal>--os</literal> flags, then emit binaries for <literal>x86_64-macos-gnu</literal> and <literal>aarch64-linux-musl</literal> and capture their sizes with <literal>ls -lh</literal>.</simpara>
</listitem>
<listitem>
<simpara>Modify the WASI pipeline to emit JSON via <literal>std.json.stringify</literal>, then run it in a WASI runtime and capture the output for regression tests. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/json.zig">json.zig</link></simpara>
</listitem>
<listitem>
<simpara>Write a <literal>build.zig</literal> step that loops over a list of target triples and calls <literal>addExecutable</literal> once per target, using the <literal>std.Target.Query</literal> helper to print human-friendly labels. <link xl:href="22__build-system-deep-dive.xml">22</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Alternatives &amp; Edge Cases:</title>
<itemizedlist>
<listitem>
<simpara>LLVM-backed targets may still behave differently from Zig&#8217;s self-hosted codegen. Fall back to <literal>-fllvm</literal> when you hit nascent architectures.</simpara>
</listitem>
<listitem>
<simpara>WASI forbids many syscalls and dynamic allocation patterns. Keep logging terse or gated to avoid blowing the import budget.</simpara>
</listitem>
<listitem>
<simpara>Windows cross-compiles pick the GNU toolchain by default. Add <literal>-msvc</literal> or switch ABI if you intend to link against MSVC-provided libraries. <link xl:href="20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.xml">20</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>