////
changes: ["Initial draft covering zig init, zig init --minimal, and build.zig.zon metadata"]
examples_compile: yes
keywords: ["zig init", "build.zig.zon", "package metadata", "fingerprint", "dependencies"]
last_updated: 2025-11-03
last_verified: 2025-11-03
next_chapter: "22__build-system-deep-dive"
open_questions: []
previous_chapter: "20__concept-primer-modules-vs-programs-vs-packages-vs-libraries"
status: draft
xref_complete: true
////

= Zig Init & Package Metadata
:chapter-number: 21
:chapter-slug: zig-init-and-package-metadata
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Chapter 20 settled the vocabulary distinguishing modules from programs, packages, and libraries; this chapter shows how `zig init` bootstraps that vocabulary into actual files, and how `build.zig.zon` codifies package identity, version constraints, and dependency metadata so the build system and package manager can resolve imports reliably. See xref:20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc[20] and link:https://ziglang.org/download/0.15.1/release-notes.html[v0.15.2].

We focus on package metadata structure before diving into build graph authoring in Chapter 22, ensuring you understand what each field in `build.zig.zon` controls and why Zig's fingerprint mechanism replaced earlier UUID-based schemes. See xref:22__build-system-deep-dive.adoc[22], link:https://github.com/ziglang/zig/blob/master/lib/init/build.zig.zon[build.zig.zon], and link:https://github.com/ziglang/zig/tree/master/lib/std/Build.zig[Build.zig].

[[learning-goals]]
== Learning Goals

* Use `zig init` and `zig init --minimal` to scaffold new projects with appropriate boilerplate for modules, executables, and tests.
* Interpret every field in `build.zig.zon`: name, version, fingerprint, minimum Zig version, dependencies, and paths.
* Distinguish remote dependencies (URL + hash), local dependencies (path), and lazy dependencies (deferred fetch).
* Explain why fingerprints provide globally unique package identity and how they prevent hostile fork confusion.

[[zig-init-basics]]
== Scaffolding projects with `zig init`

Zig 0.15.2 updated the default `zig init` template to encourage splitting reusable modules from executable entry points, addressing a common newcomer confusion where library code was unnecessarily compiled as static archives instead of being exposed as pure Zig modules. See link:https://github.com/ziglang/zig/blob/master/lib/init/build.zig[build.zig].

[[default-template]]
=== Default Template: Module + Executable

Running `zig init` in an empty directory generates four files demonstrating the recommended pattern for projects that want both a reusable module and a CLI tool:

[source,shell]
----
$ mkdir myproject && cd myproject
$ zig init
info: created build.zig
info: created build.zig.zon
info: created src/main.zig
info: created src/root.zig
info: see `zig build --help` for a menu of options
----

The generated structure separates concerns:

* `src/root.zig`: Reusable module exposing public API (e.g., `bufferedPrint`, `add`)
* `src/main.zig`: Executable entry point importing and using the module
* `build.zig`: Build graph wiring both the module and executable artifacts
* `build.zig.zon`: Package metadata including name, version, and fingerprint

This layout makes it trivial for external packages to depend on your module without inheriting unnecessary executable code, while still providing a convenient CLI for local development or distribution. xref:20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc[20]

TIP: If you only need a module or only need an executable, delete the files you don't need and simplify `build.zig` accordingly—the template is a starting point, not a mandate.

[[minimal-template]]
=== Minimal Template: Stub for Experienced Users

For users who know the build system and want minimal boilerplate, `zig init --minimal` generates only `build.zig.zon` and a stub `build.zig`:

[source,shell]
----
$ mkdir minimal-project && cd minimal-project
$ zig init --minimal
info: successfully populated 'build.zig.zon' and 'build.zig'
----

The resulting `build.zig.zon` is compact:

[source,zig]
----
.{
    .name = .minimal_project,
    .version = "0.0.1",
    .minimum_zig_version = "0.15.2",
    .paths = .{""},
    .fingerprint = 0x52714d1b5f619765,
}
----

The stub `build.zig` is equally terse:

[source,zig]
----
const std = @import("std");

pub fn build(b: *std.Build) void {
    _ = b; // stub
}
----

This mode is intended for cases where you have a clear build strategy in mind and want to avoid deleting boilerplate comments and example code.

[[build-zig-zon-anatomy]]
== Anatomy of `build.zig.zon`

Zig Object Notation (ZON) is a strict subset of Zig syntax used for data literals; `build.zig.zon` is the canonical file the build runner parses to resolve package metadata before invoking your `build.zig` script. See link:https://github.com/ziglang/zig/tree/master/lib/std/zon.zig[zon.zig] and link:https://github.com/ziglang/zig/tree/master/lib/std/zig/Zoir.zig[Zoir.zig].

[[zon-parse-modes]]
=== How ZON files are parsed

From the parser's point of view, `.zon` manifests are just another mode of `Ast.parse()`. The tokenizer is shared between `.zig` and `.zon` files, but `.zig` is parsed as a container of declarations while `.zon` is parsed as a single expression—exactly what `build.zig.zon` contains.

[mermaid]
....
graph TD
  START["Ast.parse()"] --> TOKENIZE["Tokenize source"]
  TOKENIZE --> MODE{Mode?}

  MODE -->|".zig"| PARSEROOT["Parse.parseRoot()"]
  MODE -->|".zon"| PARSEZON["Parse.parseZon()"]

  PARSEROOT --> CONTAINERMEMBERS["parseContainerMembers()"]
  CONTAINERMEMBERS --> ROOTAST["Root AST<br/>(container decls)"]

  PARSEZON --> EXPR["expectExpr()"]
  EXPR --> EXPRAST["Root AST<br/>(single expression)"]

  ROOTAST --> ASTRETURN["Return Ast struct"]
  EXPRAST --> ASTRETURN
....

* *Zig mode* (`.zig` files): Parses a full source file as a container with declarations
* *ZON mode* (`.zon` files): Parses a single expression (Zig Object Notation)

Sources: link:[lib/std/zig/Parse.zig:192-205], link:[lib/std/zig/Parse.zig:208-228]

[[zon-required-fields]]
=== Required Fields

Every `build.zig.zon` must define these core fields:

[source,zig]
----
include::{sourcedir}/21__zig-init-and-package-metadata/minimal_zon.zon[]
----

* `.name`: A symbol literal (e.g., `.myproject`) used as the default dependency key; conventionally lowercase, omitting redundant "zig" prefixes since the package already lives in the Zig namespace.
* `.version`: A semantic version string (`"MAJOR.MINOR.PATCH"`) that the package manager will eventually use for deduplication. link:https://github.com/ziglang/zig/tree/master/lib/std/SemanticVersion.zig[SemanticVersion.zig]
* `.minimum_zig_version`: The earliest Zig release that this package supports; older compilers will refuse to build it.
* `.paths`: An array of file/directory paths (relative to the build root) included in the package's content hash; only these files are distributed and cached.
* `.fingerprint`: A 64-bit hexadecimal integer serving as the package's globally unique identifier, generated once by the toolchain and never changed (except in hostile fork scenarios).

The following demo shows how these fields map to runtime introspection patterns (though in practice the build runner handles this automatically):

[source,zig]
----
include::{sourcedir}/21__zig-init-and-package-metadata/zon_field_demo.zig[]
----

.Run
[source,shell]
----
$ zig run zon_field_demo.zig
----

.Output
[source,shell]
----
=== build.zig.zon Field Demo ===
Sample ZON structure:
.{
    .name = .demo,
    .version = "0.1.0",
    .minimum_zig_version = "0.15.2",
    .fingerprint = 0x1234567890abcdef,
    .paths = .{"build.zig", "src"},
    .dependencies = .{},
}

Field explanations:
  .name: Package identifier (symbol literal)
  .version: Semantic version string
  .minimum_zig_version: Minimum supported Zig
  .fingerprint: Unique package ID (hex integer)
  .paths: Files included in package distribution
  .dependencies: External packages required

Note: Zig 0.15.2 uses .fingerprint for unique identity
      (Previously used UUID-style identifiers)
----

NOTE: Zig 0.15.2 replaced the old UUID-style `.id` field with the more compact `.fingerprint` field, simplifying generation and comparison while maintaining global uniqueness guarantees.footnote:[See Zig 0.15.2 release notes, section "Zig Init".]

[[fingerprint-identity]]
=== Fingerprint: Global Identity and Fork Detection

The `.fingerprint` field is the linchpin of package identity: it is generated once when you first run `zig init`, and should never change for the lifetime of the package unless you are deliberately forking it into a new identity.

Changing the fingerprint of an actively maintained upstream project is considered a **hostile fork**—an attempt to hijack the package's identity and redirect users to different code. Legitimate forks (where the upstream is abandoned) should regenerate the fingerprint to establish a new identity, while maintaining forks (backports, security patches) preserve the original fingerprint to signal continuity.

[source,zig]
----
include::{sourcedir}/21__zig-init-and-package-metadata/fingerprint_demo.zig[]
----

.Run
[source,shell]
----
$ zig run fingerprint_demo.zig
----

.Output
[source,shell]
----
=== Package Identity Validation ===

Package: mylib
Version: 1.0.0
Fingerprint: 0xabcdef1234567890

Version format valid: true

Fingerprint ensures:
  - Globally unique package identity
  - Unambiguous version detection
  - Fork detection (hostile vs. legitimate)

WARNING: Changing fingerprint of a maintained project
         is considered a hostile fork attempt!
----

IMPORTANT: The inline comment `// Changing this has security and trust implications.` in the generated `.zon` file is deliberately preserved to surface during code review if someone modifies the fingerprint without understanding the consequences.

[[dependencies-field]]
=== Dependencies: Remote, Local, and Lazy

The `.dependencies` field is a struct literal mapping dependency names to fetch specifications; each entry is either a remote URL dependency, a local filesystem path dependency, or a lazily-fetched optional dependency. 

[[annotated-dependencies]]
==== Annotated Dependency Examples

[source,zig]
----
include::{sourcedir}/21__zig-init-and-package-metadata/annotated_zon.zon[]
----

* **Remote dependencies** specify `.url` (a tarball/zip archive location) and `.hash` (a multihash-format content hash). The hash is the source of truth: even if the URL changes or mirrors are added, the package identity remains tied to the hash.
* **Local dependencies** specify `.path` (a relative directory from the build root). No hash is computed because the filesystem is the authority; this is useful for monorepo layouts or during development before publishing.
* **Lazy dependencies** add `.lazy = true` to defer fetching until the dependency is actually imported by a build script. This reduces bandwidth for optional features or platform-specific code paths.

[[dependency-types-demo]]
==== Dependency Types in Practice

[source,zig]
----
include::{sourcedir}/21__zig-init-and-package-metadata/dependency_types.zig[]
----

.Run
[source,shell]
----
$ zig run dependency_types.zig
----

.Output
[source,shell]
----
=== Dependency Types Comparison ===

Dependency 1: remote_package
  Type: remote
  Lazy: false
  URL: https://example.com/pkg.tar.gz
  Hash: 122012345678...
  (Fetched from network, cached locally)

Dependency 2: local_package
  Type: local
  Lazy: false
  Path: ../local-lib
  (No hash needed, relative to build root)

Dependency 3: lazy_optional
  Type: remote
  Lazy: true
  URL: https://example.com/opt.tar.gz
  Hash: 1220abcdef...
  (Fetched from network, cached locally)

Key differences:
  - Remote: Uses hash as source of truth
  - Local: Direct filesystem path
  - Lazy: Only fetched when actually imported
----

TIP: Use local paths during active development across multiple packages in the same workspace, then switch to remote URLs with hashes when publishing for external consumers. xref:24__zig-package-manager-deep.adoc[24]

Chapter 24 revisits these concepts in depth by walking through a package resolution pipeline that starts from `build.zig.zon`. xref:24__zig-package-manager-deep.adoc[24]

[[paths-field]]
=== Paths: Controlling Package Distribution

The `.paths` field specifies which files and directories are included when computing the package hash and distributing the package; everything not listed is excluded from the cached artifact.

Typical patterns:

[source,zig]
----
.paths = .{
    "build.zig",        // Build script is always needed
    "build.zig.zon",    // Metadata file itself
    "src",              // Source code directory (recursive)
    "LICENSE",          // Legal requirement
    "README.md",        // Documentation
}
----

Listing a directory includes all files within it recursively; listing the empty string `""` includes the build root itself (equivalent to listing every file individually, which is rarely desired).

IMPORTANT: Exclude generated artifacts (`zig-cache/`, `zig-out/`), large assets not needed for compilation, and internal development tools from `.paths` to keep package downloads small and deterministic.

=== Under the hood: ZON files in dependency tracking

The compiler's incremental dependency tracker treats ZON files as a distinct *dependee* category alongside source hashes, embedded files, and declaration-based dependencies. The core storage is an `InternPool` that owns multiple maps into a shared `dep_entries` array:

[mermaid]
....
graph TB
    subgraph "InternPool - Dependency Storage"
      SRCHASHDEPS["src_hash_deps<br/>Map: TrackedInst.Index → DepEntry.Index"]
      NAVVALDEPS["nav_val_deps<br/>Map: Nav.Index → DepEntry.Index"]
      NAVTYDEPS["nav_ty_deps<br/>Map: Nav.Index → DepEntry.Index"]
      INTERNEDDEPS["interned_deps<br/>Map: Index → DepEntry.Index"]
      ZONFILEDEPS["zon_file_deps<br/>Map: FileIndex → DepEntry.Index"]
      EMBEDFILEDEPS["embed_file_deps<br/>Map: EmbedFile.Index → DepEntry.Index"]
      NSDEPS["namespace_deps<br/>Map: TrackedInst.Index → DepEntry.Index"]
      NSNAMEDEPS["namespace_name_deps<br/>Map: NamespaceNameKey → DepEntry.Index"]

        FIRSTDEP["first_dependency<br/>Map: AnalUnit â†’ DepEntry.Index"]
        DEPENTRIES["dep_entries<br/>ArrayListUnmanaged<DepEntry>"]
        FREEDEP["free_dep_entries<br/>ArrayListUnmanaged<DepEntry.Index>"]
    end

    subgraph "DepEntry Structure"
        DEPENTRY["DepEntry<br/>{depender: AnalUnit,<br/>next_dependee: DepEntry.Index.Optional,<br/>next_depender: DepEntry.Index.Optional}"]
    end

    SRCHASHDEPS --> DEPENTRIES
    NAVVALDEPS --> DEPENTRIES
    NAVTYDEPS --> DEPENTRIES
    INTERNEDDEPS --> DEPENTRIES
    ZONFILEDEPS --> DEPENTRIES
    EMBEDFILEDEPS --> DEPENTRIES
    NSDEPS --> DEPENTRIES
    NSNAMEDEPS --> DEPENTRIES
    FIRSTDEP --> DEPENTRIES

    DEPENTRIES --> DEPENTRY
    FREEDEP -.->|"reuses indices from"| DEPENTRIES
....

The dependency tracking system uses multiple hash maps to look up dependencies by different *dependee* types. All maps point into a shared `dep_entries` array, which stores the actual `DepEntry` structures forming linked lists of dependencies.

Sources: link:[src/InternPool.zig:34-85]

[mermaid]
....
graph LR
    subgraph "Source-Level Dependencies"
        SRCHASH["Source Hash<br/>TrackedInst.Index<br/>src_hash_deps"]
        ZONFILE["ZON File<br/>FileIndex<br/>zon_file_deps"]
        EMBEDFILE["Embedded File<br/>EmbedFile.Index<br/>embed_file_deps"]
    end

    subgraph "Nav Dependencies"
        NAVVAL["Nav Value<br/>Nav.Index<br/>nav_val_deps"]
        NAVTY["Nav Type<br/>Nav.Index<br/>nav_ty_deps"]
    end

    subgraph "Type/Value Dependencies"
        INTERNED["Interned Value<br/>Index<br/>interned_deps<br/>runtime funcs, container types"]
    end

    subgraph "Namespace Dependencies"
        NSFULL["Full Namespace<br/>TrackedInst.Index<br/>namespace_deps"]
        NSNAME["Namespace Name<br/>NamespaceNameKey<br/>namespace_name_deps"]
    end

    subgraph "Memoized State"
        MEMO["Memoized Fields<br/>panic_messages, etc."]
    end
....

Each category tracks a different kind of dependee:

|===
| Dependee Type | Map Name | Key Type | When Invalidated

| *Source Hash*
| `src_hash_deps`
| `TrackedInst.Index`
| ZIR instruction body changes

| *Nav Value*
| `nav_val_deps`
| `Nav.Index`
| Declaration value changes

| *Nav Type*
| `nav_ty_deps`
| `Nav.Index`
| Declaration type changes

| *Interned Value*
| `interned_deps`
| `Index`
| Function IES changes, container type recreated

| *ZON File*
| `zon_file_deps`
| `FileIndex`
| ZON file imported via `@import` changes

| *Embedded File*
| `embed_file_deps`
| `EmbedFile.Index`
| File content accessed via `@embedFile` changes

| *Full Namespace*
| `namespace_deps`
| `TrackedInst.Index`
| Any name added/removed in namespace

| *Namespace Name*
| `namespace_name_deps`
| `NamespaceNameKey`
| Specific name existence changes

| *Memoized State*
| `memoized_state_*_deps`
| N/A (single entry)
| Compiler state fields change
|===

Sources: link:[src/InternPool.zig:34-71]

[[minimum-zig-version]]
=== Minimum Zig Version: Compatibility Bounds

The `.minimum_zig_version` field declares the earliest Zig release that the package can build with; older compilers will refuse to proceed, preventing silent miscompilations due to missing features or changed semantics.

When the language stabilizes at 1.0.0, this field will interact with semantic versioning to provide compatibility guarantees; before 1.0.0, it serves as a forward-looking compatibility declaration even though breaking changes happen every release.

[[version-field]]
=== Version: Semantic Versioning for Deduplication

The `.version` field currently documents the package's semantic version but does not yet enforce compatibility ranges or automatic deduplication; that functionality is planned for post-1.0.0 when the language stabilizes.

Follow semantic versioning conventions:

* **MAJOR**: Increment for incompatible API changes
* **MINOR**: Increment for backward-compatible feature additions
* **PATCH**: Increment for backward-compatible bug fixes

This discipline will pay off once the package manager can auto-resolve compatible versions within dependency trees. xref:24__zig-package-manager-deep.adoc[24]

[[zig-init-workflow]]
== Practical Workflow: From Init to First Build

A typical project initialization sequence looks like this:

[source,shell]
----
$ mkdir mylib && cd mylib
$ zig init
info: created build.zig
info: created build.zig.zon
info: created src/main.zig
info: created src/root.zig

$ zig build
$ zig build test
All 3 tests passed.

$ zig build run
All your codebase are belong to us.
Run `zig build test` to run the tests.
----

At this point, you have:

1. A reusable module (`src/root.zig`) exposing `bufferedPrint` and `add`
2. An executable (`src/main.zig`) importing and using the module
3. Tests for both the module and executable
4. Package metadata (`build.zig.zon`) ready for publishing

To share your module with other packages, you would publish the repository with a tagged release, document the URL and hash, and consumers would add it to their `.dependencies` table.

[[notes-caveats]]
== Notes & Caveats

* The fingerprint is generated from a random seed; regenerating `build.zig.zon` will produce a different fingerprint unless you preserve the original.
* Changing `.name` does not change the fingerprint; the name is a convenience alias while the fingerprint is the identity.
* Local path dependencies bypass the hash-based content addressing entirely; they are trusted based on filesystem state at build time.
* The package manager caches fetched dependencies in a global cache directory; subsequent builds with the same hash skip re-downloading.

[[exercises]]
== Exercises

* Run `zig init` in a new directory, then modify `build.zig.zon` to add a fake remote dependency with a placeholder hash; observe the error when running `zig build --fetch`.
* Create two packages in sibling directories, configure one as a local path dependency of the other, and verify that changes in the dependency are immediately visible without re-fetching.
* Generate a `build.zig.zon` with `zig init --minimal`, then manually add a `.dependencies` table and compare the resulting structure with the annotated example in this chapter.
* Fork a hypothetical package by regenerating the fingerprint (delete the field and run `zig build`), then document in a README why this is a new identity rather than a hostile takeover.

[[caveats-alternatives-edge-cases]]
== Caveats, alternatives, edge cases

* If you omit `.paths`, the package manager may include unintended files in the distribution, inflating download size and exposing internal implementation details.
* Remote dependency URLs can become stale if the host moves or removes the archive; consider mirroring critical dependencies or using content-addressed storage systems. xref:24__zig-package-manager-deep.adoc[24]
* The `zig fetch --save <url>` command automates adding a remote dependency to `.dependencies` by downloading, hashing, and inserting the correct entry—use it instead of hand-typing hashes.
* Lazy dependencies require build script cooperation: if your `build.zig` unconditionally references a lazy dependency without checking availability, the build will fail with a "dependency not available" error.
