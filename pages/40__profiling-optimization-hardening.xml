<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Profiling, Optimization, Hardening</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Last chapter we explored semantic inlining and SIMD to shape hotspots (see <link xl:href="39__performance-and-inlining.xml">39</link>); this time we go hands-on with the measurement loop that tells you whether those tweaks actually paid off. We will combine lightweight timers, build-mode comparisons, and hardened error guards to turn experimental code into a reliable toolchain. Each technique leans on recent CLI improvements, such as <literal>zig build --time-report</literal>, to keep feedback fast (see <link xl:href="https://ziglang.org/download/0.15.1/release-notes.html#web-interface-and-time-report">v0.15.2</link>).</simpara>
<simpara>By the end of this chapter you will have a repeatable recipe: collect timing baselines, choose a release strategy (speed versus size), and run safeguards across optimization levels so regressions surface before deployment.</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Instrument hot paths with <literal>std.time.Timer</literal> and interpret the relative deltas (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/time.zig">time.zig</link>).</simpara>
</listitem>
<listitem>
<simpara>Compare ReleaseFast and ReleaseSmall artifacts, understanding the trade-off between diagnostics and binary size (see <link xl:href="https://ziglang.org/documentation/master/#releasefast">#releasefast</link>).</simpara>
</listitem>
<listitem>
<simpara>Harden parsing and throttling code with error guards that hold under every optimization setting (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/testing.zig">testing.zig</link>).</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="profiling-with-timers">
<title>Profiling Baselines with Monotonic Timers</title>
<simpara><literal>std.time.Timer</literal> samples a monotonic clock, making it ideal for quick \"is it faster?\" experiments without touching global state. Paired with deterministic input data, it keeps microbenchmarks honest when you repeat them under different build modes.</simpara>
<section xml:id="timer-sort-bench">
<title>Example: Sorting Strategies Under a Single Timer Harness</title>
<simpara>We reuse the dataset for three algorithms—block sort, heap sort, and insertion sort—to illustrate how timing ratios guide further investigation. The dataset is regenerated for each run so cache effects stay consistent (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/sort.zig">sort.zig</link>).</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 40__profiling-optimization-hardening.adoc - include::example$chapters-data/code/40__profiling-optimization-hardening/01_timer_probe.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run 01_timer_probe.zig -OReleaseFast</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">optimize-mode=ReleaseFast
block sort     : 43753 ns
heap sort      : 75331 ns
insertion sort : 149541 ns
heap speedup over block: 0.58x
insertion slowdown vs block: 3.42x</programlisting>
</para>
</formalpara>
<note>
<simpara>Follow up with <literal>zig build --time-report -Doptimize=ReleaseFast</literal> on the same module when you need attribution for longer stages like hashing or parsing.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="size-strategy">
<title>Trading Binary Size for Diagnostics</title>
<simpara>Switching between ReleaseFast and ReleaseSmall is more than a compiler flag: ReleaseSmall strips safety checks and aggressively prunes code to shrink the final binary. When you profile on laptops but deploy on embedded devices, build both variants and confirm the difference justifies the lost diagnostics.</simpara>
<section xml:id="size-comparison">
<title>Example: Tracing Logic That Disappears in ReleaseSmall</title>
<simpara>Tracing is enabled only when the optimizer leaves safety checks intact. Measuring binary sizes provides a tangible signal that ReleaseSmall is doing its job.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 40__profiling-optimization-hardening.adoc - include::example$chapters-data/code/40__profiling-optimization-hardening/02_binary_size.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe 02_binary_size.zig -OReleaseFast -femit-bin=perf-releasefast
$ zig build-exe 02_binary_size.zig -OReleaseSmall -femit-bin=perf-releasesmall
$ ls -lh perf-releasefast perf-releasesmall</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">-rwxrwxr-x 1 zkevm zkevm 876K Nov  6 13:12 perf-releasefast
-rwxrwxr-x 1 zkevm zkevm  11K Nov  6 13:12 perf-releasesmall</programlisting>
</para>
</formalpara>
<tip>
<simpara>Keep both artifacts around—ReleaseFast for symbol-rich profiling sessions, ReleaseSmall for production handoff. Share them via <literal>zig build --artifact</literal> or package manager hashes to keep CI deterministic.</simpara>
</tip>
</section>
</chapter>
<chapter xml:id="hardening-regressions">
<title>Hardening Across Optimization Modes</title>
<simpara>After tuning performance and size, wrap the pipeline with tests that assert guard rails across build modes. This is vital because ReleaseFast and ReleaseSmall disable runtime safety checks by default (see <link xl:href="https://ziglang.org/documentation/master/#setruntimesafety">#setruntimesafety</link>). Running the same test suite in ReleaseSafe ensures diagnostics still fire when safety remains enabled.</simpara>
<section xml:id="guarded-pipeline">
<title>Example: Validating Input Parsing and Throttling in Every Mode</title>
<simpara>The pipeline parses limits, clamps workloads, and defends against empty input. The final test loops through values inline, mirroring the real application path while staying cheap to execute.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 40__profiling-optimization-hardening.adoc - include::example$chapters-data/code/40__profiling-optimization-hardening/03_guarded_pipeline.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig test 03_guarded_pipeline.zig -OReleaseFast</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">All 4 tests passed.</programlisting>
</para>
</formalpara>
<note>
<simpara>Repeat the command with <literal>-OReleaseSafe</literal> and plain <literal>zig test</literal> to make sure guard clauses work identically in safety-on builds. The inline loop proves the compiler can still unroll checks without sacrificing correctness.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>Use deterministic data when microbenchmarking so timer noise reflects algorithm changes, not PRNG drift (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Random.zig">Random.zig</link>).</simpara>
</listitem>
<listitem>
<simpara>ReleaseSmall disables error return traces and many assertions; pair it with a ReleaseFast smoke test before shipping to catch missing diagnostics.</simpara>
</listitem>
<listitem>
<simpara><literal>std.debug.assert</literal> remains active in Debug and ReleaseSafe. If ReleaseFast removes it, compensate with integration tests or explicit error handling (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/debug.zig">debug.zig</link>).</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Add a <literal>--sort</literal> flag to select the algorithm at runtime, then capture <literal>zig build --time-report</literal> snapshots for each choice.</simpara>
</listitem>
<listitem>
<simpara>Extend the size example with a <literal>--metrics</literal> flag that turns tracing back on; document the binary delta using <literal>zig build-exe -fstrip</literal> for extra savings.</simpara>
</listitem>
<listitem>
<simpara>Parameterize <literal>parseLimit</literal> to accept hexadecimal input and tighten the tests so they run under <literal>zig test -OReleaseSmall</literal> without triggering UB. <link xl:href="37__illegal-behavior-and-safety-modes.xml">37</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Alternatives &amp; Edge Cases</title>
<itemizedlist>
<listitem>
<simpara>Microbenchmarks that rely on <literal>std.debug.print</literal> will skew ReleaseSmall timings because the call is removed. Consider logging into ring buffers instead.</simpara>
</listitem>
<listitem>
<simpara>Use <literal>zig build run --watch -fincremental</literal> when iterating on instrumentation. Threaded codegen in 0.15.2 keeps rebuilds responsive even after large edits (see <link xl:href="https://ziglang.org/download/0.15.1/release-notes.html#threaded-codegen">v0.15.2</link>).</simpara>
</listitem>
<listitem>
<simpara>If your tests mutate data structures with undefined behavior in ReleaseFast, isolate the risky code behind <literal>@setRuntimeSafety(true)</literal> for the duration of the hardening exercise.</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>