////
changes: ["Added networking and HTTP coverage", "Documented JSON fetch pipeline"]
examples_compile: yes
keywords: ["networking", "http", "json"]
last_updated: 2025-11-05
last_verified: 2025-11-05
next_chapter: "32__project-http-json-client"
open_questions: []
previous_chapter: "30__project-parallel-wordcount"
status: draft
xref_complete: true
////

= Networking, HTTP, and JSON
:chapter-number: 31
:chapter-slug: networking-http-and-json
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

This chapter graduates from local files and threads to sockets, using Zig's `std.net` and `std.http` packages to move data between processes in a disciplined way. For background, see link:https://github.com/ziglang/zig/tree/master/lib/std/net.zig[net.zig]. We will build a minimal loopback server, explore handshakes, and layer an HTTP/JSON workflow on top to demonstrate how these pieces compose.

Zig 0.15.2's I/O redesign removes legacy buffered helpers, so we will adopt the modern `std.Io.Reader`/`std.Io.Writer` interface and show how to manage framing manually when necessary. See link:https://github.com/ziglang/zig/tree/master/lib/std/Io/Reader.zig[Reader.zig] and link:https://ziglang.org/download/0.15.1/release-notes.html[v0.15.2].

=== The Network Stack Architecture

Before diving into socket code, it's essential to understand how `std.net` fits into Zig's standard library architecture. The following diagram shows the complete layering from high-level networking APIs down to system calls:

[mermaid]
....
graph TB
    subgraph "User Code"
        APP[Application Code]
    end

    subgraph "High-Level APIs (lib/std)"
        FS["std.fs<br/>(fs.zig)"]
        NET["std.net<br/>(net.zig)"]
        PROCESS["std.process<br/>(process.zig)"]
        FMT["std.fmt<br/>(fmt.zig)"]
        HEAP["std.heap<br/>(heap.zig)"]
    end

    subgraph "Mid-Level Abstractions"
        POSIX["std.posix<br/>(posix.zig)<br/>Cross-platform POSIX API"]
        OS["std.os<br/>(os.zig)<br/>OS-specific wrappers"]
        MEM["std.mem<br/>(mem.zig)<br/>Memory utilities"]
        DEBUG["std.debug<br/>(debug.zig)<br/>Stack traces, assertions"]
    end

    subgraph "Platform Layer"
        LINUX["std.os.linux<br/>(os/linux.zig)<br/>Direct syscalls"]
        WINDOWS["std.os.windows<br/>(os/windows.zig)<br/>Win32 APIs"]
        WASI["std.os.wasi<br/>(os/wasi.zig)<br/>WASI APIs"]
        LIBC["std.c<br/>(c.zig)<br/>C interop"]
    end

    subgraph "System Layer"
        SYSCALL["System Calls"]
        KERNEL["Operating System"]
    end

    APP --> FS
    APP --> NET
    APP --> PROCESS
    APP --> FMT
    APP --> HEAP

    FS --> POSIX
    NET --> POSIX
    PROCESS --> POSIX
    FMT --> MEM
    HEAP --> MEM

    POSIX --> OS
    OS --> LIBC
    OS --> LINUX
    OS --> WINDOWS
    OS --> WASI

    DEBUG --> OS

    LINUX --> SYSCALL
    WINDOWS --> SYSCALL
    WASI --> SYSCALL
    LIBC --> SYSCALL

    SYSCALL --> KERNEL
....

This layered design mirrors the filesystem architecture from Chapter 28: `std.net` provides high-level, portable networking abstractions (Address, Stream, Server), which flow through `std.posix` for cross-platform POSIX socket compatibility, which then dispatches to platform-specific implementations—either direct syscalls on Linux (`socket`, `bind`, `listen`, `accept`) or Win32 Winsock APIs on Windows. When you call `Address.listen()`, the request traverses these layers: `std.net.Address` → `std.posix.socket()` → `std.os.linux.socket()` (or `std.os.windows.WSASocketW()`) → kernel. This explains why WASI builds fail on socket operations—the WASI layer lacks socket support in most runtimes. Understanding this architecture helps you reason about error handling (errors bubble up from syscalls), debug platform-specific issues, and make informed decisions about libc linking for maximum portability.

[[learning-goals]]
== Learning Goals

The goals in this module revolve around the networking primitives in `std.net` and the HTTP stack built on them (link:https://github.com/ziglang/zig/tree/master/lib/std/http/Server.zig[Server.zig], link:https://github.com/ziglang/zig/tree/master/lib/std/http/Client.zig[Client.zig]). You will learn how to:

* Compose a loopback service with `std.net.Address.listen` that promptly accepts connections and coordinates readiness with `std.Thread.ResetEvent`.
* Implement newline-oriented framing using the new `std.Io.Reader` helpers rather than deprecated buffered adapters.
* Call `std.http.Client.fetch`, capture the response stream, and parse JSON payloads with `std.json` utilities. link:https://github.com/ziglang/zig/tree/master/lib/std/json.zig[json.zig]

[[socket-building-blocks]]
== Socket building blocks

`std.net` exposes cross-platform TCP primitives that mirror the POSIX socket lifecycle while integrating with Zig's error semantics and resource management. Pairing them with `std.Thread.ResetEvent` lets us synchronise a server thread's readiness with a client, without resorting to polling. link:https://github.com/ziglang/zig/tree/master/lib/std/Thread/ResetEvent.zig[ResetEvent.zig]

[[loopback-handshake]]
=== Loopback handshake walkthrough

The following example binds to `127.0.0.1`, accepts a single client, and echoes the trimmed line it received. Because Zig's reader API no longer offers convenience line readers, the sample implements a `readLine` helper with `Reader.takeByte`, demonstrating how to build that functionality directly.

[source,zig]
----
include::{sourcedir}/31__networking-http-and-json/01_loopback_ping.zig[]
----

.Run
[source,shell]
----
$ zig run 01_loopback_ping.zig
----

.Output
[source,shell]
----
loopback handshake succeeded
client received: server observed "ping over loopback"
----

TIP: `std.Thread.ResetEvent` provides an inexpensive latch for announcing that the server thread reached `accept`, ensuring the client connection attempt does not race ahead.

[[manual-framing]]
=== Managing framing explicitly

Reading a line requires awareness of how the new reader interface delivers bytes: `takeByte` yields one byte at a time and reports `error.EndOfStream`, which we convert to either `null` (no data) or a completed slice. This manual framing encourages you to think about protocol boundaries rather than relying on an implicit buffered reader, and mirrors the intent of the 0.15.2 I/O overhaul.

[[http-pipeline]]
== HTTP pipelines in Zig

With sockets in hand, we can step up a level: Zig's standard library ships an HTTP server and client implemented entirely in Zig, letting you serve endpoints and perform requests without third-party dependencies.

[[http-serve]]
=== Serving JSON from a loopback listener

The server thread in the next example wraps the accepted stream with `std.http.Server`, parses one request, and emits a compact JSON body. Notice how we pre-render the response into a fixed buffer, so `request.respond` can advertise the content length accurately. link:https://github.com/ziglang/zig/tree/master/lib/std/Io/Writer.zig[Writer.zig]

[[http-fetch-json]]
=== Fetching and decoding with `std.http.Client`

The companion client uses `std.http.Client.fetch` to perform a GET request, collects the body via a fixed writer and decodes it into a strongly typed struct using `std.json.parseFromSlice`. The same routine can be extended to follow redirects, stream large payloads, or negotiate TLS, depending on your needs. link:https://github.com/ziglang/zig/tree/master/lib/std/json/static.zig[static.zig]

[source,zig]
----
include::{sourcedir}/31__networking-http-and-json/02_http_fetch_and_json.zig[]
----

.Run
[source,shell]
----
$ zig run 02_http_fetch_and_json.zig
----

.Output
[source,shell]
----
status: 200
service: loopback-api
method: GET
path: /stats
message: hello from Zig HTTP server
----

NOTE: `Client.fetch` defaults to keep-alive connections and automatically reuses sockets from its pool. When you feed it a fixed writer, the writer returns `error.WriteFailed` if your buffer is too small. Size it to cover the payload you expect, or fall back to an allocator-backed writer.

[[json-tooling]]
== JSON tooling essentials

`std.json.Stringify` and `std.json.parseFromSlice` let you stay in typed Zig data while emitting or consuming JSON text, provided you pay attention to allocation strategy. In these examples, we employ `std.Io.Writer.fixed` to build bodies without heap activity, and we release parse results with `Parsed.deinit()` once done. link:https://github.com/ziglang/zig/tree/master/lib/std/json/Stringify.zig[Stringify.zig]

=== Understanding the Writer Abstraction

Both HTTP response generation and JSON serialization rely on Zig's Writer interface. The following diagram shows the writer abstraction and its key implementations:

[mermaid]
....
graph TB
    WRITER["Writer"]

    subgraph "Writer Types"
        FIXED["fixed(buffer)"]
        ALLOC["Allocating"]
        DISCARD["Discarding"]
    end

    WRITER --> FIXED
    WRITER --> ALLOC
    WRITER --> DISCARD

    subgraph "Write Methods"
        PRINT["print(fmt, args)"]
        PRINTVAL["printValue(specifier, options, value, depth)"]
        PRINTINT["printInt(value, base, case, options)"]
        WRITEBYTE["writeByte(byte)"]
        WRITEALL["writeAll(bytes)"]
    end

    WRITER --> PRINT
    WRITER --> PRINTVAL
    WRITER --> PRINTINT
    WRITER --> WRITEBYTE
    WRITER --> WRITEALL
....

The Writer abstraction provides a unified interface for output operations, with three main implementation strategies. **Fixed buffer writers** (`std.Io.Writer.fixed(buffer)`) write to a pre-allocated buffer and return `error.WriteFailed` when the buffer is full—this is what the HTTP example uses to build response bodies with zero heap allocation. **Allocating writers** dynamically grow their buffer using an allocator, suitable for unbounded output like streaming large JSON documents. **Discarding writers** count bytes without storing them, useful for calculating content length before actually writing. The write methods provide a consistent API regardless of the underlying implementation: `writeAll` for raw bytes, `print` for formatted output, `writeByte` for single bytes, and specialized methods like `printInt` for numeric formatting. When you call `std.json.stringify(value, .{}, writer)`, the JSON serializer doesn't care whether `writer` is fixed, allocating, or discarding—it just calls `writeAll` and the writer implementation handles the details. This is why the chapter mentions 'size it to cover the payload you expect or fall back to an allocator-backed writer'—you're choosing between bounded fixed buffers (fast, no allocation, can overflow) and dynamic allocating buffers (flexible, heap overhead, no size limit).

[[notes-caveats]]
== Notes & Caveats

* TCP loopback servers still block the current thread on `accept`; when targeting single-threaded builds, you must branch on `builtin.single_threaded` to avoid spawning. link:https://github.com/ziglang/zig/tree/master/lib/std/builtin.zig[builtin.zig]
* The HTTP client rescans system trust stores the first time you make an HTTPS request; if you vend your own certificate bundle, toggle `client.next_https_rescan_certs` accordingly.
* The new I/O APIs expose raw buffers, so ensure your fixed writers and readers have enough capacity before reusing them across requests.

[[exercises]]
== Exercises

* Extend the loopback handshake to accept multiple clients by storing handles in a slice and joining them after broadcasting a shutdown message. link:https://github.com/ziglang/zig/tree/master/lib/std/Thread.zig[Thread.zig]
* Add a `--head` flag to the HTTP example that issues a `HEAD` request and prints the negotiated headers, inspecting `Response.head` for metadata.
* Replace the manual `readLine` helper with `Reader.discardDelimiterLimit` to compare behaviour and error handling under the new I/O contracts.

[[caveats-alternatives-edge-cases]]
== Caveats, alternatives, edge cases

* Not every Zig target supports sockets; WASI builds, for instance, will fail during `Address.listen`, so guard availability by inspecting the target OS tag.
* TLS requests require a certificate bundle; embed one with `Client.ca_bundle` when running in environments without system stores (CI, containers, early boot environments).
* `std.json.parseFromSlice` loads the whole document into memory; for large payloads prefer the streaming `std.json.Scanner` API to process tokens incrementally. link:https://github.com/ziglang/zig/tree/master/lib/std/json/Scanner.zig[Scanner.zig]

[[summary]]
== Summary

* `std.net` and `std.Io.Reader` give you the raw tools to accept connections, manage framing, and synchronise readiness across threads in a predictable way.
* `std.http.Server` and `std.http.Client` sit naturally atop `std.net`, providing composable building blocks for REST-style services without external dependencies.
* `std.json` rounds out the story by turning on-wire data into typed structs and back, keeping ownership explicit so you can choose between fixed buffers and heap-backed writers.
