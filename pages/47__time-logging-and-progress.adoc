////
changes: ["Initial Time, Logging, and Progress chapter for Zig 0.15.2"]
examples_compile: yes
keywords: ["std.time", "std.log", "std.Progress", "Timer", "Instant", "sleep", "log scopes", "progress bars"]
last_updated: 2025-11-06
last_verified: 2025-11-06
previous_chapter: "46__io-and-stream-adapters"
next_chapter: "48__process-and-environment"
status: draft
xref_complete: true
////

= Time, Logging, and Progress
:chapter-number: 47
:chapter-slug: time-logging-and-progress
:creative-commons:
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

== Introduction

This chapter rounds out everyday operational tools in Zig: precise time measurement (`std.time`), structured logging (`std.log`), and terminal-friendly progress reporting (`std.Progress`). Here we make pipelines observable, measurable, and user-friendly. link:https://github.com/ziglang/zig/tree/master/lib/std/time.zig[time.zig] link:https://github.com/ziglang/zig/tree/master/lib/std/log.zig[log.zig] link:https://github.com/ziglang/zig/tree/master/lib/std/Progress.zig[Progress.zig]

We'll focus on deterministic snippets that work across platforms under Zig 0.15.2, highlighting gotchas, performance notes, and best practices.

== Timekeeping with std.time

Zig's `std.time` provides:
- Calendar timestamps: `timestamp()`, `milliTimestamp()`, `microTimestamp()`, `nanoTimestamp()`.
- Duration/units: constants like `ns_per_ms`, `ns_per_s`, `s_per_min` for conversions.
- High-precision timers: `Instant` (fast, not strictly monotonic) and `Timer` (monotonic behavior by saturation).

In general, prefer `Timer` for measuring elapsed durations. Reach for `Instant` only when you need faster sampling and can tolerate occasional non-monotonicity from quirky OS/firmware environments.

=== Measuring elapsed time (Timer)

`Timer` yields monotonic readings (saturating on regressions) and is ideal for benchmarking and timeouts. xref:39__performance-and-inlining.adoc[39]

[source,zig]
----
include::{sourcedir}/47__time-logging-and-progress/time_timer_sleep.zig[]
----

.Run
[source,shell]
----
$ zig run time_timer_sleep.zig
----

.Expected output
[listing]
----
Timer OK
----

NOTE: Sleeping uses `std.Thread.sleep(ns)`. On most OSes the granularity is ~1ms or worse; timers are as precise as the underlying clocks permit. link:https://github.com/ziglang/zig/tree/master/lib/std/Thread.zig[Thread.zig]

=== Instant sampling and ordering

`Instant.now()` gives a fast, high-precision timestamp for the current process. It tries to advance during suspend and can be compared or differenced. It is not guaranteed strictly monotonic everywhere. Use `Timer` when you need that property enforced.

[source,zig]
----
include::{sourcedir}/47__time-logging-and-progress/time_instant_order.zig[]
----

.Run
[source,shell]
----
$ zig run time_instant_order.zig
----

.Expected output
[listing]
----
Instant OK
----

=== Time unit conversions

Prefer the provided unit constants over hand-rolled math. They improve clarity and prevent mistakes in mixed units.

[source,zig]
----
include::{sourcedir}/47__time-logging-and-progress/time_units.zig[]
----

.Run
[source,shell]
----
$ zig run time_units.zig
----

.Expected output
[listing]
----
2 min = 120 s
1 h = 3600000000000 ns
----

TIP: For calendar computations (year, month, day), see `std.time.epoch` helpers; for file timestamp metadata, see `std.fs.File` APIs. xref:28__filesystem-and-io.adoc[28], link:https://github.com/ziglang/zig/tree/master/lib/std/time/epoch.zig[epoch.zig], link:https://github.com/ziglang/zig/tree/master/lib/std/fs/File.zig[File.zig]

== Logging with std.log

`std.log` is a small, composable logging façade. You can:
- Control log level via `std_options` (defaults are build-mode dependent).
- Use scopes (namespaces) to categorize messages.
- Provide a custom `logFn` to change formatting or redirects.

Below, we set `.log_level = .info` so debug logs are suppressed, and demonstrate both default and scoped logging.

[source,zig]
----
include::{sourcedir}/47__time-logging-and-progress/logging_basic.zig[]
----

.Run
[source,shell]
----
$ zig run logging_basic.zig 2>&1 | cat
----

.Expected output
[listing]
----
info: starting
warning: high temperature
info(app): running
----

NOTE:
- The default logger writes to stderr, so we use `2>&1` above to show it inline in this book.
- In Debug builds the default level is `.debug`. Override via `std_options` to make examples stable across optimize modes.

== Progress reporting with std.Progress

`std.Progress` draws a small tree of tasks to the terminal, updating periodically from another thread. It is non-allocating and aims to be portable across terminals and Windows consoles. Use it to indicate long-running work such as builds, downloads, or analysis passes.

The following demo disables printing for deterministic output while exercising the API (root node, children, `completeOne`, `end`). In real tools, omit `disable_printing` to render a dynamic progress view.

[source,zig]
----
include::{sourcedir}/47__time-logging-and-progress/progress_basic.zig[]
----

.Run
[source,shell]
----
$ zig run progress_basic.zig
----

.Expected output
[listing]
----
no output
----

TIP:
- Use `Options.estimated_total_items` to show counts (“[3/10] compile”); 
- Update names with `setName`; 
- Signal success/failure via `std.Progress.setStatus`.

== Notes and caveats

- Timer vs. Instant: prefer `Timer` for elapsed time and monotonic behavior; use `Instant` for fast samples when occasional non-monotonicity is acceptable.
- Sleep resolution is OS-dependent. Don't assume sub-millisecond precision.
- Logging filters apply per scope. Use `scoped(.your_component)` to gate noisy subsystems cleanly.
- `std.Progress` output adapts to terminal capabilities. On CI/non-TTY or disabled printing, nothing is written.
- Timezone support: stdlib does not yet have a stable `std.tz` module in 0.15.2. Use platform APIs or a library if you need timezone math. [TBD]

== Exercises

- Write a micro-benchmark using `Timer` to compare two formatting routines. Print the faster one and by how many microseconds.
- Wrap `std.log` with a custom `logFn` that prefixes timestamps from `nanoTimestamp()`. Ensure it remains non-allocating.
- Create a small build simulator with `std.Progress` showing three phases. Make the second phase dynamically increase `estimated_total_items`.

== Open Questions

- Timezone helpers in std: status and roadmap for a future `std.tz` or equivalent? [TBD]
