<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Appendix C. Error-Handling Patterns Cookbook</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Chapter 4 introduced the mechanics of Zig&#8217;s error unions, <literal>try</literal>, and <literal>errdefer</literal>; this appendix turns those ideas into a quick-reference cookbook you can consult while sketching new APIs or refactoring existing ones. Each recipe tightens the link between domain-specific error vocabularies and the diagnostic messages your users ultimately see.</simpara>
<simpara>Zig 0.15.2 refined diagnostics around integer casts and allocator failures, making it easier to rely on precise error propagation in both debug and release-safe builds.<link xl:href="https://ziglang.org/download/0.15.1/release-notes.html">v0.15.2</link></simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Layer domain-specific error sets on top of standard Zig I/O failures without losing precision.</simpara>
</listitem>
<listitem>
<simpara>Guard heap-backed transformations with <literal>errdefer</literal> so that every exit path pairs allocations and deallocations.</simpara>
</listitem>
<listitem>
<simpara>Translate internal error unions into clear, actionable messages for logs and user interfaces.</simpara>
</listitem>
</itemizedlist>
<simpara>_Refs: _</simpara>
</chapter>
<chapter xml:id="layered-error-vocabularies">
<title>Layered Error Vocabularies</title>
<simpara>When a subsystem introduces its own error conditions, refine the vocabulary instead of throwing everything into <literal>anyerror</literal>. The pattern below composes a configuration-specific union from parsing failures and simulated I/O errors so the caller never loses track of <literal>NotFound</literal> versus <literal>InvalidPort</literal>.<link xl:href="04__errors-resource-cleanup.xml">4</link> The <literal>catch |err| switch</literal> idiom keeps the mapping honest and mirrors how <literal>std.fmt.parseInt</literal> surfaces parsing issues.<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig">fmt.zig</link></simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 57__error-handling-patterns-cookbook.adoc - include::example$chapters-data/code/57__error-handling-patterns-cookbook/01_layered_error_sets.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig test 01_layered_error_sets.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">All 3 tests passed.</programlisting>
</para>
</formalpara>
<tip>
<simpara>Preserve the original error names all the way to your API boundary—callers can branch on <literal>LoadError.PermissionDenied</literal> explicitly, which is more robust than string matching or sentinel values.<link xl:href="36__style-and-best-practices.xml">36</link></simpara>
</tip>
</chapter>
<chapter xml:id="errdefer-patterns">
<title>errdefer for Balanced Cleanup</title>
<simpara>String assembly and JSON shaping often allocate temporary buffers; forgetting to free them when a validation step fails leads straight to leaks. By pairing <literal>std.ArrayListUnmanaged</literal> with <literal>errdefer</literal>, the next recipe guarantees both success and failure paths clean up correctly while still returning a convenient owned slice.<link xl:href="13__testing-and-leak-detection.xml">13</link> Every allocation helper used here ships in the standard library, so the same structure scales to more complex builders.<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/array_list.zig">array_list.zig</link></simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 57__error-handling-patterns-cookbook.adoc - include::example$chapters-data/code/57__error-handling-patterns-cookbook/02_errdefer_join_upper.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig test 02_errdefer_join_upper.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">All 2 tests passed.</programlisting>
</para>
</formalpara>
<note>
<simpara>Because the standard testing allocator trips on leaks automatically, exercising both the success and error branches doubles as a regression harness for future edits.<link xl:href="13__testing-and-leak-detection.xml">13</link></simpara>
</note>
</chapter>
<chapter xml:id="reporting-bridges">
<title>Translating Errors for Humans</title>
<simpara>Even the best-crafted error sets need to land with empathetic language. The final pattern demonstrates how to keep the original <literal>ApiError</literal> for programmatic callers while producing human-readable prose for logs or UI copy.<link xl:href="36__style-and-best-practices.xml">36</link> <literal>std.io.fixedBufferStream</literal> makes the output deterministic for tests, and the dedicated formatter isolates messaging from control flow.<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/log.zig">log.zig</link></simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 57__error-handling-patterns-cookbook.adoc - include::example$chapters-data/code/57__error-handling-patterns-cookbook/03_error_reporting_bridge.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig test 03_error_reporting_bridge.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">All 2 tests passed.</programlisting>
</para>
</formalpara>
<tip>
<simpara>Keep the bridge function pure—it should only depend on the error payload and a writer—so consumers can swap logging backends or capture diagnostics in-memory during tests.<link xl:href="36__style-and-best-practices.xml">36</link></simpara>
</tip>
</chapter>
<chapter xml:id="patterns">
<title>Patterns to Keep on Hand</title>
<itemizedlist>
<listitem>
<simpara>Bubble lower-level errors verbatim until the last responsible boundary, then convert them in one place to keep invariants obvious.<link xl:href="04__errors-resource-cleanup.xml">4</link></simpara>
</listitem>
<listitem>
<simpara>Treat <literal>errdefer</literal> as a handshake: every allocation or file open should have a matching cleanup within the same scope.<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fs.zig">fs.zig</link></simpara>
</listitem>
<listitem>
<simpara>Give each public error union a dedicated formatter so documentation and user messaging never drift apart.<link xl:href="36__style-and-best-practices.xml">36</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>Merging error sets with <literal>||</literal> preserves tags but not payload data; if you need structured payloads, reach for tagged unions instead.</simpara>
</listitem>
<listitem>
<simpara>Allocator-backed helpers should surface <literal>std.mem.Allocator.Error</literal> directly—callers expect to <literal>try</literal> allocations just like standard library containers.</simpara>
</listitem>
<listitem>
<simpara>The recipes here assume debug or release-safe builds; in release-fast you may want additional logging for branches that would otherwise fire <literal>unreachable</literal>.<link xl:href="37__illegal-behavior-and-safety-modes.xml">37</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Extend <literal>loadPort</literal> so it returns a structured configuration object with both host and port, then enumerate the resulting composite error set.<link xl:href="04__errors-resource-cleanup.xml">4</link></simpara>
</listitem>
<listitem>
<simpara>Add a streaming variant of <literal>joinUpperSnippets</literal> that writes to a user-supplied writer instead of allocating, and compare its ergonomics.<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Io.zig">Io.zig</link></simpara>
</listitem>
<listitem>
<simpara>Teach <literal>runAndReport</literal> to redact identifiers before logging by injecting a formatter callback—verify with unit tests that both success and failure paths respect the hook.<link xl:href="36__style-and-best-practices.xml">36</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Alternatives &amp; Edge Cases</title>
<itemizedlist>
<listitem>
<simpara>For long-running services, consider wrapping retry loops with exponential backoff and jitter; Chapter 29 revisits the concurrency implications.<link xl:href="29__threads-and-atomics.xml">29</link></simpara>
</listitem>
<listitem>
<simpara>If your error bridge needs localization, store message IDs alongside the error tags and let higher layers format the final string.</simpara>
</listitem>
<listitem>
<simpara>Embedded targets with tiny allocators may prefer stack-based buffers or fixed <literal>std.BoundedArray</literal> instances over heap-backed arrays to avoid <literal>OutOfMemory</literal>.<link xl:href="10__allocators-and-memory-management.xml">10</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>