////
changes: ["New chapter: Generic APIs & Type Erasure (verbose, in-depth)", "Added runnable demos for comptime contracts, anytype wrappers, and runtime vtables"]
examples_compile: yes
keywords: ["generic", "anytype", "type erasure", "@hasDecl", "anyopaque"]
last_updated: 2025-11-03
last_verified: 2025-11-03
next_chapter: "18__project-generic-priority-queue"
open_questions: []
previous_chapter: "16__project-table-generator"
status: draft
xref_complete: true
////

= Generic APIs & Type Erasure
:chapter-number: 17
:chapter-slug: generic-apis-and-type-erasure
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Generics in Zig are nothing more than regular functions parameterized by `comptime` values, yet this simplicity hides a remarkable amount of expressive power. In this chapter, we turn the reflective techniques from xref:15__comptime-and-reflection.adoc[15] into disciplined API design patterns: structuring capability contracts, forwarding concrete types with `anytype`, and keeping the call sites ergonomic without sacrificing correctness.

We also cover the opposite end of the spectrum—runtime type erasure—where opaque pointers and handwritten vtables let you store heterogeneous behavior in uniform containers. These techniques complement the lookup-table generation from xref:16__project-table-generator.adoc[16] and prepare us for the fully generic priority queue project that follows. For release notes, see link:https://ziglang.org/download/0.15.1/release-notes.html[v0.15.2].

[[learning-goals]]
== Learning Goals

* Build compile-time contracts that validate user-supplied types before code generation, delivering clear diagnostics.
* Wrap arbitrary writers and strategies with `anytype`, preserving zero-cost abstractions while keeping call sites tidy. See link:https://github.com/ziglang/zig/tree/master/lib/std/io/Writer.zig[Writer.zig].
* Apply `anyopaque` pointers and explicit vtables to erase types safely, aligning state and handling lifetimes without undefined behavior.

[[comptime-contracts]]
== Comptime contracts as interfaces

A Zig function becomes generic the moment it accepts a `comptime` parameter. By pairing that flexibility with capability checks—`@hasDecl`, `@TypeOf`, or even custom predicates—you can encode rich structural interfaces without heavyweight trait systems. xref:15__comptime-and-reflection.adoc[15] We start by seeing how a metric aggregator contract pushes errors to compile time instead of relying on runtime assertions.

[[contracts-validate]]
=== Validating structural requirements

`computeReport` below accepts an analyzer type that must expose `State`, `Summary`, `init`, `observe`, and `summarize`. The `validateAnalyzer` helper makes these requirements explicit; forgetting a method gives a precise `@compileError` instead of a mysterious instantiation failure. We demonstrate the pattern with a `RangeAnalyzer` and a `MeanVarianceAnalyzer`.

[source,zig]
----
include::{sourcedir}/17__generic-apis-and-type-erasure/comptime_contract.zig[]
----

.Run
[source,shell]
----
$ zig run chapters-data/code/17__generic-apis-and-type-erasure/comptime_contract.zig
----

.Output
[source,shell]
----
Range -> min=21.00 max=24.00 spread=3.00
Mean/variance -> mean=22.70 variance=1.124
----

TIP: The contract remains zero-cost: once validated, the analyzer methods inline as if you had written specialized code, while still surfacing readable diagnostics for downstream users. 

[[contracts-diagnostics]]
=== Diagnosing capability gaps

Because `validateAnalyzer` centralizes the checks, you can extend the interface over time—by requiring `pub const SummaryFmt = []const u8`, for instance—without touching every call site. When an adopter upgrades and misses a new declaration, the compiler reports exactly which requirement is absent. This “fail fast, fail specific” strategy scales especially well for internal frameworks and prevents silent drift between modules. xref:36__style-and-best-practices.adoc[37]

[[contracts-tradeoffs]]
=== Trade-offs and batching considerations

Keep contract predicates cheap. Anything more than a handful of `@hasDecl` checks or straightforward type comparisons should be factored behind an opt-in feature flag or cached in a `comptime var`. Heavy analysis in a widely-instantiated helper quickly balloons compile times—profile with `zig build --verbose-cc` if a generic takes longer than expected. xref:38__zig-cli-deep-dive.adoc[40]

[[contracts-internpool]]
=== Under the hood: InternPool and generic instances

When `computeReport` is instantiated with a concrete analyzer, the compiler resolves all of the involved types and values through a shared `InternPool`. This structure guarantees that each unique analyzer `State`, `Summary`, and function type has a single canonical identity before code generation.

[mermaid]
....
graph TB
	IP["InternPool"]

	subgraph "Threading"
		LOCALS["locals: []Local<br/>(one per thread)"]
		SHARDS["shards: []Shard<br/>(concurrent writes)"]
		TIDWIDTH["tid_width / tid_shift_*"]
	end

	subgraph "Core Storage"
		ITEMS["items: []Item"]
		EXTRADATA["extra_data: []u32"]
		STRINGS["string_bytes"]
		LIMBS["limbs: []Limb"]
	end

	subgraph "Dependency Tracking"
		SRCHASHDEPS["src_hash_deps"]
		NAVVALDEPS["nav_val_deps"]
		NAVTYDEPS["nav_ty_deps"]
		INTERNEDDEPS["interned_deps"]
	end

	subgraph "Symbol Tables"
		NAVS["navs: []Nav"]
		NAMESPACES["namespaces: []Namespace"]
		CAUS["caus: []Cau"]
	end

	subgraph "Special Indices"
		NONE["Index.none"]
		UNREACHABLE["Index.unreachable_value"]
		TYPEINFO["Index.type_info_type"]
		ANYERROR["Index.anyerror_type"]
	end

	IP --> LOCALS
	IP --> SHARDS
	IP --> TIDWIDTH
	IP --> ITEMS
	IP --> EXTRADATA
	IP --> STRINGS
	IP --> LIMBS
	IP --> SRCHASHDEPS
	IP --> NAVVALDEPS
	IP --> NAVTYDEPS
	IP --> INTERNEDDEPS
	IP --> NAVS
	IP --> NAMESPACES
	IP --> CAUS
	IP --> NONE
	IP --> UNREACHABLE
	IP --> TYPEINFO
	IP --> ANYERROR
....

Key properties:

* Content-addressed storage: Each unique type/value is stored once, identified by an `Index`.
* Thread-safe: `shards` allow concurrent writes via fine-grained locking.
* Dependency tracking: Maps from source hashes, Navs, and interned values to dependent analysis units.
* Special values: Pre-allocated indices for common types like `anyerror_type`, `type_info_type`, etc.

[[anytype-forwarding]]
== Forwarding with `anytype` wrappers

Once you trust the capabilities of a concrete type, you often want to wrap or adapt it without reifying a trait object. `anytype` is the perfect tool: it copies the concrete type into the wrapper’s signature, preserving monomorphized performance while allowing you to build chains of decorators. xref:15__comptime-and-reflection.adoc[15] The next example shows a reusable “prefixed writer” that works equally well for fixed buffers and growable lists.

[[anytype-wrapper]]
=== A reusable prefixed writer

We fabricate two sinks: a fixed-buffer stream from the reorganized `std.Io` namespace and a heap-backed `ArrayList` wrapper with its own `GenericWriter`. `withPrefix` captures their concrete writer types via `@TypeOf`, returning a struct whose `print` method prepends a label before forwarding to the inner writer.

[source,zig]
----
include::{sourcedir}/17__generic-apis-and-type-erasure/prefixed_writer.zig[]
----

.Run
[source,shell]
----
$ zig run chapters-data/code/17__generic-apis-and-type-erasure/prefixed_writer.zig
----

.Output
[source,shell]
----
Fixed buffer stream captured:
[stream] value = 42
[stream] tuple = .{ 1, 2, 3 }
ArrayList writer captured:
[array] flags = .{ true, false }
[array] label = generic
----

NOTE: `std.Io.fixedBufferStream` and `std.io.GenericWriter` were both polished in Zig 0.15.2 to emphasize explicit writer contexts, which is why we pass the allocator into `ListSink.writer()` each time. link:https://github.com/ziglang/zig/tree/master/lib/std/Io/fixed_buffer_stream.zig[fixed_buffer_stream.zig]

[[anytype-guardrails]]
=== Guardrails for `anytype`

Prefer `anytype` in helpers that merely forward calls; export public APIs with explicit `comptime T: type` parameters so that documentation and tooling stay honest. If a wrapper accepts `anytype` but inspects `@TypeInfo` deeply, document the expectation and consider moving the predicate into a reusable validator like we did with analyzers. That way a future refactor can upgrade the constraint without rewriting the wrapper. xref:36__style-and-best-practices.adoc[37]

[[anytype-meta]]
=== `std.meta` helpers for structural contracts

When an `anytype` wrapper needs to understand the shape of the value it is forwarding, `std.meta` offers small, composable "view" functions. They are used pervasively in the standard library to implement generic helpers that adapt to arrays, slices, optionals, and unions at compile time.

[mermaid]
....
graph TB
	subgraph "Type Extractors"
		CHILD["Child(T)"]
		ELEM["Elem(T)"]
		SENTINEL["sentinel(T)"]
		TAG["Tag(T)"]
		ACTIVETAG["activeTag(union)"]
	end

	subgraph "Input Types"
		ARRAY["array"]
		VECTOR["vector"]
		POINTER["pointer"]
		OPTIONAL["optional"]
		UNION["union"]
		ENUM["enum"]
	end

	ARRAY --> CHILD
	VECTOR --> CHILD
	POINTER --> CHILD
	OPTIONAL --> CHILD

	ARRAY --> ELEM
	VECTOR --> ELEM
	POINTER --> ELEM

	ARRAY --> SENTINEL
	POINTER --> SENTINEL

	UNION --> TAG
	ENUM --> TAG
	UNION --> ACTIVETAG
....

Key type extraction functions:

* `Child(T)`: Extracts the child type from arrays, vectors, pointers, and optionals (see link:https://github.com/ziglang/zig/tree/master/lib/std/meta.zig#L83-91[meta.zig:83-91]).
* `Elem(T)`: Gets the element type from memory span types (see link:https://github.com/ziglang/zig/tree/master/lib/std/meta.zig#L102-118[meta.zig:102-118]).
* `sentinel(T)`: Returns the sentinel value, if present (see link:https://github.com/ziglang/zig/tree/master/lib/std/meta.zig#L134-150[meta.zig:134-150]).
* `Tag(T)`: Gets the tag type from enums and unions (see link:https://github.com/ziglang/zig/tree/master/lib/std/meta.zig#L628-634[meta.zig:628-634]).
* `activeTag(u)`: Returns the active tag of a union value (see link:https://github.com/ziglang/zig/tree/master/lib/std/meta.zig#L651-654[meta.zig:651-654]).

[[anytype-inline]]
=== Inline costs and specialization

Each distinct concrete writer instantiates a fresh copy of the wrapper. Use this to your advantage—attach comptime-known prefixes, bake in field offsets, or gate an `inline for` that only triggers for tiny objects. If the wrapper might be applied to dozens of types, double-check code size with `zig build-exe -femit-bin=` to avoid bloating binaries. xref:39__performance-and-inlining.adoc[41]

[[type-erasure]]
== Runtime type erasure with vtables

Sometimes you need to hold a heterogeneous set of strategies at runtime: logging backends, diagnostics passes, or data sinks discovered via configuration. Zig’s answer is explicit vtables containing function pointers plus `*anyopaque` state that you allocate yourself. The compiler stops enforcing structure, so it becomes your responsibility to maintain alignment, lifetime, and error propagation. 

[[erasure-demo]]
=== Typed state, erased handles

The registry below manages two text processors. Each factory allocates a strongly-typed state, casts it to `*anyopaque`, and stores it alongside a vtable of function pointers. Helper functions `statePtr` and `stateConstPtr` recover the original types with `@alignCast`, ensuring we never violate alignment requirements.

[source,zig]
----
include::{sourcedir}/17__generic-apis-and-type-erasure/type_erasure_registry.zig[]
----

.Run
[source,shell]
----
$ zig run chapters-data/code/17__generic-apis-and-type-erasure/type_erasure_registry.zig
----

.Output
[source,shell]
----
[char-tally] vowels=30 digits=0
[word-stats] chars=97 sentences=2 longest-word=10
----

IMPORTANT: Keep track of lifetimes—the arena allocator outlives the processors, so the erased pointers stay valid. Switching to a scoped allocator would require a matching `destroy` hook in the vtable to avoid dangling pointers. xref:10__allocators-and-memory-management.adoc[10], link:https://github.com/ziglang/zig/tree/master/lib/std/mem/Allocator.zig[Allocator.zig]

[[erasure-allocator-vtable]]
=== Standard allocator as a vtable case study

The standard library's `std.mem.Allocator` is itself a type-erased interface: every allocator implementation provides a concrete state pointer plus a vtable of function pointers. This mirrors the registry pattern above but in a form that the entire ecosystem relies on.

[mermaid]
....
graph TB
	ALLOC["Allocator"]
	PTR["ptr: *anyopaque"]
	VTABLE["vtable: *VTable"]

	ALLOC --> PTR
	ALLOC --> VTABLE

	subgraph "VTable Functions"
		ALLOCFN["alloc(*anyopaque, len, alignment, ret_addr)"]
		RESIZEFN["resize(*anyopaque, memory, alignment, new_len, ret_addr)"]
		REMAPFN["remap(*anyopaque, memory, alignment, new_len, ret_addr)"]
		FREEFN["free(*anyopaque, memory, alignment, ret_addr)"]
	end

	VTABLE --> ALLOCFN
	VTABLE --> RESIZEFN
	VTABLE --> REMAPFN
	VTABLE --> FREEFN

	subgraph "High-Level API"
		CREATE["create(T)"]
		DESTROY["destroy(ptr)"]
		ALLOCAPI["alloc(T, n)"]
		FREE["free(slice)"]
		REALLOC["realloc(slice, new_len)"]
	end

	ALLOC --> CREATE
	ALLOC --> DESTROY
	ALLOC --> ALLOCAPI
	ALLOC --> FREE
	ALLOC --> REALLOC
....

The `Allocator` type is defined in link:https://github.com/ziglang/zig/tree/master/lib/std/mem/Allocator.zig#L7-20[Allocator.zig:7-20] as a type-erased interface with a pointer and vtable. The vtable contains four fundamental operations:

* `alloc`: Returns a pointer to `len` bytes with the specified alignment, or null on failure (see link:https://github.com/ziglang/zig/tree/master/lib/std/mem/Allocator.zig#L29[Allocator.zig:29]).
* `resize`: Attempts to expand or shrink memory in place (see link:https://github.com/ziglang/zig/tree/master/lib/std/mem/Allocator.zig#L48[Allocator.zig:48]).
* `remap`: Attempts to expand or shrink memory, allowing relocation (see link:https://github.com/ziglang/zig/tree/master/lib/std/mem/Allocator.zig#L69[Allocator.zig:69]).
* `free`: Frees and invalidates a region of memory (see link:https://github.com/ziglang/zig/tree/master/lib/std/mem/Allocator.zig#L81[Allocator.zig:81]).

[[erasure-safety]]
=== Safety notes for `anyopaque`

`anyopaque` has a declared alignment of one, so every downcast must assert the true alignment with `@alignCast`. Skipping that assertion is illegal behavior even if the pointer happens to be properly aligned at runtime. Consider stashing the allocator and a cleanup function inside the vtable when ownership spans multiple modules.

[[erasure-interop]]
=== When to graduate to modules or packages

Manual vtables shine for small, closed sets of behaviors. As soon as the surface area grows, migrate to a module-level registry that exposes constructors returning typed handles. Consumers still receive erased pointers, but the module can enforce invariants and share helper code for alignment, cleanup, and panic diagnostics. xref:19__modules-and-imports-root-builtin-discovery.adoc[19]

[[notes-caveats]]
== Notes & Caveats

* Favor small, intention-revealing validator helpers—long `validateX` functions are ripe for extraction into reusable comptime utilities. xref:15__comptime-and-reflection.adoc[15]
* `anytype` wrappers generate one instantiation per concrete type. Profile binary size when exposing them in widely-used libraries. xref:39__performance-and-inlining.adoc[41]
* Type erasure pushes correctness to the programmer. Add assertions, logging, or debug toggles in development builds to prove that downcasts and lifetimes remain valid. xref:37__illegal-behavior-and-safety-modes.adoc[39]

[[exercises]]
== Exercises

* Extend `validateAnalyzer` to require an optional `summarizeError` function and demonstrate custom error sets in a test. xref:13__testing-and-leak-detection.adoc[13]
* Add a `flush` capability to `PrefixedWriter`, detecting at comptime whether the inner writer exposes the method and adapting accordingly. link:https://github.com/ziglang/zig/tree/master/lib/std/meta.zig[meta.zig]
* Introduce a third processor that streams hashes into a `std.crypto.hash.sha2.Sha256` context, then prints the digest in hex when finished. xref:50__random-and-math.adoc[52], link:https://github.com/ziglang/zig/tree/master/lib/std/crypto/sha2.zig[sha2.zig]

[[caveats-alternatives-edge-cases]]
== Alternatives & Edge Cases

* If compile-time validation depends on user-supplied types from other packages, add smoke tests so regressions surface before integration builds. xref:22__build-system-deep-dive.adoc[22]
* Prefer `union(enum)` with payloaded variants when only a handful of strategies exist; vtables pay off once you cross from “few” to “many.” xref:08__user-types-structs-enums-unions.adoc[08]
* For plug-in systems loaded from shared objects, pair erased state with explicit ABI-safe trampolines to keep portability manageable. xref:33__c-interop-import-export-abi.adoc[33]
