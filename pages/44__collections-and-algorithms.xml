<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Collections and Algorithms</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>With the stdlib index providing your map, you now dive into Zig&#8217;s collection types—the workhorses of data manipulation. This chapter explores dynamic arrays (<literal>ArrayList</literal>), hash tables (<literal>HashMap</literal> and variants), priority structures (<literal>PriorityQueue</literal>), linked lists, specialized containers like <literal>MultiArrayList</literal> and <literal>SegmentedList</literal>, and sorting algorithms (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/array_list.zig">array_list.zig</link> and <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/hash_map.zig">hash_map.zig</link>). Each collection embraces Zig&#8217;s explicit allocator model, giving you control over memory lifetime and enabling leak detection during testing.</simpara>
<simpara>Unlike languages with implicit garbage collection, Zig collections require you to <literal>deinit()</literal> or transfer ownership explicitly. This discipline, combined with the standard library&#8217;s rich suite of adapters (unmanaged variants, sentinel-aware slices, custom contexts), makes collections both powerful and predictable. By chapter&#8217;s end, you&#8217;ll confidently choose the right structure for your use case and understand the performance trade-offs inherent in each design (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/sort.zig">sort.zig</link>).</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Use <literal>ArrayList(T)</literal> for dynamic arrays: append, insert, remove, iterate, and understand reallocation strategies.</simpara>
</listitem>
<listitem>
<simpara>Employ <literal>HashMap</literal> and <literal>AutoHashMap</literal> for key-value lookups with custom hash and equality functions.</simpara>
</listitem>
<listitem>
<simpara>Leverage <literal>PriorityQueue</literal> for min/max heap operations and understand comparison contexts (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/priority_queue.zig">priority_queue.zig</link>).</simpara>
</listitem>
<listitem>
<simpara>Apply <literal>std.sort</literal> for in-place sorting with stable and unstable algorithms (pdqsort, block sort, insertion sort).</simpara>
</listitem>
<listitem>
<simpara>Recognize specialized structures: <literal>MultiArrayList</literal> for structure-of-arrays layout, <literal>SegmentedList</literal> for stable pointers, linked lists for intrusive designs (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/multi_array_list.zig">multi_array_list.zig</link> and <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/segmented_list.zig">segmented_list.zig</link>).</simpara>
</listitem>
<listitem>
<simpara>Appreciate allocator impact: how collection growth triggers reallocation and how arenas simplify bulk-free patterns (see <link xl:href="10__allocators-and-memory-management.xml">10</link>).</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="arraylist">
<title>ArrayList: Dynamic Arrays</title>
<simpara><literal>ArrayList(T)</literal> is Zig&#8217;s foundational growable array, analogous to C++'s <literal>std::vector</literal> or Rust&#8217;s <literal>Vec&lt;T&gt;</literal>. It manages a contiguous slice of <literal>T</literal> values, expanding capacity as needed. You interact with <literal>.items</literal> (the current slice) and call methods like <literal>append</literal>, <literal>pop</literal>, <literal>insert</literal>, and <literal>remove</literal>.</simpara>
<section xml:id="arraylist-basics">
<title>Basic Operations</title>
<simpara>Create an <literal>ArrayList</literal> by specifying the element type and passing an allocator. Call <literal>deinit()</literal> when done to free the backing memory.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/arraylist_basic.zig[]</programlisting>
<formalpara>
<title>Build</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe arraylist_basic.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ ./arraylist_basic</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Item 0: 10
Item 1: 20
Item 2: 30
Popped: 30
Remaining length: 2</programlisting>
</para>
</formalpara>
<tip>
<simpara><literal>ArrayList</literal> doubles capacity when full (exponential growth), amortizing reallocation cost. You can pre-allocate with <literal>try list.ensureTotalCapacity(allocator, n)</literal> if you know the final size.</simpara>
</tip>
</section>
<section xml:id="arraylist-ownership">
<title>Ownership and Unmanaged Variants</title>
<simpara>By default, <literal>ArrayList(T)</literal> stores its allocator internally (managed variant). For more explicit control, use the unmanaged form by accessing <literal>.items</literal> and <literal>.capacity</literal> directly, or use the deprecated <literal>Unmanaged</literal> APIs. The modern pattern is to use the simpler managed form unless you need to decouple allocation from the list itself.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/arraylist_ownership.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe arraylist_ownership.zig &amp;&amp; ./arraylist_ownership</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Managed list length: 3
After transfer, original list length: 0
Owned slice length: 3</programlisting>
</para>
</formalpara>
<note>
<simpara><literal>toOwnedSlice()</literal> empties the list and returns the backing memory as a slice—you become responsible for freeing it with <literal>allocator.free(slice)</literal>.</simpara>
</note>
</section>
<section xml:id="arraylist-insertion-removal">
<title>Insertion and Removal</title>
<simpara>Beyond <literal>append</literal> and <literal>pop</literal>, <literal>ArrayList</literal> supports mid-array operations. <literal>orderedRemove</literal> maintains element order (shifts subsequent elements), while <literal>swapRemove</literal> is O(1) but doesn&#8217;t preserve order (swaps with the last element).</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/arraylist_insert_remove.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe arraylist_insert_remove.zig &amp;&amp; ./arraylist_insert_remove</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">After insert at 1: [1, 99, 2, 3, 4]
After orderedRemove at 2: [1, 99, 3, 4]
After swapRemove at 1: [1, 4, 3]</programlisting>
</para>
</formalpara>
<important>
<simpara><literal>orderedRemove</literal> is O(n) in the worst case (removing the first element requires shifting all others); use <literal>swapRemove</literal> when order doesn&#8217;t matter for O(1) performance.</simpara>
</important>
</section>
</chapter>
<chapter xml:id="hashmap">
<title>HashMap: Key-Value Lookups</title>
<simpara>Zig&#8217;s hash map family provides O(1) average-case lookups via open addressing and linear probing. <literal>HashMap(K, V, Context, max_load_percentage)</literal> requires a context with <literal>hash</literal> and <literal>eql</literal> functions. For convenience, <literal>AutoHashMap</literal> auto-generates these for hashable types, and <literal>StringHashMap</literal> specializes for <literal>[]const u8</literal> keys.</simpara>
<section xml:id="hashmap-basic">
<title>StringHashMap Basics</title>
<simpara>For string keys (<literal>[]const u8</literal>), use <literal>StringHashMap(V)</literal> which provides optimized string hashing. Note that <literal>AutoHashMap</literal> does not support slice types like <literal>[]const u8</literal> to avoid ambiguity—use <literal>StringHashMap</literal> instead.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/hashmap_basic.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe hashmap_basic.zig &amp;&amp; ./hashmap_basic</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Value for 'foo': 42
Contains 'bar': true
Contains 'baz': false
After removing 'foo', contains: false</programlisting>
</para>
</formalpara>
<tip>
<simpara>Use <literal>put</literal> to insert or update, <literal>get</literal> to retrieve (returns <literal>?V</literal>), and <literal>remove</literal> to delete. Check existence with <literal>contains</literal> without retrieving the value.</simpara>
</tip>
</section>
<section xml:id="hashmap-string">
<title>StringHashMap for String Keys</title>
<simpara>When keys are <literal>[]const u8</literal>, use <literal>StringHashMap(V)</literal> for optimized string hashing. Remember: the map doesn&#8217;t copy key memory—you must ensure strings outlive the map or use an arena allocator.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/hashmap_string.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe hashmap_string.zig &amp;&amp; ./hashmap_string</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">City: Seattle, Population: 750000
City: Austin, Population: 950000
City: Boston, Population: 690000</programlisting>
</para>
</formalpara>
<important>
<simpara>String keys are not duplicated by the map—if you pass stack-allocated or temporary strings, they must remain valid. Use an arena allocator or <literal>dupe</literal> to manage key lifetimes.</simpara>
</important>
</section>
<section xml:id="hashmap-custom">
<title>Custom Hash and Equality</title>
<simpara>For types not supported by <literal>autoHash</literal>, define a context with custom <literal>hash</literal> and <literal>eql</literal> functions.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/hashmap_custom.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe hashmap_custom.zig &amp;&amp; ./hashmap_custom</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Point(10, 20): Alice
Point(30, 40): Bob
Contains (10, 20): true</programlisting>
</para>
</formalpara>
<note>
<simpara>The context parameter in <literal>HashMap(K, V, Context, max_load_percentage)</literal> allows stateful hashing (e.g., salted hashes). For stateless contexts, pass <literal>void</literal>.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="priorityqueue">
<title>PriorityQueue: Heap-Based Priority Structures</title>
<simpara><literal>PriorityQueue(T, Context, compareFn)</literal> implements a binary min-heap or max-heap depending on your comparison function. It supports <literal>add</literal>, <literal>peek</literal>, <literal>remove</literal> (pop the top element), and <literal>removeIndex</literal>.</simpara>
<section xml:id="priorityqueue-basic">
<title>Min-Heap Example</title>
<simpara>A min-heap pops the smallest element first. The comparison function returns <literal>.lt</literal> when the first argument should come before the second.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/priorityqueue_min.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe priorityqueue_min.zig &amp;&amp; ./priorityqueue_min</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Popped: 1
Popped: 5
Popped: 10
Popped: 20</programlisting>
</para>
</formalpara>
<tip>
<simpara>For a max-heap, reverse the comparison logic: return <literal>.gt</literal> when <literal>a &lt; b</literal>.</simpara>
</tip>
</section>
<section xml:id="priorityqueue-tasks">
<title>Priority Queue for Task Scheduling</title>
<simpara>Priority queues excel at scheduling: add tasks with priorities, then always process the highest-priority task first.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/priorityqueue_tasks.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe priorityqueue_tasks.zig &amp;&amp; ./priorityqueue_tasks</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Processing: Critical bug (priority 10)
Processing: Feature request (priority 5)
Processing: Documentation (priority 1)</programlisting>
</para>
</formalpara>
<note>
<simpara><literal>PriorityQueue</literal> uses a heap internally, so <literal>add</literal> is O(log n), <literal>peek</literal> is O(1), and <literal>remove</literal> is O(log n).</simpara>
</note>
</section>
</chapter>
<chapter xml:id="sorting">
<title>Sorting</title>
<simpara>Zig&#8217;s <literal>std.sort</literal> module provides multiple algorithms: <literal>insertion</literal> (stable, O(n²)), <literal>heap</literal> (unstable, O(n log n)), <literal>pdq</literal> (pattern-defeating quicksort, O(n log n) worst-case), and <literal>block</literal> (stable, O(n log n) with extra memory). The default recommendation is <literal>pdq</literal> for most use cases.</simpara>
<section xml:id="sort-basic">
<title>Basic Sorting</title>
<simpara>Call <literal>std.sort.pdq</literal> with a slice, a context, and a <literal>lessThan</literal> function.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/sort_basic.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe sort_basic.zig &amp;&amp; ./sort_basic</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Sorted ascending: [1, 2, 5, 8, 10]
Sorted descending: [10, 8, 5, 2, 1]</programlisting>
</para>
</formalpara>
<tip>
<simpara><literal>pdq</literal> is unstable but fast. Use <literal>block</literal> if you need stability (equal elements retain their original order).</simpara>
</tip>
</section>
<section xml:id="sort-structs">
<title>Sorting Structs</title>
<simpara>Sort by struct fields by providing a custom comparison function.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/sort_structs.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe sort_structs.zig &amp;&amp; ./sort_structs</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Sorted by age:
Alice, age 30
Bob, age 25
Charlie, age 35</programlisting>
</para>
</formalpara>
<note>
<simpara>The context parameter in sorting functions can hold state (e.g., sort direction flags or comparison modifiers). Use <literal>anytype</literal> for flexibility.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="multiarraylist">
<title>MultiArrayList: Structure-of-Arrays Layout</title>
<simpara><literal>MultiArrayList(T)</literal> stores structs in a structure-of-arrays (SoA) format: each field is stored in its own contiguous array, improving cache locality when accessing individual fields across many elements.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/multiarraylist.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe multiarraylist.zig &amp;&amp; ./multiarraylist</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Entity 0: id=1, x=10.5, y=20.3
Entity 1: id=2, x=30.1, y=40.7
Sum of x coordinates: 40.6</programlisting>
</para>
</formalpara>
<tip>
<simpara>Use <literal>MultiArrayList</literal> when you frequently iterate over a single field (e.g., positions in a game engine) but rarely need the entire struct. This layout maximizes CPU cache efficiency.</simpara>
</tip>
</chapter>
<chapter xml:id="segmentedlist">
<title>SegmentedList: Stable Pointers</title>
<simpara><literal>SegmentedList(T, prealloc_item_count)</literal> grows by allocating fixed-size segments rather than reallocating a single contiguous array. This ensures pointers to elements remain valid across insertions.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/segmentedlist.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe segmentedlist.zig &amp;&amp; ./segmentedlist</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">First item: 10
First item (after append): 10
List length: 3</programlisting>
</para>
</formalpara>
<important>
<simpara>Unlike <literal>ArrayList</literal>, pointers to <literal>SegmentedList</literal> elements remain valid even as you add more items. Use this when you need stable addressing (e.g., storing pointers in other data structures).</simpara>
</important>
</chapter>
<chapter xml:id="linkedlists">
<title>Linked Lists</title>
<simpara>Zig provides <literal>DoublyLinkedList(T)</literal> and <literal>SinglyLinkedList(T)</literal> as intrusive linked lists: nodes embed the link pointers directly (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/DoublyLinkedList.zig">DoublyLinkedList.zig</link> and <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/SinglyLinkedList.zig">SinglyLinkedList.zig</link>). This avoids allocator overhead per node and integrates naturally with existing structs.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/linkedlist.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe linkedlist.zig &amp;&amp; ./linkedlist</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Node: 10
Node: 20
Node: 30</programlisting>
</para>
</formalpara>
<note>
<simpara>Intrusive lists don&#8217;t own node memory—you allocate and manage nodes yourself. This is powerful but requires discipline to avoid use-after-free bugs.</simpara>
</note>
</chapter>
<chapter xml:id="specialized-maps">
<title>Specialized Maps</title>
<section xml:id="_arrayhashmap">
<title>ArrayHashMap</title>
<simpara><literal>ArrayHashMap</literal> stores keys and values in separate arrays, preserving insertion order and enabling iteration by index (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/array_hash_map.zig">array_hash_map.zig</link>).</simpara>
</section>
<section xml:id="_staticstringmap">
<title>StaticStringMap</title>
<simpara><literal>StaticStringMap(V)</literal> is a compile-time perfect hash map for string keys—fast lookups with zero runtime allocation or hashing overhead (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/static_string_map.zig">static_string_map.zig</link>).</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/static_string_map.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe static_string_map.zig &amp;&amp; ./static_string_map</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Status code for 'ok': 200
Status code for 'not_found': 404
Status code for 'server_error': 500</programlisting>
</para>
</formalpara>
<tip>
<simpara>Use <literal>StaticStringMap</literal> for compile-time constant mappings (e.g., keyword tables, command parsers). It compiles to optimal switch statements or lookup tables.</simpara>
</tip>
</section>
</chapter>
<chapter xml:id="allocator-impact">
<title>Allocator Impact on Collections</title>
<simpara>Every collection requires an allocator, either passed at initialization (<literal>ArrayList(T).init(allocator)</literal>) or per operation (unmanaged variants). Growth strategies trigger reallocations, and failure returns <literal>error.OutOfMemory</literal> (see <link xl:href="10__allocators-and-memory-management.xml">10</link>).</simpara>
<section xml:id="arena-pattern">
<title>Arena Pattern for Bulk-Free</title>
<simpara>When building temporary collections that live for a single scope, use an arena allocator to free everything at once.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 44__collections-and-algorithms.adoc - include::example$chapters-data/code/44__collections-and-algorithms/collections_arena.zig[]</programlisting>
<formalpara>
<title>Build and Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build-exe collections_arena.zig &amp;&amp; ./collections_arena</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">List has 1000 items
Map has 500 entries
All freed at once via arena.deinit()</programlisting>
</para>
</formalpara>
<note>
<simpara>The arena doesn&#8217;t call individual collection <literal>deinit()</literal> methods. It frees all memory at once. Use this pattern when you know collections won&#8217;t outlive the arena&#8217;s scope (see <link xl:href="10__allocators-and-memory-management.xml">10</link>).</simpara>
</note>
</section>
</chapter>
<chapter xml:id="performance-considerations">
<title>Performance Considerations</title>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">ArrayList growth</emphasis>: Doubling capacity amortizes reallocation cost, but large allocations may fail. Pre-allocate if size is known.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">HashMap load factor</emphasis>: Default <literal>max_load_percentage</literal> is 80%. Higher values save memory but increase collision chains.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Sort stability</emphasis>: <literal>pdq</literal> is fastest but unstable. Use <literal>block</literal> or <literal>insertion</literal> when order of equal elements matters.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">MultiArrayList cache</emphasis>: SoA layout shines when iterating single fields but adds indirection overhead for full-struct access.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">SegmentedList segments</emphasis>: Smaller <literal>prealloc_item_count</literal> means more segments (more allocations); larger values waste memory if lists stay small.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Implement a <literal>FrequencyMap</literal> using <literal>StringHashMap(u32)</literal> that counts word occurrences in a text file, then print the top-10 most frequent words using a <literal>PriorityQueue</literal>.</simpara>
</listitem>
<listitem>
<simpara>Compare <literal>ArrayList</literal> vs <literal>SegmentedList</literal> performance: create 10,000 items, take pointers to the first 100, then append 10,000 more. Verify pointers remain valid with <literal>SegmentedList</literal> but may invalidate with <literal>ArrayList</literal>.</simpara>
</listitem>
<listitem>
<simpara>Write an <literal>LRU</literal> cache using <literal>HashMap</literal> for lookups and <literal>DoublyLinkedList</literal> for eviction order. When capacity is reached, remove the least-recently-used item.</simpara>
</listitem>
<listitem>
<simpara>Sort an <literal>ArrayList</literal> of structs by multiple keys (e.g., sort by <literal>age</literal>, then by <literal>name</literal> for ties) using a custom comparator and <literal>std.sort.pdq</literal>.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Caveats, Alternatives, Edge Cases</title>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Unmanaged variants</emphasis>: Most collections have unmanaged counterparts (e.g., <literal>ArrayListUnmanaged(T)</literal>) for manual allocator threading, useful in generic code or when embedding collections in structs.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">HashMap key lifetimes</emphasis>: Maps don&#8217;t duplicate keys. Ensure key memory outlives the map, or use an arena allocator to manage key storage collectively.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Iterator invalidation</emphasis>: Like C++, modifying a collection (append, remove) may invalidate iterators or pointers to elements. Always check documentation for each operation.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Stable vs unstable sort</emphasis>: If your data has equal elements that must maintain relative order (e.g., sorting a table by column but preserving row order for ties), use <literal>std.sort.block</literal> or <literal>insertion</literal>, not <literal>pdq</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Treap</emphasis>: Zig also provides <literal>std.Treap</literal>, a tree-heap hybrid for ordered maps with probabilistic balancing, useful when you need both sorted iteration and O(log n) operations (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/treap.zig">treap.zig</link>).</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>