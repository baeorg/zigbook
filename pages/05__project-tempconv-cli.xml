<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Project</title>
<subtitle>TempConv CLI</subtitle>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Our first project turns the language fundamentals from Chapters 1–4 into a handheld command-line utility that converts temperatures between Celsius, Fahrenheit, and Kelvin. We compose argument parsing, enums, and floating-point math into a single program while keeping diagnostics friendly for end users, as described in <link xl:href="https://ziglang.org/documentation/master/#Command-line-flags">#Command-line-flags</link> and <link xl:href="https://ziglang.org/documentation/master/#Floats">#Floats</link>.</simpara>
<simpara>Along the way, we reinforce the error-handling philosophy from the previous chapter: validation produces human-readable hints, and the process exits with intent instead of a stack trace; see <link xl:href="https://ziglang.org/documentation/master/#Error-Handling">#Error-Handling</link>.</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Build a minimal CLI harness that reads arguments, handles <literal>--help</literal>, and emits usage guidance.</simpara>
</listitem>
<listitem>
<simpara>Represent temperature units with enums and use <literal>switch</literal> to normalise conversions, as described in <link xl:href="https://ziglang.org/documentation/master/#switch">#switch</link>.</simpara>
</listitem>
<listitem>
<simpara>Present conversion results while surfacing validation failures through concise diagnostics instead of unwinding traces.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="section-1">
<title>Shaping the Command Interface</title>
<simpara>Before touching any math, we need a predictable contract: three arguments (<literal>value</literal>, <literal>from-unit</literal>, <literal>to-unit</literal>) plus <literal>--help</literal> for documentation. The program should explain mistakes up front so callers never see a panic.</simpara>
<section xml:id="section-1-sub-a-pre">
<title>How CLI Arguments Reach Your Program</title>
<simpara>When you run your program from the command line, the operating system passes arguments through a well-defined startup sequence before your <literal>main()</literal> function ever runs. Understanding this flow clarifies where <literal>std.process.args()</literal> gets its data:</simpara>
<literallayout class="monospaced">graph TB
    OS["Operating System"]
    EXEC["execve() system call"]
    KERNEL["Kernel loads ELF"]
    STACK["Stack setup:&lt;br/&gt;argc, argv[], envp[]"]

    START["_start entry point&lt;br/&gt;(naked assembly)"]
    POSIX["posixCallMainAndExit&lt;br/&gt;(argc_argv_ptr)"]

    PARSE["Parse stack layout:&lt;br/&gt;argc at [0]&lt;br/&gt;argv at [1..argc+1]&lt;br/&gt;envp after NULL"]

    GLOBALS["Set global state:&lt;br/&gt;std.os.argv = argv[0..argc]&lt;br/&gt;std.os.environ = envp"]

    CALLMAIN["callMainWithArgs&lt;br/&gt;(argc, argv, envp)"]
    USERMAIN["Your main() function"]
    ARGS["std.process.args()&lt;br/&gt;reads std.os.argv"]

    OS --&gt; EXEC
    EXEC --&gt; KERNEL
    KERNEL --&gt; STACK
    STACK --&gt; START
    START --&gt; POSIX
    POSIX --&gt; PARSE
    PARSE --&gt; GLOBALS
    GLOBALS --&gt; CALLMAIN
    CALLMAIN --&gt; USERMAIN
    USERMAIN --&gt; ARGS</literallayout>
<simpara><emphasis role="strong">Key points:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">OS Preparation</emphasis>: The operating system places <literal>argc</literal> (argument count) and <literal>argv</literal> (argument array) on the stack before transferring control to your program.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Assembly Entry</emphasis>: The <literal>_start</literal> symbol (written in inline assembly) is the true entry point, not <literal>main()</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Stack Parsing</emphasis>: <literal>posixCallMainAndExit</literal> reads the stack layout to extract <literal>argc</literal>, <literal>argv</literal>, and environment variables.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Global State</emphasis>: Before calling your <literal>main()</literal>, the runtime populates <literal>std.os.argv</literal> and <literal>std.os.environ</literal> with the parsed data.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">User Access</emphasis>: When you call <literal>std.process.args()</literal>, it simply returns an iterator over the already-populated <literal>std.os.argv</literal> slice.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Why this matters for CLI programs:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Arguments are available from the moment <literal>main()</literal> runs—no separate initialization needed.</simpara>
</listitem>
<listitem>
<simpara>The first argument (<literal>argv[0]</literal>) is always the program name.</simpara>
</listitem>
<listitem>
<simpara>Argument parsing happens once during startup, not per access.</simpara>
</listitem>
<listitem>
<simpara>This sequence is the same whether you use <literal>zig run</literal> or a compiled binary.</simpara>
</listitem>
</itemizedlist>
<simpara>This infrastructure means your TempConv CLI can immediately start parsing arguments without worrying about the low-level details of how they arrived.</simpara>
</section>
<section xml:id="section-1-sub-a">
<title>Parsing Arguments with Guard Rails</title>
<simpara>The entry point allocates the full argument vector, checks for <literal>--help</literal>, and verifies the arity. When a rule is violated we print the usage banner and exit with a failure code, relying on <literal>std.process.exit</literal> to avoid noisy stack traces.</simpara>
</section>
<section xml:id="section-1-sub-b">
<title>Units and Validation Helpers</title>
<simpara>We describe the supported units with an enum and a <literal>parseUnit</literal> helper that accepts either uppercase or lowercase tokens. Invalid tokens trigger a friendly diagnostic and immediate exit, keeping the CLI resilient when embedded in scripts, as described in <link xl:href="https://ziglang.org/documentation/master/#enum">#enum</link>.</simpara>
</section>
</chapter>
<chapter xml:id="section-2">
<title>Converting and Reporting Results</title>
<simpara>With the interface in place, the rest of the program leans on deterministic conversions: every value is normalised to Kelvin and then projected into the requested unit, guaranteeing consistent results regardless of the input combination.</simpara>
<section xml:id="workflow-1">
<title>Complete TempConv Listing</title>
<simpara>The listing below includes argument parsing, unit helpers, and the conversion logic. Focus on how the CLI structure keeps every failure path obvious while keeping the happy path concise.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 05__project-tempconv-cli.adoc - include::example$chapters-data/code/05__project-tempconv-cli/tempconv_cli.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run tempconv_cli.zig -- 32 F C</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">32.00 f -&gt; 0.00 c</programlisting>
</para>
</formalpara>
<tip>
<simpara>The program prints diagnostics before exiting whenever it spots an invalid value or unit, so scripts can rely on a non-zero exit status without parsing stack traces.</simpara>
</tip>
</section>
<section xml:id="workflow-2">
<title>Exercising Additional Conversions</title>
<simpara>You can run the same binary for Kelvin or Celsius inputs—the shared conversion helpers guarantee symmetry because everything flows through Kelvin.</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ zig run tempconv_cli.zig -- 273.15 K C</programlisting>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">273.15 k -&gt; 0.00 c</programlisting>
</para>
</formalpara>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>Argument parsing remains minimal by design; production tools might add long-form flags or richer help text using the same guard patterns.</simpara>
</listitem>
<listitem>
<simpara>Temperature conversions are linear, so double-precision floats suffice; adapt the formulas carefully if you add niche scales such as Rankine.</simpara>
</listitem>
<listitem>
<simpara><literal>std.debug.print</literal> writes to stderr, which keeps scripted pipelines safe—swap to buffered stdout writers if you need clean stdout output; see <link xl:href="https://ziglang.org/documentation/master/#Debug">#Debug</link>.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Expand <literal>parseUnit</literal> to recognise the full words <literal>celsius</literal>, <literal>fahrenheit</literal>, and <literal>kelvin</literal> alongside their single-letter abbreviations.</simpara>
</listitem>
<listitem>
<simpara>Add a flag that toggles between rounded output (<literal>{d:.2}</literal>) and full precision using Zig’s formatting verbs; see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig">fmt.zig</link>.</simpara>
</listitem>
<listitem>
<simpara>Introduce a <literal>--table</literal> mode that prints conversions for a range of values, reinforcing slice iteration with <literal>for</literal>, as described in <link xl:href="https://ziglang.org/documentation/master/#for">#for</link>.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Alternatives &amp; Edge Cases:</title>
<itemizedlist>
<listitem>
<simpara>Kelvin never drops below zero; attach a guard if your CLI should reject negative Kelvin inputs instead of accepting the mathematical value.</simpara>
</listitem>
<listitem>
<simpara>International audiences sometimes expect comma decimals; connect <literal>std.fmt.formatFloat</literal> with locale-aware post-processing if you need that behaviour.</simpara>
</listitem>
<listitem>
<simpara>To support scripted usage without invoking <literal>zig run</literal>, package the program with <literal>zig build-exe</literal> and place the binary on your <literal>PATH</literal>.</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>