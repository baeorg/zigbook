////
changes: ["Initial draft for TempConv CLI project chapter"]
examples_compile: yes
keywords: ["cli", "project", "temperature"]
last_updated: 2025-11-02
last_verified: 2025-11-02
next_chapter: "06__project-grep-lite"
open_questions: []
previous_chapter: "04__errors-resource-cleanup"
status: draft
xref_complete: true
////

= Project: TempConv CLI
:chapter-number: 5
:chapter-slug: project-tempconv-cli
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Our first project turns the language fundamentals from Chapters 1–4 into a handheld command-line utility that converts temperatures between Celsius, Fahrenheit, and Kelvin. We compose argument parsing, enums, and floating-point math into a single program while keeping diagnostics friendly for end users, as described in link:https://ziglang.org/documentation/master/#Command-line-flags[#Command-line-flags] and link:https://ziglang.org/documentation/master/#Floats[#Floats].

Along the way, we reinforce the error-handling philosophy from the previous chapter: validation produces human-readable hints, and the process exits with intent instead of a stack trace; see link:https://ziglang.org/documentation/master/#Error-Handling[#Error-Handling].

[[learning-goals]]
== Learning Goals

* Build a minimal CLI harness that reads arguments, handles `--help`, and emits usage guidance.
* Represent temperature units with enums and use `switch` to normalise conversions, as described in link:https://ziglang.org/documentation/master/#switch[#switch].
* Present conversion results while surfacing validation failures through concise diagnostics instead of unwinding traces.

[[section-1]]
== Shaping the Command Interface

Before touching any math, we need a predictable contract: three arguments (`value`, `from-unit`, `to-unit`) plus `--help` for documentation. The program should explain mistakes up front so callers never see a panic.

[[section-1-sub-a-pre]]
=== How CLI Arguments Reach Your Program

When you run your program from the command line, the operating system passes arguments through a well-defined startup sequence before your `main()` function ever runs. Understanding this flow clarifies where `std.process.args()` gets its data:

[mermaid]
....
graph TB
    OS["Operating System"]
    EXEC["execve() system call"]
    KERNEL["Kernel loads ELF"]
    STACK["Stack setup:<br/>argc, argv[], envp[]"]
    
    START["_start entry point<br/>(naked assembly)"]
    POSIX["posixCallMainAndExit<br/>(argc_argv_ptr)"]
    
    PARSE["Parse stack layout:<br/>argc at [0]<br/>argv at [1..argc+1]<br/>envp after NULL"]
    
    GLOBALS["Set global state:<br/>std.os.argv = argv[0..argc]<br/>std.os.environ = envp"]
    
    CALLMAIN["callMainWithArgs<br/>(argc, argv, envp)"]
    USERMAIN["Your main() function"]
    ARGS["std.process.args()<br/>reads std.os.argv"]
    
    OS --> EXEC
    EXEC --> KERNEL
    KERNEL --> STACK
    STACK --> START
    START --> POSIX
    POSIX --> PARSE
    PARSE --> GLOBALS
    GLOBALS --> CALLMAIN
    CALLMAIN --> USERMAIN
    USERMAIN --> ARGS
....

**Key points:**

* **OS Preparation**: The operating system places `argc` (argument count) and `argv` (argument array) on the stack before transferring control to your program.
* **Assembly Entry**: The `_start` symbol (written in inline assembly) is the true entry point, not `main()`.
* **Stack Parsing**: `posixCallMainAndExit` reads the stack layout to extract `argc`, `argv`, and environment variables.
* **Global State**: Before calling your `main()`, the runtime populates `std.os.argv` and `std.os.environ` with the parsed data.
* **User Access**: When you call `std.process.args()`, it simply returns an iterator over the already-populated `std.os.argv` slice.

**Why this matters for CLI programs:**

* Arguments are available from the moment `main()` runs—no separate initialization needed.
* The first argument (`argv[0]`) is always the program name.
* Argument parsing happens once during startup, not per access.
* This sequence is the same whether you use `zig run` or a compiled binary.

This infrastructure means your TempConv CLI can immediately start parsing arguments without worrying about the low-level details of how they arrived.

[[section-1-sub-a]]
=== Parsing Arguments with Guard Rails

The entry point allocates the full argument vector, checks for `--help`, and verifies the arity. When a rule is violated we print the usage banner and exit with a failure code, relying on `std.process.exit` to avoid noisy stack traces.

[[section-1-sub-b]]
=== Units and Validation Helpers

We describe the supported units with an enum and a `parseUnit` helper that accepts either uppercase or lowercase tokens. Invalid tokens trigger a friendly diagnostic and immediate exit, keeping the CLI resilient when embedded in scripts, as described in link:https://ziglang.org/documentation/master/#enum[#enum].

[[section-2]]
== Converting and Reporting Results

With the interface in place, the rest of the program leans on deterministic conversions: every value is normalised to Kelvin and then projected into the requested unit, guaranteeing consistent results regardless of the input combination.

[[workflow-1]]
=== Complete TempConv Listing

The listing below includes argument parsing, unit helpers, and the conversion logic. Focus on how the CLI structure keeps every failure path obvious while keeping the happy path concise.

[source,zig]
----

include::{sourcedir}/05__project-tempconv-cli/tempconv_cli.zig[]

----

.Run
[source,shell]
----
$ zig run tempconv_cli.zig -- 32 F C
----

.Output
[source,shell]
----
32.00 f -> 0.00 c
----

TIP: The program prints diagnostics before exiting whenever it spots an invalid value or unit, so scripts can rely on a non-zero exit status without parsing stack traces.

[[workflow-2]]
=== Exercising Additional Conversions

You can run the same binary for Kelvin or Celsius inputs—the shared conversion helpers guarantee symmetry because everything flows through Kelvin.

[source,shell]
----
$ zig run tempconv_cli.zig -- 273.15 K C
----

.Output
[source,shell]
----
273.15 k -> 0.00 c
----

[[notes-caveats]]
== Notes & Caveats

* Argument parsing remains minimal by design; production tools might add long-form flags or richer help text using the same guard patterns.
* Temperature conversions are linear, so double-precision floats suffice; adapt the formulas carefully if you add niche scales such as Rankine.
* `std.debug.print` writes to stderr, which keeps scripted pipelines safe—swap to buffered stdout writers if you need clean stdout output; see link:https://ziglang.org/documentation/master/#Debug[#Debug].

[[exercises]]
== Exercises

* Expand `parseUnit` to recognise the full words `celsius`, `fahrenheit`, and `kelvin` alongside their single-letter abbreviations.
* Add a flag that toggles between rounded output (`{d:.2}`) and full precision using Zig’s formatting verbs; see link:https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig[fmt.zig].
* Introduce a `--table` mode that prints conversions for a range of values, reinforcing slice iteration with `for`, as described in link:https://ziglang.org/documentation/master/#for[#for].

[[caveats-alternatives-edge-cases]]
== Alternatives & Edge Cases:

* Kelvin never drops below zero; attach a guard if your CLI should reject negative Kelvin inputs instead of accepting the mathematical value.
* International audiences sometimes expect comma decimals; connect `std.fmt.formatFloat` with locale-aware post-processing if you need that behaviour.
* To support scripted usage without invoking `zig run`, package the program with `zig build-exe` and place the binary on your `PATH`.
