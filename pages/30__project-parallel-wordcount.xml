<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Project</title>
<subtitle>Parallel Wordcount</subtitle>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Armed with the concurrency primitives from the last chapter, we’ll build a small but useful tool: a parallel word counter that reads a file, shards it into contiguous segments along whitespace, spins up worker threads to tokenize and tally, then merges thread-local maps into a final frequency table. See <link xl:href="29__threads-and-atomics.xml">29</link>, <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Thread.zig">Thread.zig</link>, and <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/atomic.zig">atomic.zig</link>.</simpara>
<simpara>Why this project? It exercises common systems patterns—work decomposition, avoiding false sharing, ownership of string keys, and memory order discipline—without drowning in boilerplate. The result is a robust skeleton you can adapt to log crunching, grep-like indexing, or lightweight analytics.</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Partition inputs into shards while respecting token boundaries.</simpara>
</listitem>
<listitem>
<simpara>Use <literal>std.Thread.spawn</literal> safely and fall back to inline execution in single‑threaded builds.</simpara>
</listitem>
<listitem>
<simpara>Maintain per‑thread <literal>std.StringHashMap</literal> instances and merge them without dangling pointers.</simpara>
</listitem>
<listitem>
<simpara>Present a deterministic “Top N” by sorting a vector of key/value pairs.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="project-setup">
<title>Project layout and build</title>
<simpara>We keep this sample as a tiny package with a local build. The 0.15.2 build API constructs an explicit module and passes it to <literal>addExecutable</literal>—note the <literal>root_module</literal> field rather than the old <literal>root_source_file</literal>.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 30__project-parallel-wordcount.adoc - include::example$chapters-data/code/30__project-parallel-wordcount/build.zig[]</programlisting>
<simpara>See <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Build.zig">Build.zig</link>.</simpara>
</chapter>
<chapter xml:id="implementation">
<title>Implementation</title>
<simpara>The program reads an entire file into memory (bounded by a reasonable cap), creates shard boundaries at whitespace, and then launches N workers (N=CPU count unless in single‑threaded mode). Each worker tokenizes and lowercases ASCII, strips punctuation, and inserts into its own map backed by an arena to avoid per‑token frees. At merge time, we duplicate keys into the final map’s allocator so deinitializing arenas doesn’t invalidate keys.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 30__project-parallel-wordcount.adoc - include::example$chapters-data/code/30__project-parallel-wordcount/src/main.zig[]</programlisting>
<simpara>See <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/hash_map.zig">hash_map.zig</link> and <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/mem/tokenize.zig">tokenize.zig</link>.</simpara>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig build --build-file chapters-data/code/30__project-parallel-wordcount/build.zig run -- chapters-data/code/30__project-parallel-wordcount/data/lines.txt</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">top 10 words in 8 shards:
and 2
i 2
little 2
me 2
the 2
a 1
about 1
ago—never 1
call 1
how 1</programlisting>
</para>
</formalpara>
<tip>
<simpara><literal>StringHashMap</literal> stores string slices by reference; it does not copy bytes. When merging maps that point into short‑lived arenas, duplicate the key bytes into the destination allocator, then free them when you’re done. The example iterates and frees keys just before exit.</simpara>
</tip>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>Sharding pushes shard ends forward to the next whitespace to avoid splitting tokens mid‑word. That means shards may be uneven; that’s fine for an I/O‑bound tool.</simpara>
</listitem>
<listitem>
<simpara>The sample lowercases ASCII and strips punctuation crudely to stay focused on threading. If you need Unicode segmentation, integrate <literal>std.unicode</literal> and a more faithful normalization.</simpara>
</listitem>
<listitem>
<simpara>In single‑threaded builds (<literal>-Dsingle-threaded=true</literal>), we execute workers inline and skip spawning entirely, mirroring the pattern from Chapter 29.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Add <literal>-n &lt;N&gt;</literal> to print the top N words, parsing flags with <literal>std.process.argsWithAllocator</literal>.</simpara>
</listitem>
<listitem>
<simpara>Switch the merge phase to a parallel reduction: pairwise merge per CPU until one map remains; measure scalability.</simpara>
</listitem>
<listitem>
<simpara>Replace the arena with a bump allocator sized via <literal>file size / shards</literal> and reason about fragmentation vs. peak footprint.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="summary">
<title>Summary</title>
<simpara>This project distills a practical, fast path from bytes on disk to a sorted frequency table while respecting Zig’s ownership and threading model. It consolidates sharding, per‑thread maps, and safe merging—a minimal template ready for larger pipelines.</simpara>
</chapter>
</book>