<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>User Types</title>
<subtitle>Structs, Enums, Unions</subtitle>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Zig&#8217;s user-defined types are deliberately small, sharp tools. Structs compose data and behavior under a clean namespace, enums encode closed sets of states with explicit integer representations, and unions model variant data—tagged for safety or untagged for low-level control. Together, these form the backbone of ergonomic APIs and memory-aware systems code; see <link xl:href="https://ziglang.org/documentation/master/#Structs">#Structs</link>, <link xl:href="https://ziglang.org/documentation/master/#Enums">#Enums</link>, and <link xl:href="https://ziglang.org/documentation/master/#Unions">#Unions</link> for reference.</simpara>
<simpara>This chapter builds pragmatic fluency: methods and defaults on structs, enum round-trips with <literal>@intFromEnum</literal>/<literal>@enumFromInt</literal>, and both tagged and untagged unions. We&#8217;ll also peek at layout modifiers (<literal>packed</literal>, <literal>extern</literal>) and anonymous structs/tuples, which become handy for lightweight return values and FFI. See <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig">fmt.zig</link> and <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/math.zig">math.zig</link> for related helpers.</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Define and use structs with methods, defaults, and clear namespacing.</simpara>
</listitem>
<listitem>
<simpara>Convert enums to and from integers safely and match on them exhaustively.</simpara>
</listitem>
<listitem>
<simpara>Choose between tagged and untagged unions; understand when <literal>packed</literal>/<literal>extern</literal> layout matters (see <link xl:href="https://ziglang.org/documentation/master/#packed-struct">#packed struct</link> and <link xl:href="https://ziglang.org/documentation/master/#extern-struct">#extern struct</link>).</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="structs">
<title>Structs: Data + Namespace</title>
<simpara>Structs gather fields and related helper functions. Methods are just functions with an explicit receiver parameter—no magic, which keeps call sites obvious and unit-testable. Defaults reduce boilerplate for common cases.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 08__user-types-structs-enums-unions.adoc - include::example$chapters-data/code/08__user-types-structs-enums-unions/struct_basics.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run struct_basics.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">p=(3,0) len=3.000
p=(0,4) len=4.000</programlisting>
</para>
</formalpara>
<tip>
<simpara>Methods are namespaced functions; you can freely mix free functions and methods depending on testability and API clarity.</simpara>
</tip>
</chapter>
<chapter xml:id="enums">
<title>Enums: States with Bit-Exact Reprs</title>
<simpara>Enums can set their integer representation (e.g., <literal>enum(u8)</literal>) and convert to/from integers with builtins. A <literal>switch</literal> over an enum must be exhaustive unless you include <literal>else</literal>, which is perfect for catching new states at compile time.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 08__user-types-structs-enums-unions.adoc - include::example$chapters-data/code/08__user-types-structs-enums-unions/enum_roundtrip.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run enum_roundtrip.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">m=busy int=1
m2=paused int=2</programlisting>
</para>
</formalpara>
<note>
<simpara><literal>@enumFromInt</literal> requires that the integer maps to a declared tag. If you expect unknown values (e.g., file formats), consider a sentinel tag, validation paths, or separate integer parsing with explicit error handling.</simpara>
</note>
</chapter>
<chapter xml:id="unions">
<title>Unions: Variant Data</title>
<simpara>A tagged union carries both a tag and a payload; pattern matching is straightforward and type-safe. Untagged unions require you to manage the active field manually and are appropriate for low-level bit reinterpretations or FFI shims.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 08__user-types-structs-enums-unions.adoc - include::example$chapters-data/code/08__user-types-structs-enums-unions/union_demo.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run union_demo.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">start: number=42
update: hi
raw u=0xFFFFFFFE i=-2</programlisting>
</para>
</formalpara>
<warning>
<simpara>Reading a different field from an untagged union without reinterpreting the bits (e.g., via <literal>@bitCast</literal>) is illegal; Zig prevents this at compile time. Prefer tagged unions for safety unless you truly need the control.</simpara>
</warning>
<section xml:id="_tagged_union_memory_representation">
<title>Tagged Union Memory Representation</title>
<simpara>Understanding how tagged unions are laid out in memory clarifies the safety vs space trade-off and explains when to choose tagged vs untagged unions:</simpara>
<literallayout class="monospaced">graph TB
    subgraph "Tagged Union Definition"
        TAGGED["const Value = union(enum) {&lt;br/&gt;  number: i32,    // 4 bytes&lt;br/&gt;  text: []const u8, // 16 bytes (ptr+len)&lt;br/&gt;}"]
    end

    subgraph "Tagged Union Memory (24 bytes on 64-bit)"
        TAG_MEM["Memory Layout:&lt;br/&gt;&lt;br/&gt;| tag (u8) | padding | payload (16 bytes) |&lt;br/&gt;&lt;br/&gt;Tag identifies active field&lt;br/&gt;Payload holds largest variant"]
    end

    subgraph "Untagged Union Definition"
        UNTAGGED["const Raw = union {&lt;br/&gt;  number: i32,&lt;br/&gt;  text: []const u8,&lt;br/&gt;}"]
    end

    subgraph "Untagged Union Memory (16 bytes)"
        UNTAG_MEM["Memory Layout:&lt;br/&gt;&lt;br/&gt;| payload (16 bytes) |&lt;br/&gt;&lt;br/&gt;No tag - you track active field&lt;br/&gt;Size = largest variant only"]
    end

    TAGGED --&gt; TAG_MEM
    UNTAGGED --&gt; UNTAG_MEM

    subgraph "Access Patterns"
        SAFE["Tagged: Safe Pattern Matching&lt;br/&gt;switch (value) {&lt;br/&gt;  .number =&gt; |n| use(n),&lt;br/&gt;  .text =&gt; |t| use(t),&lt;br/&gt;}"]
        UNSAFE["Untagged: Manual Tracking&lt;br/&gt;// You must know which field is active&lt;br/&gt;const n = raw.number; // Unsafe!"]
    end

    TAG_MEM --&gt; SAFE
    UNTAG_MEM --&gt; UNSAFE</literallayout>
<simpara><emphasis role="strong">Memory layout details:</emphasis></simpara>
<simpara><emphasis role="strong">Tagged Union:</emphasis>
- Size = tag size + padding + largest variant size
- Tag field (typically u8 or smallest integer that fits tag count)
- Padding for alignment of payload
- Payload space sized to hold the largest variant
- Example: <literal>union(enum) { i32, []const u8 }</literal> = 1 byte tag + 7 bytes padding + 16 bytes payload = 24 bytes</simpara>
<simpara><emphasis role="strong">Untagged Union:</emphasis>
- Size = largest variant size (no tag overhead)
- No runtime tag to check
- You&#8217;re responsible for tracking which field is active
- Example: <literal>union { i32, []const u8 }</literal> = 16 bytes (just the payload)</simpara>
<simpara><emphasis role="strong">When to use each:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Use Tagged Unions</emphasis> (default choice):</simpara>
<itemizedlist>
<listitem>
<simpara>Application logic with variant data types</simpara>
</listitem>
<listitem>
<simpara>When you need exhaustive pattern matching</simpara>
</listitem>
<listitem>
<simpara>Safety is more important than 1-8 bytes of tag overhead</simpara>
</listitem>
<listitem>
<simpara>Error unions, option types, state machines</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Use Untagged Unions</emphasis> (rare, expert use):</simpara>
<itemizedlist>
<listitem>
<simpara>FFI with C unions that don&#8217;t have tags</simpara>
</listitem>
<listitem>
<simpara>Bit reinterpretation with <literal>@bitCast</literal></simpara>
</listitem>
<listitem>
<simpara>Performance-critical code where tag overhead matters AND you can prove safety</simpara>
</listitem>
<listitem>
<simpara>Type punning for low-level operations</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Safety guarantees:</emphasis></simpara>
<simpara>Tagged unions provide compile-time exhaustiveness checking and runtime tag validation:</simpara>
<programlisting language="zig" linenumbering="unnumbered">const val = Value{ .number = 42 };
switch (val) {
    .number =&gt; |n| print("{}", .{n}),  // OK - matches tag
    .text =&gt; |t| print("{s}", .{t}),  // Compiler ensures both cases covered
}</programlisting>
<simpara>Untagged unions require you to maintain safety invariants manually—the compiler can&#8217;t help you.</simpara>
</section>
</chapter>
<chapter xml:id="layout-anon">
<title>Layout and Anonymous Structs/Tuples</title>
<simpara>When you must fit bits precisely (wire formats) or match C ABI layout, Zig offers <literal>packed</literal> and <literal>extern</literal>. Anonymous structs (often called "tuples") are convenient for quick multi-value returns.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 08__user-types-structs-enums-unions.adoc - include::example$chapters-data/code/08__user-types-structs-enums-unions/layout_and_anonymous.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run layout_and_anonymous.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">packed.size=1
extern.size=8 align=4
pair[0]=x pair[1]=42 via names: x/42</programlisting>
</para>
</formalpara>
<note>
<simpara>Tuple field access uses <literal>@field(val, "0")</literal> and <literal>@field(val, "1")</literal>. They&#8217;re anonymous structs with numeric field names, which keeps them simple and allocation-free.</simpara>
</note>
<section xml:id="_memory_layout_default_vs_packed_vs_extern">
<title>Memory Layout: Default vs Packed vs Extern</title>
<simpara>Zig offers three struct layout strategies, each with different trade-offs for memory efficiency, performance, and compatibility:</simpara>
<literallayout class="monospaced">graph TB
    subgraph "Default Layout (Optimized)"
        DEF_CODE["const Point = struct {&lt;br/&gt;  x: u8,  // 1 byte&lt;br/&gt;  y: u32, // 4 bytes&lt;br/&gt;  z: u8,  // 1 byte&lt;br/&gt;};"]
        DEF_MEM["Memory: 12 bytes&lt;br/&gt;&lt;br/&gt;| x | pad(3) | y(4) | z | pad(3) |&lt;br/&gt;&lt;br/&gt;Compiler reorders &amp; pads for efficiency"]
    end

    subgraph "Packed Layout (No Padding)"
        PACK_CODE["const Flags = packed struct {&lt;br/&gt;  a: bool,  // 1 bit&lt;br/&gt;  b: u3,    // 3 bits&lt;br/&gt;  c: bool,  // 1 bit&lt;br/&gt;  d: u3,    // 3 bits&lt;br/&gt;};"]
        PACK_MEM["Memory: 1 byte&lt;br/&gt;&lt;br/&gt;| abcd(8 bits) |&lt;br/&gt;&lt;br/&gt;No padding, bit-exact packing"]
    end

    subgraph "Extern Layout (C ABI)"
        EXT_CODE["const Data = extern struct {&lt;br/&gt;  x: u8,&lt;br/&gt;  y: u32,&lt;br/&gt;  z: u8,&lt;br/&gt;};"]
        EXT_MEM["Memory: 12 bytes&lt;br/&gt;&lt;br/&gt;| x | pad(3) | y(4) | z | pad(3) |&lt;br/&gt;&lt;br/&gt;C ABI rules, field order preserved"]
    end

    DEF_CODE --&gt; DEF_MEM
    PACK_CODE --&gt; PACK_MEM
    EXT_CODE --&gt; EXT_MEM

    subgraph "Key Differences"
        DIFF1["Default: Compiler can reorder fields&lt;br/&gt;Extern: Field order fixed&lt;br/&gt;Packed: Bit-level packing"]
        DIFF2["Default: Optimized alignment&lt;br/&gt;Extern: Platform ABI alignment&lt;br/&gt;Packed: No alignment (bitfields)"]
    end</literallayout>
<simpara><emphasis role="strong">Layout mode comparison:</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Layout</entry>
<entry align="left" valign="top">Size/Alignment</entry>
<entry align="left" valign="top">Field Order</entry>
<entry align="left" valign="top">Use Case</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Default</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Optimized by compiler</simpara></entry>
<entry align="left" valign="top"><simpara>Can be reordered</simpara></entry>
<entry align="left" valign="top"><simpara>Normal Zig code</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Packed</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Bit-exact, no padding</simpara></entry>
<entry align="left" valign="top"><simpara>Fixed, bit-level</simpara></entry>
<entry align="left" valign="top"><simpara>Wire formats, bit flags</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis role="strong">Extern</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>C ABI rules</simpara></entry>
<entry align="left" valign="top"><simpara>Fixed (declaration order)</simpara></entry>
<entry align="left" valign="top"><simpara>FFI, C interop</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">Detailed behavior:</emphasis></simpara>
<simpara><emphasis role="strong">Default Layout:</emphasis></simpara>
<programlisting language="zig" linenumbering="unnumbered">const Point = struct {
    x: u8,   // Compiler might reorder this
    y: u32,  // to minimize padding
    z: u8,
};
// Compiler chooses optimal order, typically:
// y (4 bytes, aligned) + x (1 byte) + z (1 byte) + padding</programlisting>
<simpara><emphasis role="strong">Packed Layout:</emphasis></simpara>
<programlisting language="zig" linenumbering="unnumbered">const Flags = packed struct {
    enabled: bool,    // bit 0
    mode: u3,         // bits 1-3
    priority: u4,     // bits 4-7
};
// Total: 8 bits = 1 byte, no padding
// Perfect for hardware registers and wire protocols</programlisting>
<simpara><emphasis role="strong">Extern Layout:</emphasis></simpara>
<programlisting language="zig" linenumbering="unnumbered">const CHeader = extern struct {
    version: u32,  // Matches C struct layout exactly
    flags: u16,    // Field order preserved
    padding: u16,  // Explicit padding if needed
};
// For calling C functions or reading C-written binary data</programlisting>
<simpara><emphasis role="strong">When to use each layout:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Default</emphasis> (no modifier):</simpara>
<itemizedlist>
<listitem>
<simpara>All normal Zig code</simpara>
</listitem>
<listitem>
<simpara>When you don&#8217;t need specific memory layout</simpara>
</listitem>
<listitem>
<simpara>Let the compiler optimize for you</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Packed</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>Wire protocols with bit-level fields</simpara>
</listitem>
<listitem>
<simpara>Hardware register definitions</simpara>
</listitem>
<listitem>
<simpara>When you need exact bit positions</simpara>
</listitem>
<listitem>
<simpara>Space-critical flags and options</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Warning</emphasis>: Can be slower due to bit operations</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Extern</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>FFI with C/C++ structs</simpara>
</listitem>
<listitem>
<simpara>Reading binary file formats defined by other languages</simpara>
</listitem>
<listitem>
<simpara>When field order must match external specification</simpara>
</listitem>
<listitem>
<simpara>ABI compatibility requirements</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">Important notes:</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Use <literal>@sizeOf(T)</literal> and <literal>@alignOf(T)</literal> to verify layout</simpara>
</listitem>
<listitem>
<simpara>Packed structs can be slower—measure before optimizing</simpara>
</listitem>
<listitem>
<simpara>Extern structs must match the C definition exactly (including padding)</simpara>
</listitem>
<listitem>
<simpara>Default layout may change between compiler versions (always safe, but field order not guaranteed)</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>Methods are sugar-free; consider making helpers <literal>pub</literal> inside the struct for discoverability and test scoping.</simpara>
</listitem>
<listitem>
<simpara>Enum reprs (<literal>enum(uN)</literal>) define size and affect ABI/FFI—choose the smallest that fits your protocol.</simpara>
</listitem>
<listitem>
<simpara>Untagged unions are sharp tools. In most application code, prefer tagged unions and pattern matching.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Add a <literal>scale</literal> method to <literal>Point</literal> that multiplies both coordinates by a <literal>f64</literal>, then reworks <literal>len</literal> to avoid precision loss for large integers.</simpara>
</listitem>
<listitem>
<simpara>Extend <literal>Mode</literal> with a new <literal>Error</literal> state and observe how the compiler enforces an updated <literal>switch</literal>.</simpara>
</listitem>
<listitem>
<simpara>Create a tagged union representing a JSON scalar (<literal>null</literal>, <literal>bool</literal>, <literal>number</literal>, <literal>string</literal>) and write a <literal>print</literal> function that formats each case.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Alternatives &amp; Edge Cases</title>
<itemizedlist>
<listitem>
<simpara>ABI layout: <literal>extern</literal> respects the platform ABI. Verify sizes with <literal>@sizeOf</literal>/<literal>@alignOf</literal> and cross-compile when shipping libraries.</simpara>
</listitem>
<listitem>
<simpara>Bit packing: <literal>packed struct</literal> compresses fields but can increase instruction count; measure before committing in hot paths.</simpara>
</listitem>
<listitem>
<simpara>Tuples vs named structs: prefer named structs for stable APIs; tuples shine for local, short-lived glue.</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>