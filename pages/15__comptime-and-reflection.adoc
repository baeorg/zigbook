////
changes: ["New chapter: Comptime & Reflection (in-depth)", "Runnable examples with captured outputs"]
examples_compile: yes
keywords: ["comptime", "reflection", "@TypeOf", "@typeInfo", "inline", "anytype", "@hasDecl", "@hasField", "@embedFile"]
last_updated: 2025-11-03
last_verified: 2025-11-03
next_chapter: "16__project-table-generator"
open_questions: []
previous_chapter: "14__project-path-utility"
status: draft
xref_complete: true
////

= Comptime & Reflection
:chapter-number: 15
:chapter-slug: comptime-and-reflection
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Zig lets you execute plain Zig at compile time. That single, quiet idea unlocks a lot: generate lookup tables, specialize code based on types or values, validate invariants before the program is ever run, and write generic utilities without macros or a separate metaprogramming language. Reflection completes the picture: with `@TypeOf`, `@typeInfo`, and friends, code can inspect types and construct behavior adaptively.

This chapter is a practitioner’s tour of compile-time execution and reflection in Zig 0.15.2. We’ll build small, self-contained examples you can run directly. Along the way, we’ll discuss what runs when (compile vs. run), how to keep code readable and fast, and when to prefer explicit parameters over clever reflection. For more detail, see link:https://github.com/ziglang/zig/tree/master/lib/std/meta.zig[meta.zig].

[[learning-goals]]
== Learning Goals

* Use `comptime` expressions and blocks to compute data at build time and surface it at run time.
* Introspect types using `@TypeOf`, `@typeInfo`, and `@typeName` to implement robust, generic helpers.
* Apply `inline fn` and `inline for/while` judiciously, understanding code-size and performance trade-offs. xref:37__illegal-behavior-and-safety-modes.adoc[37]
* Detect declarations and fields with `@hasDecl`, `@hasField`, and embed assets with `@embedFile`. xref:19__modules-and-imports-root-builtin-discovery.adoc[19]

[[comptime-basics]]
== Compile-time basics: data now, print later

Compile-time work is just ordinary Zig evaluated earlier. The example below:

- Evaluates an expression at compile time.
- Checks `@inComptime()` during runtime (it’s `false`).
- Builds a small squares lookup table at compile time using an `inline while` and a comptime index.

[source,zig]
----
include::{sourcedir}/15__comptime-and-reflection/comptime_basics.zig[]
----

.Run
[source,shell]
----
$ zig run chapters-data/code/15__comptime-and-reflection/comptime_basics.zig
----

.Output
[source,shell]
----
a (comptime 2+3) = 5
@inComptime() during runtime: false
squares[0..8): 0,1,4,9,16,25,36,49
----

TIP: `inline while` requires the condition to be known at compile time. Use a `comptime var` index for unrolled loops. Prefer ordinary loops unless you have a measured reason to unroll. 

[[comptime-tracking]]
=== How the compiler tracks comptime values

When you write comptime code, the compiler must determine which allocations and values are fully known at compile time. This tracking uses a mechanism in semantic analysis (Sema) that monitors all stores to allocated memory.

[mermaid]
....
graph TB
    subgraph "Key Structures"
        COMPTIMEALLOC["ComptimeAlloc<br/>val, is_const, alignment"]
        MAYBECOMPTIMEALLOC["MaybeComptimeAlloc<br/>runtime_index, stores[]"]
        BASEALLOC["base_allocs map<br/>derived ptr → base alloc"]
    end

    subgraph "Lifecycle"
        RUNTIMEALLOC["Runtime alloc instruction"]
        STORES["Store operations tracked"]
        MAKEPTRCONST["make_ptr_const instruction"]
        COMPTIMEVALUE["Determine comptime value"]
    end

    subgraph "MaybeComptimeAlloc Tracking"
        STORELIST["stores: MultiArrayList<br/>inst, src"]
        RUNTIMEINDEXFIELD["runtime_index<br/>Allocation point"]
    end

    subgraph "ComptimeAlloc Fields"
        VAL["val: MutableValue<br/>Current value"]
        ISCONST["is_const: bool<br/>Immutable after init"]
        ALIGNMENT["alignment<br/>Pointer alignment"]
        RUNTIMEINDEXALLOC["runtime_index<br/>Creation point"]
    end

    RUNTIMEALLOC --> MAYBECOMPTIMEALLOC
    MAYBECOMPTIMEALLOC --> STORELIST
    STORELIST --> STORES
    STORES --> MAKEPTRCONST
    MAKEPTRCONST --> COMPTIMEVALUE
    COMPTIMEVALUE --> COMPTIMEALLOC

    COMPTIMEALLOC --> VAL
    COMPTIMEALLOC --> ISCONST
    COMPTIMEALLOC --> ALIGNMENT
    COMPTIMEALLOC --> RUNTIMEINDEXALLOC

    BASEALLOC -.->|"tracks"| RUNTIMEALLOC
....

When the compiler encounters an allocation during semantic analysis, it creates a `MaybeComptimeAlloc` entry to track all stores. If any store depends on runtime values or conditions, the allocation cannot be known at comptime and the entry is discarded. If all stores are known at comptime when the pointer becomes const, the compiler applies all stores at compile time and creates a `ComptimeAlloc` with the final value. This mechanism enables the compiler to evaluate complex initialization patterns at compile time while ensuring correctness. For implementation details, see link:https://github.com/ziglang/zig/blob/master/src/Sema.zig[Sema.zig].

[[reflection-typeinfo]]
== Reflection: `@TypeOf`, `@typeInfo`, and friends

Reflection lets you write “generic-but-precise” code. Here we examine a `struct` and print its fields and their types, then construct a value in the usual way.

[source,zig]
----
include::{sourcedir}/15__comptime-and-reflection/type_info_introspect.zig[]
----

.Run
[source,shell]
----
$ zig run chapters-data/code/15__comptime-and-reflection/type_info_introspect.zig
----

.Output
[source,shell]
----
type name: type_info_introspect.Person
fields: 3
  0. id: u32
  1. name: []const u8
  2. active: bool
example: id=42 name=Zig active=true
----

NOTE: Use `@typeInfo(T)` at compile time to derive implementations (formatters, serializers, adapters). Keep the result in a local `const` for readability.

[[type-decomposition]]
=== Type decomposition with `std.meta`

Beyond `@typeInfo`, the `std.meta` module provides specialized functions for extracting component types from composite types. These utilities make generic code cleaner by avoiding manual `@typeInfo` inspection.

[mermaid]
....
graph TB
    subgraph "Type Extractors"
        CHILD["Child(T)"]
        ELEM["Elem(T)"]
        SENTINEL["sentinel(T)"]
        TAG["Tag(T)"]
        ACTIVETAG["activeTag(union)"]
    end

    subgraph "Input Types"
        ARRAY["array"]
        VECTOR["vector"]
        POINTER["pointer"]
        OPTIONAL["optional"]
        UNION["union"]
        ENUM["enum"]
    end

    ARRAY --> CHILD
    VECTOR --> CHILD
    POINTER --> CHILD
    OPTIONAL --> CHILD

    ARRAY --> ELEM
    VECTOR --> ELEM
    POINTER --> ELEM

    ARRAY --> SENTINEL
    POINTER --> SENTINEL

    UNION --> TAG
    ENUM --> TAG
    UNION --> ACTIVETAG
....

Key type extraction functions:

* `Child(T)`: Extracts the child type from arrays, vectors, pointers, and optionals—useful for generic functions operating on containers.
* `Elem(T)`: Gets the element type from memory span types (arrays, slices, pointers)—cleaner than manual `@typeInfo` field access.
* `sentinel(T)`: Returns the sentinel value, if present, enabling generic handling of null-terminated data.
* `Tag(T)`: Gets the tag type from enums and unions for switch-based dispatch.
* `activeTag(u)`: Returns the active tag of a union value at runtime.

These functions compose well: `std.meta.Child(std.meta.Child(T))` extracts the element type from `[][]u8`. Use them to write generic algorithms that adapt to type structure without verbose `switch (@typeInfo(T))` blocks. link:https://github.com/ziglang/zig/blob/master/lib/std/meta.zig[meta.zig]

[[field-declaration-introspection]]
=== Field and declaration introspection

For structured access to container internals, `std.meta` provides higher-level alternatives to manual `@typeInfo` navigation:

[mermaid]
....
graph TB
    subgraph "Container Introspection"
        FIELDS["fields(T)"]
        FIELDINFO["fieldInfo(T, field)"]
        FIELDNAMES["fieldNames(T)"]
        TAGS["tags(T)"]
        FIELDENUM["FieldEnum(T)"]
    end

    subgraph "Declaration Introspection"
        DECLARATIONS["declarations(T)"]
        DECLINFO["declarationInfo(T, name)"]
        DECLENUM["DeclEnum(T)"]
    end

    subgraph "Applicable Types"
        STRUCT["struct"]
        UNION["union"]
        ENUMP["enum"]
        ERRORSET["error_set"]
    end

    STRUCT --> FIELDS
    UNION --> FIELDS
    ENUMP --> FIELDS
    ERRORSET --> FIELDS

    STRUCT --> DECLARATIONS
    UNION --> DECLARATIONS
    ENUMP --> DECLARATIONS

    FIELDS --> FIELDINFO
    FIELDS --> FIELDNAMES
    FIELDS --> FIELDENUM
    ENUMP --> TAGS
....

The introspection API provides:

* `fields(T)`: Returns compile-time field information for any struct, union, enum, or error set—iterate with `inline for` to process each field.
* `fieldInfo(T, field)`: Gets detailed information (name, type, default value, alignment) for a specific field.
* `FieldEnum(T)`: Creates an enum with variants for each field name, enabling switch-based field dispatch.
* `declarations(T)`: Returns compile-time declaration info for functions and constants in a type—useful for finding optional interface methods.

Example pattern: `inline for (std.meta.fields(MyStruct)) |field| { ... }` lets you write generic serialization, formatting, or comparison functions without hand-coding field access. The `FieldEnum(T)` helper is particularly useful for switch statements over field names. link:https://github.com/ziglang/zig/blob/master/lib/std/meta.zig[meta.zig]

[[inline-and-unrolling]]
== Inline functions and inline loops: power and cost

`inline fn` forces inlining, and `inline for` unrolls compile-time-known iterations. Both increase code size. Use them when you’ve profiled and determined a hot path benefits from unrolling or call-overhead elimination.

[source,zig]
----
include::{sourcedir}/15__comptime-and-reflection/inline_for_inline_fn.zig[]
----

.Run
[source,shell]
----
$ zig run chapters-data/code/15__comptime-and-reflection/inline_for_inline_fn.zig
----

.Output
[source,shell]
----
acc=26
----

CAUTION: Inline is not a performance cheat code. It trades instruction cache and binary size for potential speed. Measure before and after. xref:39__performance-and-inlining.adoc[39]

[[decl-field-embedfile]]
== Capabilities: `@hasDecl`, `@hasField`, and `@embedFile`

Compile-time capability tests let you adapt to types without overfitting APIs. Asset embedding keeps small resources close to the code with no runtime I/O.

[source,zig]
----
include::{sourcedir}/15__comptime-and-reflection/has_decl_field_embedfile.zig[]
----

.Run
[source,shell]
----
$ zig run chapters-data/code/15__comptime-and-reflection/has_decl_field_embedfile.zig
----

.Output
[source,shell]
----
has greet: true
has field x: true
message: compile-time constant
embedded:
Hello from @embedFile!
This text is compiled into the binary at build time.
----

TIP: Place assets next to the source that uses them and reference with a relative path in `@embedFile`. For larger assets or user-supplied data, prefer runtime I/O. xref:28__filesystem-and-io.adoc[28]

[[anytype-generics]]
== `anytype` and explicit type parameters: pragmatic generics

Zig’s generics are just functions with `comptime` parameters. Use explicit type parameters for clarity; use `anytype` in leaf helpers that forward types. Reflection (`@TypeOf`, `@typeName`) helps with diagnostics when you accept flexible inputs.

[source,zig]
----
include::{sourcedir}/15__comptime-and-reflection/anytype_and_generics.zig[]
----

.Run
[source,shell]
----
$ zig run chapters-data/code/15__comptime-and-reflection/anytype_and_generics.zig
----

.Output
[source,shell]
----
sum(u32,[1,2,3,4]) = 10
sum(u64,[10,20]) = 30
value of type u8: 42
value of type *const [5:0]u8: { 104, 101, 108, 108, 111 }
----

IMPORTANT: Prefer explicit `comptime T: type` parameters for public APIs; restrict `anytype` to helpers that transparently forward the concrete type and don’t constrain semantics.

[[notes-caveats]]
== Notes & Caveats

* Compile-time execution runs in the compiler; be mindful of complexity. Keep heavy work out of tight incremental loops to preserve fast rebuilds. xref:38__zig-cli-deep-dive.adoc[38]
* Inline loops require compile-time-known bounds. When in doubt, use runtime loops and let the optimizer do its job. xref:39__performance-and-inlining.adoc[39]
* Reflection is powerful but can obscure control flow. Prefer straightforward parameters for clarity, and reflect only where ergonomics justify it. xref:36__style-and-best-practices.adoc[36]

[[exercises]]
== Exercises

* Write a `formatFields` helper that uses `@typeInfo` to print any struct’s field names and values. Try it with nested structs and slices. xref:45__text-formatting-and-unicode.adoc[47]
* Build a compile-time computed `sin`/`cos` lookup table for integer angles and benchmark against `std.math` calls in a tight loop. Measure code size and runtime. xref:50__random-and-math.adoc[50]
* Add a `hasToString` check: if a type `T` has a `format` method, print with `{f}`, otherwise print with `{any}`. Clarify behavior in a short doc comment.

[[caveats-alternatives-edge-cases]]
== Alternatives & Edge Cases

* `@inComptime()` is `true` in comptime contexts only; don’t rely on it for runtime behavior switches. Keep such switches in values/parameters.
* `@embedFile` increases binary size; avoid embedding large resources. For configs/logos, it’s great. For datasets, stream from disk or network. xref:28__filesystem-and-io.adoc[28]
* Avoid `inline fn` on large functions; it can balloon code. Use it on leaf arithmetic helpers or very small combinators where profiling shows wins. xref:39__performance-and-inlining.adoc[39]
