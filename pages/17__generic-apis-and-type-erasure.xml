<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Generic APIs &amp; Type Erasure</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Generics in Zig are nothing more than regular functions parameterized by <literal>comptime</literal> values, yet this simplicity hides a remarkable amount of expressive power. In this chapter, we turn the reflective techniques from <link xl:href="15__comptime-and-reflection.xml">15</link> into disciplined API design patterns: structuring capability contracts, forwarding concrete types with <literal>anytype</literal>, and keeping the call sites ergonomic without sacrificing correctness.</simpara>
<simpara>We also cover the opposite end of the spectrum—runtime type erasure—where opaque pointers and handwritten vtables let you store heterogeneous behavior in uniform containers. These techniques complement the lookup-table generation from <link xl:href="16__project-table-generator.xml">16</link> and prepare us for the fully generic priority queue project that follows. For release notes, see <link xl:href="https://ziglang.org/download/0.15.1/release-notes.html">v0.15.2</link>.</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Build compile-time contracts that validate user-supplied types before code generation, delivering clear diagnostics.</simpara>
</listitem>
<listitem>
<simpara>Wrap arbitrary writers and strategies with <literal>anytype</literal>, preserving zero-cost abstractions while keeping call sites tidy. See <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/io/Writer.zig">Writer.zig</link>.</simpara>
</listitem>
<listitem>
<simpara>Apply <literal>anyopaque</literal> pointers and explicit vtables to erase types safely, aligning state and handling lifetimes without undefined behavior.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="comptime-contracts">
<title>Comptime contracts as interfaces</title>
<simpara>A Zig function becomes generic the moment it accepts a <literal>comptime</literal> parameter. By pairing that flexibility with capability checks—<literal>@hasDecl</literal>, <literal>@TypeOf</literal>, or even custom predicates—you can encode rich structural interfaces without heavyweight trait systems. <link xl:href="15__comptime-and-reflection.xml">15</link> We start by seeing how a metric aggregator contract pushes errors to compile time instead of relying on runtime assertions.</simpara>
<section xml:id="contracts-validate">
<title>Validating structural requirements</title>
<simpara><literal>computeReport</literal> below accepts an analyzer type that must expose <literal>State</literal>, <literal>Summary</literal>, <literal>init</literal>, <literal>observe</literal>, and <literal>summarize</literal>. The <literal>validateAnalyzer</literal> helper makes these requirements explicit; forgetting a method gives a precise <literal>@compileError</literal> instead of a mysterious instantiation failure. We demonstrate the pattern with a <literal>RangeAnalyzer</literal> and a <literal>MeanVarianceAnalyzer</literal>.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 17__generic-apis-and-type-erasure.adoc - include::example$chapters-data/code/17__generic-apis-and-type-erasure/comptime_contract.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/17__generic-apis-and-type-erasure/comptime_contract.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Range -&gt; min=21.00 max=24.00 spread=3.00
Mean/variance -&gt; mean=22.70 variance=1.124</programlisting>
</para>
</formalpara>
<tip>
<simpara>The contract remains zero-cost: once validated, the analyzer methods inline as if you had written specialized code, while still surfacing readable diagnostics for downstream users.</simpara>
</tip>
</section>
<section xml:id="contracts-diagnostics">
<title>Diagnosing capability gaps</title>
<simpara>Because <literal>validateAnalyzer</literal> centralizes the checks, you can extend the interface over time—by requiring <literal>pub const SummaryFmt = []const u8</literal>, for instance—without touching every call site. When an adopter upgrades and misses a new declaration, the compiler reports exactly which requirement is absent. This “fail fast, fail specific” strategy scales especially well for internal frameworks and prevents silent drift between modules. <link xl:href="36__style-and-best-practices.xml">37</link></simpara>
</section>
<section xml:id="contracts-tradeoffs">
<title>Trade-offs and batching considerations</title>
<simpara>Keep contract predicates cheap. Anything more than a handful of <literal>@hasDecl</literal> checks or straightforward type comparisons should be factored behind an opt-in feature flag or cached in a <literal>comptime var</literal>. Heavy analysis in a widely-instantiated helper quickly balloons compile times—profile with <literal>zig build --verbose-cc</literal> if a generic takes longer than expected. <link xl:href="38__zig-cli-deep-dive.xml">40</link></simpara>
</section>
<section xml:id="contracts-internpool">
<title>Under the hood: InternPool and generic instances</title>
<simpara>When <literal>computeReport</literal> is instantiated with a concrete analyzer, the compiler resolves all of the involved types and values through a shared <literal>InternPool</literal>. This structure guarantees that each unique analyzer <literal>State</literal>, <literal>Summary</literal>, and function type has a single canonical identity before code generation.</simpara>
<literallayout class="monospaced">graph TB
	IP["InternPool"]

	subgraph "Threading"
		LOCALS["locals: []Local&lt;br/&gt;(one per thread)"]
		SHARDS["shards: []Shard&lt;br/&gt;(concurrent writes)"]
		TIDWIDTH["tid_width / tid_shift_*"]
	end

	subgraph "Core Storage"
		ITEMS["items: []Item"]
		EXTRADATA["extra_data: []u32"]
		STRINGS["string_bytes"]
		LIMBS["limbs: []Limb"]
	end

	subgraph "Dependency Tracking"
		SRCHASHDEPS["src_hash_deps"]
		NAVVALDEPS["nav_val_deps"]
		NAVTYDEPS["nav_ty_deps"]
		INTERNEDDEPS["interned_deps"]
	end

	subgraph "Symbol Tables"
		NAVS["navs: []Nav"]
		NAMESPACES["namespaces: []Namespace"]
		CAUS["caus: []Cau"]
	end

	subgraph "Special Indices"
		NONE["Index.none"]
		UNREACHABLE["Index.unreachable_value"]
		TYPEINFO["Index.type_info_type"]
		ANYERROR["Index.anyerror_type"]
	end

	IP --&gt; LOCALS
	IP --&gt; SHARDS
	IP --&gt; TIDWIDTH
	IP --&gt; ITEMS
	IP --&gt; EXTRADATA
	IP --&gt; STRINGS
	IP --&gt; LIMBS
	IP --&gt; SRCHASHDEPS
	IP --&gt; NAVVALDEPS
	IP --&gt; NAVTYDEPS
	IP --&gt; INTERNEDDEPS
	IP --&gt; NAVS
	IP --&gt; NAMESPACES
	IP --&gt; CAUS
	IP --&gt; NONE
	IP --&gt; UNREACHABLE
	IP --&gt; TYPEINFO
	IP --&gt; ANYERROR</literallayout>
<simpara>Key properties:</simpara>
<itemizedlist>
<listitem>
<simpara>Content-addressed storage: Each unique type/value is stored once, identified by an <literal>Index</literal>.</simpara>
</listitem>
<listitem>
<simpara>Thread-safe: <literal>shards</literal> allow concurrent writes via fine-grained locking.</simpara>
</listitem>
<listitem>
<simpara>Dependency tracking: Maps from source hashes, Navs, and interned values to dependent analysis units.</simpara>
</listitem>
<listitem>
<simpara>Special values: Pre-allocated indices for common types like <literal>anyerror_type</literal>, <literal>type_info_type</literal>, etc.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="anytype-forwarding">
<title>Forwarding with <literal>anytype</literal> wrappers</title>
<simpara>Once you trust the capabilities of a concrete type, you often want to wrap or adapt it without reifying a trait object. <literal>anytype</literal> is the perfect tool: it copies the concrete type into the wrapper’s signature, preserving monomorphized performance while allowing you to build chains of decorators. <link xl:href="15__comptime-and-reflection.xml">15</link> The next example shows a reusable “prefixed writer” that works equally well for fixed buffers and growable lists.</simpara>
<section xml:id="anytype-wrapper">
<title>A reusable prefixed writer</title>
<simpara>We fabricate two sinks: a fixed-buffer stream from the reorganized <literal>std.Io</literal> namespace and a heap-backed <literal>ArrayList</literal> wrapper with its own <literal>GenericWriter</literal>. <literal>withPrefix</literal> captures their concrete writer types via <literal>@TypeOf</literal>, returning a struct whose <literal>print</literal> method prepends a label before forwarding to the inner writer.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 17__generic-apis-and-type-erasure.adoc - include::example$chapters-data/code/17__generic-apis-and-type-erasure/prefixed_writer.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/17__generic-apis-and-type-erasure/prefixed_writer.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">Fixed buffer stream captured:
[stream] value = 42
[stream] tuple = .{ 1, 2, 3 }
ArrayList writer captured:
[array] flags = .{ true, false }
[array] label = generic</programlisting>
</para>
</formalpara>
<note>
<simpara><literal>std.Io.fixedBufferStream</literal> and <literal>std.io.GenericWriter</literal> were both polished in Zig 0.15.2 to emphasize explicit writer contexts, which is why we pass the allocator into <literal>ListSink.writer()</literal> each time. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Io/fixed_buffer_stream.zig">fixed_buffer_stream.zig</link></simpara>
</note>
</section>
<section xml:id="anytype-guardrails">
<title>Guardrails for <literal>anytype</literal></title>
<simpara>Prefer <literal>anytype</literal> in helpers that merely forward calls; export public APIs with explicit <literal>comptime T: type</literal> parameters so that documentation and tooling stay honest. If a wrapper accepts <literal>anytype</literal> but inspects <literal>@TypeInfo</literal> deeply, document the expectation and consider moving the predicate into a reusable validator like we did with analyzers. That way a future refactor can upgrade the constraint without rewriting the wrapper. <link xl:href="36__style-and-best-practices.xml">37</link></simpara>
</section>
<section xml:id="anytype-meta">
<title><literal>std.meta</literal> helpers for structural contracts</title>
<simpara>When an <literal>anytype</literal> wrapper needs to understand the shape of the value it is forwarding, <literal>std.meta</literal> offers small, composable "view" functions. They are used pervasively in the standard library to implement generic helpers that adapt to arrays, slices, optionals, and unions at compile time.</simpara>
<literallayout class="monospaced">graph TB
	subgraph "Type Extractors"
		CHILD["Child(T)"]
		ELEM["Elem(T)"]
		SENTINEL["sentinel(T)"]
		TAG["Tag(T)"]
		ACTIVETAG["activeTag(union)"]
	end

	subgraph "Input Types"
		ARRAY["array"]
		VECTOR["vector"]
		POINTER["pointer"]
		OPTIONAL["optional"]
		UNION["union"]
		ENUM["enum"]
	end

	ARRAY --&gt; CHILD
	VECTOR --&gt; CHILD
	POINTER --&gt; CHILD
	OPTIONAL --&gt; CHILD

	ARRAY --&gt; ELEM
	VECTOR --&gt; ELEM
	POINTER --&gt; ELEM

	ARRAY --&gt; SENTINEL
	POINTER --&gt; SENTINEL

	UNION --&gt; TAG
	ENUM --&gt; TAG
	UNION --&gt; ACTIVETAG</literallayout>
<simpara>Key type extraction functions:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Child(T)</literal>: Extracts the child type from arrays, vectors, pointers, and optionals (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/meta.zig#L83-91">meta.zig:83-91</link>).</simpara>
</listitem>
<listitem>
<simpara><literal>Elem(T)</literal>: Gets the element type from memory span types (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/meta.zig#L102-118">meta.zig:102-118</link>).</simpara>
</listitem>
<listitem>
<simpara><literal>sentinel(T)</literal>: Returns the sentinel value, if present (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/meta.zig#L134-150">meta.zig:134-150</link>).</simpara>
</listitem>
<listitem>
<simpara><literal>Tag(T)</literal>: Gets the tag type from enums and unions (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/meta.zig#L628-634">meta.zig:628-634</link>).</simpara>
</listitem>
<listitem>
<simpara><literal>activeTag(u)</literal>: Returns the active tag of a union value (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/meta.zig#L651-654">meta.zig:651-654</link>).</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="anytype-inline">
<title>Inline costs and specialization</title>
<simpara>Each distinct concrete writer instantiates a fresh copy of the wrapper. Use this to your advantage—attach comptime-known prefixes, bake in field offsets, or gate an <literal>inline for</literal> that only triggers for tiny objects. If the wrapper might be applied to dozens of types, double-check code size with <literal>zig build-exe -femit-bin=</literal> to avoid bloating binaries. <link xl:href="39__performance-and-inlining.xml">41</link></simpara>
</section>
</chapter>
<chapter xml:id="type-erasure">
<title>Runtime type erasure with vtables</title>
<simpara>Sometimes you need to hold a heterogeneous set of strategies at runtime: logging backends, diagnostics passes, or data sinks discovered via configuration. Zig’s answer is explicit vtables containing function pointers plus <literal>*anyopaque</literal> state that you allocate yourself. The compiler stops enforcing structure, so it becomes your responsibility to maintain alignment, lifetime, and error propagation.</simpara>
<section xml:id="erasure-demo">
<title>Typed state, erased handles</title>
<simpara>The registry below manages two text processors. Each factory allocates a strongly-typed state, casts it to <literal>*anyopaque</literal>, and stores it alongside a vtable of function pointers. Helper functions <literal>statePtr</literal> and <literal>stateConstPtr</literal> recover the original types with <literal>@alignCast</literal>, ensuring we never violate alignment requirements.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 17__generic-apis-and-type-erasure.adoc - include::example$chapters-data/code/17__generic-apis-and-type-erasure/type_erasure_registry.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/17__generic-apis-and-type-erasure/type_erasure_registry.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">[char-tally] vowels=30 digits=0
[word-stats] chars=97 sentences=2 longest-word=10</programlisting>
</para>
</formalpara>
<important>
<simpara>Keep track of lifetimes—the arena allocator outlives the processors, so the erased pointers stay valid. Switching to a scoped allocator would require a matching <literal>destroy</literal> hook in the vtable to avoid dangling pointers. <link xl:href="10__allocators-and-memory-management.xml">10</link>, <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/mem/Allocator.zig">Allocator.zig</link></simpara>
</important>
</section>
<section xml:id="erasure-allocator-vtable">
<title>Standard allocator as a vtable case study</title>
<simpara>The standard library&#8217;s <literal>std.mem.Allocator</literal> is itself a type-erased interface: every allocator implementation provides a concrete state pointer plus a vtable of function pointers. This mirrors the registry pattern above but in a form that the entire ecosystem relies on.</simpara>
<literallayout class="monospaced">graph TB
	ALLOC["Allocator"]
	PTR["ptr: *anyopaque"]
	VTABLE["vtable: *VTable"]

	ALLOC --&gt; PTR
	ALLOC --&gt; VTABLE

	subgraph "VTable Functions"
		ALLOCFN["alloc(*anyopaque, len, alignment, ret_addr)"]
		RESIZEFN["resize(*anyopaque, memory, alignment, new_len, ret_addr)"]
		REMAPFN["remap(*anyopaque, memory, alignment, new_len, ret_addr)"]
		FREEFN["free(*anyopaque, memory, alignment, ret_addr)"]
	end

	VTABLE --&gt; ALLOCFN
	VTABLE --&gt; RESIZEFN
	VTABLE --&gt; REMAPFN
	VTABLE --&gt; FREEFN

	subgraph "High-Level API"
		CREATE["create(T)"]
		DESTROY["destroy(ptr)"]
		ALLOCAPI["alloc(T, n)"]
		FREE["free(slice)"]
		REALLOC["realloc(slice, new_len)"]
	end

	ALLOC --&gt; CREATE
	ALLOC --&gt; DESTROY
	ALLOC --&gt; ALLOCAPI
	ALLOC --&gt; FREE
	ALLOC --&gt; REALLOC</literallayout>
<simpara>The <literal>Allocator</literal> type is defined in <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/mem/Allocator.zig#L7-20">Allocator.zig:7-20</link> as a type-erased interface with a pointer and vtable. The vtable contains four fundamental operations:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>alloc</literal>: Returns a pointer to <literal>len</literal> bytes with the specified alignment, or null on failure (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/mem/Allocator.zig#L29">Allocator.zig:29</link>).</simpara>
</listitem>
<listitem>
<simpara><literal>resize</literal>: Attempts to expand or shrink memory in place (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/mem/Allocator.zig#L48">Allocator.zig:48</link>).</simpara>
</listitem>
<listitem>
<simpara><literal>remap</literal>: Attempts to expand or shrink memory, allowing relocation (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/mem/Allocator.zig#L69">Allocator.zig:69</link>).</simpara>
</listitem>
<listitem>
<simpara><literal>free</literal>: Frees and invalidates a region of memory (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/mem/Allocator.zig#L81">Allocator.zig:81</link>).</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="erasure-safety">
<title>Safety notes for <literal>anyopaque</literal></title>
<simpara><literal>anyopaque</literal> has a declared alignment of one, so every downcast must assert the true alignment with <literal>@alignCast</literal>. Skipping that assertion is illegal behavior even if the pointer happens to be properly aligned at runtime. Consider stashing the allocator and a cleanup function inside the vtable when ownership spans multiple modules.</simpara>
</section>
<section xml:id="erasure-interop">
<title>When to graduate to modules or packages</title>
<simpara>Manual vtables shine for small, closed sets of behaviors. As soon as the surface area grows, migrate to a module-level registry that exposes constructors returning typed handles. Consumers still receive erased pointers, but the module can enforce invariants and share helper code for alignment, cleanup, and panic diagnostics. <link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>Favor small, intention-revealing validator helpers—long <literal>validateX</literal> functions are ripe for extraction into reusable comptime utilities. <link xl:href="15__comptime-and-reflection.xml">15</link></simpara>
</listitem>
<listitem>
<simpara><literal>anytype</literal> wrappers generate one instantiation per concrete type. Profile binary size when exposing them in widely-used libraries. <link xl:href="39__performance-and-inlining.xml">41</link></simpara>
</listitem>
<listitem>
<simpara>Type erasure pushes correctness to the programmer. Add assertions, logging, or debug toggles in development builds to prove that downcasts and lifetimes remain valid. <link xl:href="37__illegal-behavior-and-safety-modes.xml">39</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Extend <literal>validateAnalyzer</literal> to require an optional <literal>summarizeError</literal> function and demonstrate custom error sets in a test. <link xl:href="13__testing-and-leak-detection.xml">13</link></simpara>
</listitem>
<listitem>
<simpara>Add a <literal>flush</literal> capability to <literal>PrefixedWriter</literal>, detecting at comptime whether the inner writer exposes the method and adapting accordingly. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/meta.zig">meta.zig</link></simpara>
</listitem>
<listitem>
<simpara>Introduce a third processor that streams hashes into a <literal>std.crypto.hash.sha2.Sha256</literal> context, then prints the digest in hex when finished. <link xl:href="50__random-and-math.xml">52</link>, <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/crypto/sha2.zig">sha2.zig</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Alternatives &amp; Edge Cases</title>
<itemizedlist>
<listitem>
<simpara>If compile-time validation depends on user-supplied types from other packages, add smoke tests so regressions surface before integration builds. <link xl:href="22__build-system-deep-dive.xml">22</link></simpara>
</listitem>
<listitem>
<simpara>Prefer <literal>union(enum)</literal> with payloaded variants when only a handful of strategies exist; vtables pay off once you cross from “few” to “many.” <link xl:href="08__user-types-structs-enums-unions.xml">08</link></simpara>
</listitem>
<listitem>
<simpara>For plug-in systems loaded from shared objects, pair erased state with explicit ABI-safe trampolines to keep portability manageable. <link xl:href="33__c-interop-import-export-abi.xml">33</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>