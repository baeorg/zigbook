<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Random and Math</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>With compression pipelines in place from <link xl:href="49__compression-and-archives.xml">the previous chapter</link>, we now zoom in on the numeric engines that feed those workflows: deterministic pseudo-random number generators, well-behaved math helpers, and hashing primitives that balance speed and security. Zig 0.15.2 keeps these components modular—<literal>std.Random</literal> builds reproducible sequences, <literal>std.math</literal> provides careful tolerances and constants, and the stdlib splits hashing into non-crypto and crypto families so you can choose the right tool per workload. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/math.zig">math.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/hash/wyhash.zig">wyhash.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/crypto/sha2.zig">sha2.zig</link></simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Seed, advance, and reproduce <literal>std.Random</literal> generators while sampling common distributions. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Random/Xoshiro256.zig">Xoshiro256.zig</link></simpara>
</listitem>
<listitem>
<simpara>Apply <literal>std.math</literal> utilities—constants, clamps, tolerances, and geometry helpers—to keep numeric code stable. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/math/hypot.zig">hypot.zig</link></simpara>
</listitem>
<listitem>
<simpara>Distinguish fast hashers like Wyhash from cryptographic digests such as SHA-256, and wire both into file-processing jobs responsibly.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="random-foundations">
<title>Random number foundations</title>
<simpara>Zig exposes pseudo-random generators as first-class values: you seed an engine, ask it for integers, floats, or indices, and your code owns the state transitions. That transparency gives you control over fuzzers, simulations, and deterministic tests. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Random.zig">Random.zig</link></simpara>
<section xml:id="random-foundations-prngs">
<title>Deterministic generators with reproducible sequences</title>
<simpara><literal>std.Random.DefaultPrng</literal> wraps <literal>Xoshiro256++</literal>, seeding itself via SplitMix64 when you call <literal>init(seed)</literal>. From there you obtain a <literal>Random</literal> facade that exposes high-level helpers—ranges, shuffles, floats—while keeping the underlying state private.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 50__random-and-math.adoc - include::example$chapters-data/code/50__random-and-math/prng_sequences.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run prng_sequences.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">seed=0x00067B20
d6 roll -&gt; 5
coin flip -&gt; tails
shuffled ladder -&gt; { 0, 4, 3, 2, 5, 1 }
unit float -&gt; 0.742435
first three u32 -&gt; { 2135551917, 3874178402, 2563214192 }</programlisting>
</para>
</formalpara>
<tip>
<simpara>The fairness guarantees of <literal>uintLessThan</literal> hinge on the generator’s uniform output; fall back to <literal>uintLessThanBiased</literal> when constant-time behavior matters more than perfect distribution.</simpara>
</tip>
</section>
<section xml:id="random-foundations-distributions">
<title>Working with distributions and sampling heuristics</title>
<simpara>Beyond uniform draws, <literal>Random.floatNorm</literal> and <literal>Random.floatExp</literal> expose Ziggurat-backed normal and exponential samples—ideal for synthetic workloads or noise injection. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Random/ziggurat.zig">ziggurat.zig</link> Weighted choices come from <literal>weightedIndex</literal>, while <literal>.jump()</literal> on Xoshiro engines deterministically leaps ahead by 2^128 steps to partition streams across threads without overlap. <link xl:href="29__threads-and-atomics.xml">29</link> For cryptographic uses, swap to <literal>std.crypto.random</literal> or <literal>std.Random.DefaultCsprng</literal> to inherit ChaCha-based entropy rather than a fast-but-predictable PRNG. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/crypto/tlcsprng.zig">tlcsprng.zig</link></simpara>
</section>
</chapter>
<chapter xml:id="math-utilities">
<title>Practical math utilities</title>
<simpara>The <literal>std.math</literal> namespace combines fundamental constants with measured utilities: clamps, approximate equality, and geometry helpers all share consistent semantics across CPU targets.</simpara>
<section xml:id="math-utilities-toolkit">
<title>Numeric hygiene toolkit</title>
<simpara>Combining a handful of helpers—<literal>sqrt</literal>, <literal>clamp</literal>, approximate equality, and the golden ratio constant—keeps reporting code readable and portable. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/math/sqrt.zig">sqrt.zig</link></simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 50__random-and-math.adoc - include::example$chapters-data/code/50__random-and-math/math_inspector.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run math_inspector.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">sample count -&gt; 6
min/max -&gt; 0.87 / 1.11
mean -&gt; 0.997
rms -&gt; 1.000
normalized mean -&gt; 0.328
72deg in rad -&gt; 1.256637
close to right angle? -&gt; no
hypot(3,4) -&gt; 5.0
phi constant -&gt; 1.618033989</programlisting>
</para>
</formalpara>
<note>
<simpara>Prefer <literal>approxEqRel</literal> for large-magnitude comparisons and <literal>approxEqAbs</literal> near zero; both honor IEEE-754 edge cases without tripping NaNs.</simpara>
</note>
</section>
<section xml:id="math-utilities-scaling">
<title>Tolerances, scaling, and derived quantities</title>
<simpara>Angular conversions use <literal>rad_per_deg</literal>/<literal>deg_per_rad</literal>, while <literal>hypot</literal> preserves precision in Pythagorean calculations by avoiding catastrophic cancellation. When chaining transforms, keep intermediate results in <literal>f64</literal> even if your public API uses narrower floats—the mixed-type overloads in <literal>std.math</literal> do the right thing and avoid compiler warnings. <link xl:href="39__performance-and-inlining.xml">39</link></simpara>
</section>
</chapter>
<chapter xml:id="hashing-integrity">
<title>Hashing: reproducibility versus integrity</title>
<simpara>Zig splits hashing strategies sharply: <literal>std.hash</literal> families target speed and low collision rates for in-memory buckets, whereas <literal>std.crypto.hash.sha2</literal> delivers standardized digests for integrity checks or signature pipelines.</simpara>
<section xml:id="hashing-integrity-noncrypto">
<title>Non-cryptographic hashing for buckets</title>
<simpara><literal>std.hash.Wyhash.hash</literal> produces a 64-bit value seeded however you like, ideal for hash maps or bloom filters where avalanche properties matter more than resistance to adversaries. If you need structured hashing with compile-time type awareness, <literal>std.hash.autoHash</literal> walks your fields recursively and feeds them into a configurable backend. <link xl:href="44__collections-and-algorithms.xml">44</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/hash/auto_hash.zig">auto_hash.zig</link></simpara>
</section>
<section xml:id="hashing-integrity-sha256">
<title>SHA-256 digest pipeline with pragmatic guardrails</title>
<simpara>Even when your CLI only needs a checksum, treat SHA-256 as an integrity primitive—not an authenticity guarantee—and document that difference for users.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 50__random-and-math.adoc - include::example$chapters-data/code/50__random-and-math/hash_digest_tool.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run hash_digest_tool.zig -- chapters-data/code/50__random-and-math/payload.txt</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">wyhash(seed=0) payload preview -&gt; 0x30297ecbb2bd0c02
sha256(chapters-data/code/50__random-and-math/payload.txt) -&gt;
  0498ca2116fb55b7a502d0bf3ad5d0e0b3f4e23ad919bdc0f9f151ca3637a6fa
(remember: sha256 certifies integrity, not authenticity.)</programlisting>
</para>
</formalpara>
<tip>
<simpara>When hashing large files, stream through a reusable buffer and reuse a single arena allocator for argument parsing to avoid churning the general-purpose allocator. <link xl:href="10__allocators-and-memory-management.xml">10</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig">fmt.zig</link></simpara>
</tip>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara><literal>Random</literal> structs are not thread-safe; split distinct generators per worker or guard access with atomics to avoid shared-state races. <link xl:href="29__threads-and-atomics.xml">29</link></simpara>
</listitem>
<listitem>
<simpara><literal>std.math</literal> functions honor IEEE-754 NaN propagation—never rely on comparisons after invalid operations without explicit checks.</simpara>
</listitem>
<listitem>
<simpara>Cryptographic digests should be paired with signature checks, HMACs, or trusted distribution; SHA-256 alone detects corruption, not tampering. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/crypto/hash_composition.zig">hash_composition.zig</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Replace <literal>DefaultPrng</literal> with <literal>std.Random.DefaultCsprng</literal> in the first example and measure the performance delta across build modes. <link xl:href="39__performance-and-inlining.xml">39</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Random/ChaCha.zig">ChaCha.zig</link></simpara>
</listitem>
<listitem>
<simpara>Extend <literal>math_inspector.zig</literal> to compute confidence intervals using <literal>approxEqRel</literal> to flag outliers in a latency report. <link xl:href="47__time-logging-and-progress.xml">47</link></simpara>
</listitem>
<listitem>
<simpara>Modify <literal>hash_digest_tool.zig</literal> to compute and store SHA-256 digests for every file inside a TAR archive from <link xl:href="49__compression-and-archives.xml">Chapter 49</link>, emitting a manifest alongside the archive. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/tar.zig">tar.zig</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Caveats, alternatives, edge cases</title>
<itemizedlist>
<listitem>
<simpara>Jump functions on Xoshiro mutate state irreversibly; snapshot your generator before calling <literal>jump()</literal> if you need to rewind later.</simpara>
</listitem>
<listitem>
<simpara>Avoid <literal>bytesToHex</literal> for streaming output on gigantic files—prefer incremental encoders to sidestep large stack allocations.</simpara>
</listitem>
<listitem>
<simpara>SHA-256 digests of enormous files (&gt;4 GiB) must account for platform-specific path encodings; normalize UTF-8/UTF-16 earlier in your pipeline to avoid hashing different byte streams. <link xl:href="45__text-formatting-and-unicode.xml">45</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>