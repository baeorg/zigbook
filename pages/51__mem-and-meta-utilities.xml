<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Mem and Meta Utilities</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Having wrangled randomness and numeric helpers in the previous chapter, we now turn to the slice plumbing and reflection primitives that glue many Zig subsystems together.<link xl:href="50__random-and-math.xml">50</link> Zig&#8217;s <literal>std.mem</literal> establishes predictable rules for tokenizing, trimming, searching, and copying arbitrarily shaped data, while <literal>std.meta</literal> exposes enough type information to build lightweight generic helpers without giving up static guarantees.<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/mem.zig">mem.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/meta.zig">meta.zig</link> Together they let you parse configuration files, introspect user-defined structs, and stitch together data pipelines with the same zero-cost abstractions used throughout the standard library.</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Iterate across slices with <literal>std.mem.tokenize*</literal>, <literal>std.mem.split*</literal>, and search routines without allocating.</simpara>
</listitem>
<listitem>
<simpara>Normalize or rewrite slice contents in-place and aggregate results with <literal>std.mem.join</literal> and friends, even when working from stack buffers.<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/heap.zig">heap.zig</link></simpara>
</listitem>
<listitem>
<simpara>Reflect over struct fields using <literal>std.meta.FieldEnum</literal>, <literal>std.meta.fields</literal>, and <literal>std.meta.stringToEnum</literal> to build tiny schema-aware utilities.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="mem-slice-plumbing">
<title>Slice Plumbing with <literal>std.mem</literal></title>
<simpara>Tokenization, splitting, and rewriting all revolve around the same idea: work with borrowed slices instead of allocating new strings. Most <literal>std.mem</literal> helpers therefore accept a borrowed buffer and return slices into the original data, leaving you in control of lifetimes and copying.</simpara>
<section xml:id="mem-tokenization-vs-splitting">
<title>Tokenization Versus Splitting</title>
<simpara>The next example processes a faux configuration blob. It tokenizes lines, trims whitespace, hunts for <literal>key=value</literal> pairs, and normalizes mode names in-place before joining the remaining path list via a fixed buffer allocator.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 51__mem-and-meta-utilities.adoc - include::example$chapters-data/code/51__mem-and-meta-utilities/mem_token_workbench.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run mem_token_workbench.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">normalized mode -&gt; fast_render
log level -&gt; warn
roots (2)
  [0] /srv/www
  [1] /srv/cache
extra segments -&gt; /opt/tools, /opt/tools/bin</programlisting>
</para>
</formalpara>
<tip>
<simpara>Prefer <literal>std.mem.tokenize*</literal> variants when you want to skip delimiters entirely, and <literal>std.mem.split*</literal> when empty segments matter—for example, when you need to detect doubled separators.</simpara>
</tip>
</section>
<section xml:id="mem-copy-rewrite">
<title>Copying, Rewriting, and Aggregating Slices</title>
<simpara><literal>std.mem.copyForwards</literal> guarantees safe overlap when copying forward, while <literal>std.mem.replaceScalar</literal> lets you normalize characters in-place without touching allocation. Once you have the slices you care about, use <literal>std.mem.join</literal> with a <literal>std.heap.FixedBufferAllocator</literal> to coalesce them into a single view without falling back to the general-purpose heap. Keep an eye on buffer lengths (as the example does for <literal>mode_buffer</literal>) so that the rewrite step stays bounds-safe.</simpara>
</section>
</chapter>
<chapter xml:id="meta-reflection">
<title>Reflection Helpers with <literal>std.meta</literal></title>
<simpara>Where <literal>std.mem</literal> keeps data moving, <literal>std.meta</literal> helps describe it. The library exposes field metadata, alignment, and enumerated tags so that you can build schema-aware tooling without macro systems or runtime type information.</simpara>
<section xml:id="meta-field-overrides">
<title>Field-Driven Overrides with <literal>FieldEnum</literal></title>
<simpara>This sample defines a <literal>Settings</literal> struct, prints a schema summary, and applies overrides parsed from a string by dispatching through <literal>std.meta.FieldEnum</literal>. Each assignment uses statically typed code yet supports dynamic key lookup via <literal>std.meta.stringToEnum</literal> and the struct&#8217;s own default values.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 51__mem-and-meta-utilities.adoc - include::example$chapters-data/code/51__mem-and-meta-utilities/meta_struct_report.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run meta_struct_report.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">settings schema:
  - render: bool (align 1) default=false
  - retries: u8 (align 1) default=1
  - mode: []const u8 (align 1) default=slow
  - log_level: []const u8 (align 1) default=info
  - extra_paths: []const u8 (align 1) default=
resolved values:
  render =&gt; true
  retries =&gt; 4
  mode =&gt; fast-render
  log_level =&gt; info
  extra_paths =&gt; /srv/www:/srv/cache
field tags visited: { .render, .retries, .mode, .log_level, .extra_paths }
parsing failures: 0</programlisting>
</para>
</formalpara>
<note>
<simpara><literal>std.meta.tags(FieldEnum(T))</literal> materialises an array of field tags at comptime, making it cheap to track which fields a routine has touched without runtime reflection.</simpara>
</note>
</section>
<section xml:id="meta-schema-patterns">
<title>Schema Inspection Patterns</title>
<simpara>By combining <literal>std.meta.fields</literal> with <literal>@field</literal>, you can emit a documentation table or prepare a lightweight LSP schema for editor integrations. <literal>std.meta.alignment</literal> reports the natural alignment of each field type, while the field iterator exposes default values so you can display sensible fallbacks alongside user-supplied overrides. Because everything happens at compile time, the generated code compiles down to a handful of constants and direct loads.</simpara>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara>When tokenizing, remember that the returned slices alias the original buffer; mutate or copy them before the source goes out of scope.</simpara>
</listitem>
<listitem>
<simpara><literal>std.mem.join</literal> allocates through the supplied allocator—stack-buffer allocators work well for short joins, but switch to a general-purpose allocator as soon as you expect unbounded data.</simpara>
</listitem>
<listitem>
<simpara><literal>std.meta.stringToEnum</literal> performs a linear scan for large enums; cache the result or build a lookup table when parsing untrusted input at scale.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Extend <literal>mem_token_workbench.zig</literal> to detect duplicate roots by sorting or deduplicating the slice list with <literal>std.mem.sort</literal> and <literal>std.mem.indexOf</literal> before joining.</simpara>
</listitem>
<listitem>
<simpara>Augment <literal>meta_struct_report.zig</literal> to emit JSON by pairing <literal>std.meta.fields</literal> with <literal>std.json.StringifyStream</literal>, keeping the compile-time schema but offering machine-readable output.<link xl:href="32__project-http-json-client.xml">32</link></simpara>
</listitem>
<listitem>
<simpara>Add a <literal>strict</literal> flag to the override parser that requires every key in <literal>FieldEnum(Settings)</literal> to appear at least once, using <literal>std.meta.tags</literal> to track coverage.<link xl:href="36__style-and-best-practices.xml">36</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Caveats, Alternatives, Edge Cases</title>
<itemizedlist>
<listitem>
<simpara>If you need delimiter-aware iteration that preserves separators, fall back to <literal>std.mem.SplitIterator</literal>—tokenizers always drop delimiter slices.</simpara>
</listitem>
<listitem>
<simpara>For very large configuration blobs, consider <literal>std.mem.terminated</literal> and sentinel slices so you can stream sections without copying entire files into memory.<link xl:href="28__filesystem-and-io.xml">28</link></simpara>
</listitem>
<listitem>
<simpara><literal>std.meta</literal> intentionally exposes only compile-time data; if you need runtime reflection, you must generate it yourself (for example, via build steps that emit lookup tables).</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>