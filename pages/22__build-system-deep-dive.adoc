////
changes: ["Initial draft covering build.zig fundamentals, std.Build API, and build graph authoring"]
examples_compile: yes
keywords: ["build.zig", "std.Build", "addExecutable", "addModule", "standardTargetOptions", "build graph"]
last_updated: 2025-11-03
last_verified: 2025-11-03
next_chapter: "23__project-library-and-executable-workspace"
open_questions: []
previous_chapter: "21__zig-init-and-package-metadata"
status: draft
xref_complete: true
////

= Build System Deep Dive: `build.zig` & `std.Build`
:chapter-number: 22
:chapter-slug: build-system-deep-dive
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Chapter 21 xref:21__zig-init-and-package-metadata.adoc[21] showed how `build.zig.zon` declares package metadata; this chapter reveals how `build.zig` orchestrates compilation by authoring a directed acyclic graph of build steps using the `std.Build` API, which the build runner executes to produce artifacts—executables, libraries, tests, and custom transformations—while caching intermediate results and parallelizing independent work (see link:https://github.com/ziglang/zig/tree/master/lib/std/Build.zig[Build.zig]).

Unlike `zig run` or `zig build-exe`, which compile a single entry point imperatively, `build.zig` is executable Zig code that constructs a declarative build graph: nodes represent compilation steps, edges represent dependencies, and the build runner (`zig build`) traverses the graph optimally. For release details, see link:https://ziglang.org/download/0.15.1/release-notes.html[v0.15.2].

[[learning-goals]]
== Learning Goals

* Distinguish `zig build` (build graph execution) from `zig run` / `zig build-exe` (direct compilation). 
* Use `b.standardTargetOptions()` and `b.standardOptimizeOption()` to expose user-configurable target and optimization choices.
* Create modules with `b.addModule()` and `b.createModule()`, understanding when to expose modules publicly versus privately (see link:https://github.com/ziglang/zig/tree/master/lib/std/Build/Module.zig[Module.zig]).
* Build executables with `b.addExecutable()`, libraries with `b.addLibrary()`, and wire dependencies between artifacts (see link:https://github.com/ziglang/zig/tree/master/lib/std/Build/Step/Compile.zig[Compile.zig]).
* Integrate tests with `b.addTest()` and wire custom top-level steps with `b.step()`.
* Debug build failures using `zig build -v` and interpret graph errors from missing modules or incorrect dependencies.

[[build-zig-as-code]]
== `build.zig` as Executable Zig Code

Every `build.zig` exports a `pub fn build(b: *std.Build)` function that the build runner invokes after parsing `build.zig.zon` and setting up the build graph context; within this function, you use methods on the `*std.Build` pointer to register steps, artifacts, and dependencies declaratively. xref:21__zig-init-and-package-metadata.adoc[21]

[[imperative-vs-declarative]]
=== Imperative Commands vs. Declarative Graph

When you run `zig run main.zig`, the compiler immediately compiles `main.zig` and executes it—a single-shot imperative workflow. When you run `zig build`, the runner first executes `build.zig` to construct a graph of steps, then analyzes that graph to determine which steps need to run (based on cache state and dependencies), and finally executes those steps in parallel where possible. 

This declarative approach enables:

* **Incremental builds**: unchanged artifacts are not recompiled
* **Parallel execution**: independent steps run simultaneously
* **Reproducibility**: the same graph produces the same outputs
* **Extensibility**: custom steps integrate seamlessly

link:https://github.com/ziglang/zig/blob/master/lib/init/build.zig[build.zig template]

[[minimal-build]]
=== Minimal `build.zig`

The simplest `build.zig` creates one executable and installs it:

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/01_minimal/build.zig[]
----

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/01_minimal/main.zig[]
----

.Build and run
[source,shell]
----
$ zig build
$ ./zig-out/bin/hello
----

.Output
[source,shell]
----
Hello from minimal build!
----

This example hard-codes `b.graph.host` (the machine running the build) as the target and `.Debug` optimization, so users cannot customize it. For real projects, expose these as options.

IMPORTANT: The `build` function does not compile anything itself—it only registers steps in the graph. The build runner executes the graph after `build()` returns.

[[standard-options]]
== Standard Options Helpers

Most projects want users to control the target architecture/OS and optimization level; `std.Build` provides two helpers that expose these as CLI flags and handle defaults gracefully.

[[standard-target-options]]
=== `standardTargetOptions()`: Cross-Compilation Made Easy

`b.standardTargetOptions(.{})` returns a `std.Build.ResolvedTarget` that respects the `-Dtarget=` flag, allowing users to cross-compile without modifying `build.zig`:

[source,shell]
----
$ zig build -Dtarget=x86_64-linux       # Linux x86_64
$ zig build -Dtarget=aarch64-macos      # macOS ARM64
$ zig build -Dtarget=wasm32-wasi        # WebAssembly WASI
----

The empty options struct `(.{})` accepts defaults; you can optionally whitelist targets or specify a fallback:

[source,zig]
----
const target = b.standardTargetOptions(.{
    .default_target = .{ .cpu_arch = .x86_64, .os_tag = .linux },
});
----


[[standard-optimize-options]]
=== `standardOptimizeOption()`: User-Controlled Optimization

`b.standardOptimizeOption(.{})` returns a `std.builtin.OptimizeMode` that respects the `-Doptimize=` flag, with values `.Debug`, `.ReleaseSafe`, `.ReleaseFast`, or `.ReleaseSmall`:

[source,shell]
----
$ zig build                             # Debug (default)
$ zig build -Doptimize=ReleaseFast      # Maximum speed
$ zig build -Doptimize=ReleaseSmall     # Minimum size
----

The options struct accepts a `.preferred_optimize_mode` to suggest a default when the user doesn't specify one. If you pass no preference, the system infers from the package's `release_mode` setting in `build.zig.zon`. xref:21__zig-init-and-package-metadata.adoc[21]

Under the hood, the chosen `OptimizeMode` feeds into the compiler's configuration and affects safety checks, debug information, and backend optimization levels:

[mermaid]
....
graph TB
    subgraph "Optimization Mode Effects"
        OptMode["optimize_mode: OptimizeMode"]

        OptMode --> SafetyChecks["Runtime Safety Checks"]
        OptMode --> DebugInfo["Debug Information"]
        OptMode --> CodegenStrategy["Codegen Strategy"]
        OptMode --> LLVMOpt["LLVM Optimization Level"]

        SafetyChecks --> Overflow["Integer overflow checks"]
        SafetyChecks --> Bounds["Bounds checking"]
        SafetyChecks --> Null["Null pointer checks"]
        SafetyChecks --> Unreachable["Unreachable assertions"]

        DebugInfo --> StackTraces["Stack traces"]
        DebugInfo --> DWARF["DWARF debug info"]
        DebugInfo --> LineInfo["Source line information"]

        CodegenStrategy --> Inlining["Inline heuristics"]
        CodegenStrategy --> Unrolling["Loop unrolling"]
        CodegenStrategy --> Vectorization["SIMD vectorization"]

        LLVMOpt --> O0["Debug: -O0"]
        LLVMOpt --> O2Safe["ReleaseSafe: -O2 + safety"]
        LLVMOpt --> O3["ReleaseFast: -O3"]
        LLVMOpt --> Oz["ReleaseSmall: -Oz"]
    end
....

This is the same `OptimizeMode` that `b.standardOptimizeOption()` returns, so the flags you expose in `build.zig` directly determine which safety checks remain enabled and which optimization pipeline the compiler selects.

[[configurable-example]]
=== Complete Example with Standard Options

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/02_standard_options/build.zig[]
----

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/02_standard_options/main.zig[]
----

.Build and run with options
[source,shell]
----
$ zig build -Dtarget=x86_64-linux -Doptimize=ReleaseFast run
----

.Output (example)
[listing]
----
Target: x86_64-linux
Optimize: ReleaseFast
----

TIP: Always use `standardTargetOptions()` and `standardOptimizeOption()` unless you have a very specific reason to hard-code values (e.g., firmware targeting a fixed embedded system).

[[modules-and-imports]]
== Modules: Public and Private

Zig 0.15.2 distinguishes **public modules** (exposed to consumers via `b.addModule()`) from **private modules** (internal to the current package, created with `b.createModule()`). Public modules appear in downstream `build.zig` files via `b.dependency()`, while private modules exist only within your build graph.

[[add-module-vs-create-module]]
=== `addModule` vs. `createModule`

* `b.addModule(name, options)` creates a module and registers it in the package's public module table, making it available to consumers who depend on this package.
* `b.createModule(options)` creates a module without exposing it; useful for executable-specific code or internal helpers.

Both functions return a `*std.Build.Module`, which you wire into compilation steps via the `.imports` field.

[[module-example]]
=== Example: Public Module and Executable

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/03_modules/build.zig[]
----

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/03_modules/math.zig[]
----

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/03_modules/main.zig[]
----

.Build and run
[source,shell]
----
$ zig build run
----

.Output
[source,shell]
----
10 + 20 = 30
10 * 20 = 200
----

Here `math` is a **public module** (consumers of this package can `@import("math")`), while the executable's root module is **private** (created with `createModule`).

NOTE: The `.imports` field in `Module.CreateOptions` is a slice of `.{ .name = ..., .module = ... }` pairs, allowing you to map arbitrary import names to module pointers—useful for avoiding name collisions when consuming multiple packages.

[[artifacts]]
== Artifacts: Executables, Libraries, Objects

An **artifact** is a compile step that produces a binary output: an executable, a static or dynamic library, or an object file. The `std.Build` API provides `addExecutable()`, `addLibrary()`, and `addObject()` functions that return `*Step.Compile` pointers.

[[add-executable]]
=== `addExecutable()`: Building Programs

`b.addExecutable(.{ .name = ..., .root_module = ... })` creates a `Step.Compile` that links a `main` function (or `_start` for freestanding) into an executable:

[source,zig]
----
const exe = b.addExecutable(.{
    .name = "myapp",
    .root_module = b.createModule(.{
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = optimize,
    }),
});
b.installArtifact(exe);
----

* `.name`: The output filename (e.g., `myapp.exe` on Windows, `myapp` on Unix).
* `.root_module`: The module containing the entry point.
* Optional: `.version`, `.linkage` (for PIE), `.max_rss`, `.use_llvm`, `.use_lld`, `.zig_lib_dir`.



[[add-library]]
=== `addLibrary()`: Static and Dynamic Libraries

`b.addLibrary(.{ .name = ..., .root_module = ..., . linkage = ... })` creates a library:

[source,zig]
----
const lib = b.addLibrary(.{
    .name = "utils",
    .root_module = b.createModule(.{
        .root_source_file = b.path("utils.zig"),
        .target = target,
        .optimize = optimize,
    }),
    . linkage = .static, // or .dynamic
    .version = .{ .major = 1, .minor = 0, .patch = 0 },
});
b.installArtifact(lib);
----

* `.linkage = .static` produces a `.a` (Unix) or `.lib` (Windows) archive.
* `.linkage = .dynamic` produces a `.so` (Unix), `.dylib` (macOS), or `.dll` (Windows) shared library.
* `.version`: Semantic version embedded in the library metadata (Unix only).



[[linking-libraries]]
=== Linking Libraries to Executables

To link a library into an executable, call `exe.linkLibrary(lib)` after creating both artifacts:

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/05_library/build.zig[]
----

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/05_library/utils.zig[]
----

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/05_library/main.zig[]
----

.Build and run
[source,shell]
----
$ zig build run
----

.Output
[source,shell]
----
double(7) = 14
square(7) = 49
----

IMPORTANT: When linking a Zig library, symbols must be `export`ed (for C ABI) or you must use module imports—Zig does not have a linker-level "public Zig API" concept distinct from module exports.

[[install-artifact]]
=== Installing Artifacts: `installArtifact()`

`b.installArtifact(exe)` adds a dependency on the default install step (`zig build` with no arguments) that copies the artifact to `zig-out/bin/` (executables) or `zig-out/lib/` (libraries). You can customize the install directory or skip installation entirely if the artifact is intermediate-only.

[[tests-and-test-steps]]
== Tests and Test Steps

Zig's test blocks integrate directly into the build system: `b.addTest(.{ .root_module = ... })` creates a special executable that runs all `test` blocks in the given module, reporting pass/fail to the build runner. xref:13__testing-and-leak-detection.adoc[13]

[[add-test]]
=== `addTest()`: Compiling Test Executables

[source,zig]
----
const lib_tests = b.addTest(.{
    .root_module = lib_mod,
});

const run_lib_tests = b.addRunArtifact(lib_tests);

const test_step = b.step("test", "Run library tests");
test_step.dependOn(&run_lib_tests.step);
----

`b.addTest()` returns a `*Step.Compile` just like `addExecutable()`, but it compiles the module in test mode, linking the test runner and enabling test-only code paths.

[[test-example]]
=== Complete Test Integration Example

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/04_tests/build.zig[]
----

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/04_tests/lib.zig[]
----

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/04_tests/main.zig[]
----

.Run tests
[source,shell]
----
$ zig build test
----

.Output (success)
[listing]
----
All 3 tests passed.
----

TIP: Create separate test steps for each module to isolate failures and enable parallel test execution.

__To see how this scales up in a large codebase, the Zig compiler's own `build.zig` wires many specialized test steps into a single umbrella `test` step:__

[mermaid]
....
graph TB
    subgraph "Test Steps"
        TEST_STEP["test step<br/>(umbrella step)"]
        FMT["test-fmt<br/>Format checking"]
        CASES["test-cases<br/>Compiler test cases"]
        MODULES["test-modules<br/>Per-target module tests"]
        UNIT["test-unit<br/>Compiler unit tests"]
        STANDALONE["Standalone tests"]
        CLI["CLI tests"]
        STACK_TRACE["Stack trace tests"]
        ERROR_TRACE["Error trace tests"]
        LINK["Link tests"]
        C_ABI["C ABI tests"]
        INCREMENTAL["test-incremental<br/>Incremental compilation"]
    end

    subgraph "Module Tests"
        BEHAVIOR["behavior tests<br/>test/behavior.zig"]
        COMPILER_RT["compiler_rt tests<br/>lib/compiler_rt.zig"]
        ZIGC["zigc tests<br/>lib/c.zig"]
        STD["std tests<br/>lib/std/std.zig"]
        LIBC_TESTS["libc tests"]
    end

    subgraph "Test Configuration"
        TARGET_MATRIX["test_targets array<br/>Different architectures<br/>Different OSes<br/>Different ABIs"]
        OPT_MODES["Optimization modes:<br/>Debug, ReleaseFast<br/>ReleaseSafe, ReleaseSmall"]
        FILTERS["test-filter<br/>test-target-filter"]
    end

    TEST_STEP --> FMT
    TEST_STEP --> CASES
    TEST_STEP --> MODULES
    TEST_STEP --> UNIT
    TEST_STEP --> STANDALONE
    TEST_STEP --> CLI
    TEST_STEP --> STACK_TRACE
    TEST_STEP --> ERROR_TRACE
    TEST_STEP --> LINK
    TEST_STEP --> C_ABI
    TEST_STEP --> INCREMENTAL

    MODULES --> BEHAVIOR
    MODULES --> COMPILER_RT
    MODULES --> ZIGC
    MODULES --> STD

    TARGET_MATRIX --> MODULES
    OPT_MODES --> MODULES
    FILTERS --> MODULES
....

Your own projects can borrow this pattern: one high-level `test` step that fans out to format checks, unit tests, integration tests, and cross-target test matrices, all wired together using the same `b.step` and `b.addTest` primitives. 

[[top-level-steps]]
== Top-Level Steps: Custom Build Commands

A **top-level step** is a named entry point that users invoke with `zig build <step-name>`. You create them with `b.step(name, description)` and wire dependencies using `step.dependOn(other_step)`.

[[step-example]]
=== Creating a `run` Step

[source,zig]
----
const run_step = b.step("run", "Run the application");
const run_cmd = b.addRunArtifact(exe);
run_cmd.step.dependOn(b.getInstallStep());
run_step.dependOn(&run_cmd.step);
----

* `b.step("run", ...)` creates the top-level step users invoke.
* `b.addRunArtifact(exe)` creates a step that executes the compiled binary.
* `run_cmd.step.dependOn(b.getInstallStep())` ensures the binary is installed before running it.
* `run_step.dependOn(&run_cmd.step)` links the top-level step to the run command.

This pattern appears in almost every `zig init`-generated `build.zig`.

__In the Zig compiler's own `build.zig`, the default install and test steps form a larger dependency graph:__

[mermaid]
....
graph TB
    subgraph "Installation Step (default)"
        INSTALL["b.getInstallStep()"]
    end

    subgraph "Compiler Artifacts"
        EXE_STEP["exe.step<br/>(compile compiler)"]
        INSTALL_EXE["install_exe.step<br/>(install binary)"]
    end

    subgraph "Documentation"
        LANGREF["generateLangRef()"]
        INSTALL_LANGREF["install_langref.step"]
        STD_DOCS_GEN["autodoc_test"]
        INSTALL_STD_DOCS["install_std_docs.step"]
    end

    subgraph "Library Files"
        LIB_FILES["installDirectory(lib/)"]
    end

    subgraph "Test Steps"
        TEST["test step"]
        FMT["test-fmt step"]
        CASES["test-cases step"]
        MODULES["test-modules step"]
    end

    INSTALL --> INSTALL_EXE
    INSTALL --> INSTALL_LANGREF
    INSTALL --> LIB_FILES

    INSTALL_EXE --> EXE_STEP
    INSTALL_LANGREF --> LANGREF
    INSTALL --> INSTALL_STD_DOCS
    INSTALL_STD_DOCS --> STD_DOCS_GEN

    TEST --> EXE_STEP
    TEST --> FMT
    TEST --> CASES
    TEST --> MODULES

    CASES --> EXE_STEP
    MODULES --> EXE_STEP
....

Running `zig build` (with no explicit step) typically executes a default install step like this, while `zig build test` executes a dedicated test step that depends on the same core compile actions.

__To place this chapter in the wider Zig toolchain, the compiler's own bootstrap process uses CMake to produce an intermediate `zig2` executable, then invokes `zig2 build` on its native `build.zig` script:__

[mermaid]
....
graph TB
    subgraph "CMake Stage (stage2)"
        CMAKE["CMake"]
        ZIG2_C["zig2.c<br/>(generated C code)"]
        ZIGCPP["zigcpp<br/>(C++ LLVM/Clang wrapper)"]
        ZIG2["zig2 executable"]

        CMAKE --> ZIG2_C
        CMAKE --> ZIGCPP
        ZIG2_C --> ZIG2
        ZIGCPP --> ZIG2
    end

    subgraph "Native Build System (stage3)"
        BUILD_ZIG["build.zig<br/>Native Build Script"]
        BUILD_FN["build() function"]
        COMPILER_STEP["addCompilerStep()"]
        EXE["std.Build.Step.Compile<br/>(compiler executable)"]
        INSTALL["Installation Steps"]

        BUILD_ZIG --> BUILD_FN
        BUILD_FN --> COMPILER_STEP
        COMPILER_STEP --> EXE
        EXE --> INSTALL
    end

    subgraph "Build Arguments"
        ZIG_BUILD_ARGS["ZIG_BUILD_ARGS<br/>--zig-lib-dir<br/>-Dversion-string<br/>-Dtarget<br/>-Denable-llvm<br/>-Doptimize"]
    end

    ZIG2 -->|"zig2 build"| BUILD_ZIG
    ZIG_BUILD_ARGS --> BUILD_FN

    subgraph "Output"
        STAGE3_BIN["stage3/bin/zig"]
        STD_LIB["stage3/lib/zig/std/"]
        LANGREF["stage3/doc/langref.html"]
    end

    INSTALL --> STAGE3_BIN
    INSTALL --> STD_LIB
    INSTALL --> LANGREF
....

__In other words, the same `std.Build` APIs you use for application projects also drive the self-hosted Zig compiler build.__ 

[[custom-options]]
== Custom Build Options

Beyond `standardTargetOptions()` and `standardOptimizeOption()`, you can define arbitrary user-facing flags with `b.option()` and expose them to Zig source code via `b.addOptions()` (see link:https://github.com/ziglang/zig/tree/master/lib/std/Build/Step/Options.zig[Options.zig]).

[[option-api]]
=== `b.option()`: CLI Flags

`b.option(T, name, description)` registers a user-facing flag and returns `?T` (null if the user didn't provide it):

[source,zig]
----
const enable_logging = b.option(bool, "enable-logging", "Enable debug logging") orelse false;
const app_name = b.option([]const u8, "app-name", "Application name") orelse "MyApp";
----

Users pass values via `-Dname=value`:

[source,shell]
----
$ zig build -Denable-logging -Dapp-name=CustomName run
----



[[add-options]]
=== `addOptions()`: Passing Config to Code

`b.addOptions()` creates a step that generates a Zig source file from key-value pairs, which you then import as a module:

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/06_options/build.zig[]
----

[source,zig]
----
include::{sourcedir}/22__build-system-deep-dive/06_options/main.zig[]
----

.Build and run with custom options
[source,shell]
----
$ zig build run -Denable-logging -Dapp-name=TestApp
----

.Output
[source,shell]
----
Application: TestApp
Logging enabled: true
[DEBUG] This is a debug message
----

This pattern avoids the need for environment variables or runtime config files when build-time constants suffice.

The Zig compiler itself uses the same approach: command-line `-D` options are parsed with `b.option()`, collected into an options step with `b.addOptions()`, and then imported as a `build_options` module that regular Zig code can read.

[mermaid]
....
graph LR
    subgraph "Command Line"
        CLI["-Ddebug-allocator<br/>-Denable-llvm<br/>-Dversion-string<br/>etc."]
    end

    subgraph "build.zig"
        PARSE["b.option()<br/>Parse options"]
        OPTIONS["exe_options =<br/>b.addOptions()"]
        ADD["exe_options.addOption()"]

        PARSE --> OPTIONS
        OPTIONS --> ADD
    end

    subgraph "Generated Module"
        BUILD_OPTIONS["build_options<br/>(auto-generated)"]
        CONSTANTS["pub const mem_leak_frames = 4;<br/>pub const have_llvm = true;<br/>pub const version = '0.16.0';<br/>etc."]

        BUILD_OPTIONS --> CONSTANTS
    end

    subgraph "Compiler Source"
        IMPORT["@import('build_options')"]
        USE["if (build_options.have_llvm) { ... }"]

        IMPORT --> USE
    end

    CLI --> PARSE
    ADD --> BUILD_OPTIONS
    BUILD_OPTIONS --> IMPORT
....

Treat `b.addOptions()` as a structured, type-checked configuration channel from your `zig build` command line into ordinary Zig modules, just as the compiler does for its own `build_options` module. 

[[debugging-builds]]
== Debugging Build Failures

When `zig build` fails, the error message usually points to a missing module, incorrect dependency, or misconfigured step. The `-v` flag enables verbose output showing all compiler invocations.

[[verbose-flag]]
=== `zig build -v`: Inspecting Compiler Invocations

[source,shell]
----
$ zig build -v
zig build-exe /path/to/main.zig -target x86_64-linux -O Debug -femit-bin=zig-cache/...
zig build-lib /path/to/lib.zig -target x86_64-linux -O Debug -femit-bin=zig-cache/...
...
----

This reveals the exact `zig` subcommands the build runner executes, helping diagnose flag issues or missing files.

[[common-errors]]
=== Common Graph Errors

* **"module 'foo' not found"**: The `.imports` table doesn't include a module named `foo`, or a dependency wasn't wired correctly.
* **"circular dependency detected"**: Two steps depend on each other transitively—build graphs must be acyclic.
* **"file not found: src/main.zig"**: The path passed to `b.path()` doesn't exist relative to the build root.
* **"no member named 'root_source_file' in ExecutableOptions"**: You're using Zig 0.15.2 syntax with an older compiler, or vice versa.

[[notes-caveats]]
== Notes & Caveats

* The build runner caches artifact hashes in `zig-cache/`; deleting this directory forces a full rebuild.
* Passing `--` after `zig build run` forwards arguments to the executed binary: `zig build run -- --help`.
* `b.installArtifact()` is the canonical way to expose outputs; avoid manual file copying unless you have a specific need.
* The default install step (`zig build` with no arguments) installs all artifacts registered with `installArtifact()`—if you want a no-op default, don't install anything.

[[exercises]]
== Exercises

* Modify the minimal example to hard-code a cross-compilation target (e.g., `wasm32-wasi`) and verify the output format with `file zig-out/bin/hello`. xref:41__cross-compilation-and-wasm.adoc[43]
* Extend the modules example to create a second module `utils` that `math` imports, demonstrating transitive dependencies.
* Add a custom option `-Dmax-threads=N` to the options example and use it to initialize a compile-time constant thread pool size.
* Create a library with both static and dynamic linkage modes, install both, and inspect the output files to see the size difference.

[[caveats-alternatives-edge-cases]]
== Caveats, Alternatives, Edge Cases

* Zig 0.14.0 introduced the `root_module` field; older code using `root_source_file` directly on `ExecutableOptions` will fail on Zig 0.15.2.
* Some projects still use `--pkg-begin`/`--pkg-end` flags manually instead of the module system—these are deprecated and should be migrated to `Module.addImport()`. xref:20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc[20]
* The build runner does not support incremental compilation of `build.zig` itself—changing `build.zig` triggers a full graph re-evaluation.
* If you see "userland" mentioned in documentation, it means the build system is implemented entirely in Zig standard library code, not compiler magic—you can read `std.Build` source to understand any behavior.
