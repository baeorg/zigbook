<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Time, Logging, and Progress</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="_introduction">
<title>Introduction</title>
<simpara>This chapter rounds out everyday operational tools in Zig: precise time measurement (<literal>std.time</literal>), structured logging (<literal>std.log</literal>), and terminal-friendly progress reporting (<literal>std.Progress</literal>). Here we make pipelines observable, measurable, and user-friendly. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/time.zig">time.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/log.zig">log.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Progress.zig">Progress.zig</link></simpara>
<simpara>We&#8217;ll focus on deterministic snippets that work across platforms under Zig 0.15.2, highlighting gotchas, performance notes, and best practices.</simpara>
</chapter>
<chapter xml:id="_timekeeping_with_std_time">
<title>Timekeeping with std.time</title>
<simpara>Zig&#8217;s <literal>std.time</literal> provides:
- Calendar timestamps: <literal>timestamp()</literal>, <literal>milliTimestamp()</literal>, <literal>microTimestamp()</literal>, <literal>nanoTimestamp()</literal>.
- Duration/units: constants like <literal>ns_per_ms</literal>, <literal>ns_per_s</literal>, <literal>s_per_min</literal> for conversions.
- High-precision timers: <literal>Instant</literal> (fast, not strictly monotonic) and <literal>Timer</literal> (monotonic behavior by saturation).</simpara>
<simpara>In general, prefer <literal>Timer</literal> for measuring elapsed durations. Reach for <literal>Instant</literal> only when you need faster sampling and can tolerate occasional non-monotonicity from quirky OS/firmware environments.</simpara>
<section xml:id="_measuring_elapsed_time_timer">
<title>Measuring elapsed time (Timer)</title>
<simpara><literal>Timer</literal> yields monotonic readings (saturating on regressions) and is ideal for benchmarking and timeouts. <link xl:href="39__performance-and-inlining.xml">39</link></simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 47__time-logging-and-progress.adoc - include::example$chapters-data/code/47__time-logging-and-progress/time_timer_sleep.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run time_timer_sleep.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Expected output</title>
<para>
<screen>Timer OK</screen>
</para>
</formalpara>
<note>
<simpara>Sleeping uses <literal>std.Thread.sleep(ns)</literal>. On most OSes the granularity is ~1ms or worse; timers are as precise as the underlying clocks permit. <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Thread.zig">Thread.zig</link></simpara>
</note>
</section>
<section xml:id="_instant_sampling_and_ordering">
<title>Instant sampling and ordering</title>
<simpara><literal>Instant.now()</literal> gives a fast, high-precision timestamp for the current process. It tries to advance during suspend and can be compared or differenced. It is not guaranteed strictly monotonic everywhere. Use <literal>Timer</literal> when you need that property enforced.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 47__time-logging-and-progress.adoc - include::example$chapters-data/code/47__time-logging-and-progress/time_instant_order.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run time_instant_order.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Expected output</title>
<para>
<screen>Instant OK</screen>
</para>
</formalpara>
</section>
<section xml:id="_time_unit_conversions">
<title>Time unit conversions</title>
<simpara>Prefer the provided unit constants over hand-rolled math. They improve clarity and prevent mistakes in mixed units.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 47__time-logging-and-progress.adoc - include::example$chapters-data/code/47__time-logging-and-progress/time_units.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run time_units.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Expected output</title>
<para>
<screen>2 min = 120 s
1 h = 3600000000000 ns</screen>
</para>
</formalpara>
<tip>
<simpara>For calendar computations (year, month, day), see <literal>std.time.epoch</literal> helpers; for file timestamp metadata, see <literal>std.fs.File</literal> APIs. <link xl:href="28__filesystem-and-io.xml">28</link>, <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/time/epoch.zig">epoch.zig</link>, <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fs/File.zig">File.zig</link></simpara>
</tip>
</section>
</chapter>
<chapter xml:id="_logging_with_std_log">
<title>Logging with std.log</title>
<simpara><literal>std.log</literal> is a small, composable logging façade. You can:
- Control log level via <literal>std_options</literal> (defaults are build-mode dependent).
- Use scopes (namespaces) to categorize messages.
- Provide a custom <literal>logFn</literal> to change formatting or redirects.</simpara>
<simpara>Below, we set <literal>.log_level = .info</literal> so debug logs are suppressed, and demonstrate both default and scoped logging.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 47__time-logging-and-progress.adoc - include::example$chapters-data/code/47__time-logging-and-progress/logging_basic.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run logging_basic.zig 2&gt;&amp;1 | cat</programlisting>
</para>
</formalpara>
<formalpara>
<title>Expected output</title>
<para>
<screen>info: starting
warning: high temperature
info(app): running</screen>
</para>
</formalpara>
<simpara>NOTE:
- The default logger writes to stderr, so we use <literal>2&gt;&amp;1</literal> above to show it inline in this book.
- In Debug builds the default level is <literal>.debug</literal>. Override via <literal>std_options</literal> to make examples stable across optimize modes.</simpara>
</chapter>
<chapter xml:id="_progress_reporting_with_std_progress">
<title>Progress reporting with std.Progress</title>
<simpara><literal>std.Progress</literal> draws a small tree of tasks to the terminal, updating periodically from another thread. It is non-allocating and aims to be portable across terminals and Windows consoles. Use it to indicate long-running work such as builds, downloads, or analysis passes.</simpara>
<simpara>The following demo disables printing for deterministic output while exercising the API (root node, children, <literal>completeOne</literal>, <literal>end</literal>). In real tools, omit <literal>disable_printing</literal> to render a dynamic progress view.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 47__time-logging-and-progress.adoc - include::example$chapters-data/code/47__time-logging-and-progress/progress_basic.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run progress_basic.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Expected output</title>
<para>
<screen>no output</screen>
</para>
</formalpara>
<simpara>TIP:
- Use <literal>Options.estimated_total_items</literal> to show counts (“[3/10] compile”);
- Update names with <literal>setName</literal>;
- Signal success/failure via <literal>std.Progress.setStatus</literal>.</simpara>
</chapter>
<chapter xml:id="_notes_and_caveats">
<title>Notes and caveats</title>
<itemizedlist>
<listitem>
<simpara>Timer vs. Instant: prefer <literal>Timer</literal> for elapsed time and monotonic behavior; use <literal>Instant</literal> for fast samples when occasional non-monotonicity is acceptable.</simpara>
</listitem>
<listitem>
<simpara>Sleep resolution is OS-dependent. Don&#8217;t assume sub-millisecond precision.</simpara>
</listitem>
<listitem>
<simpara>Logging filters apply per scope. Use <literal>scoped(.your_component)</literal> to gate noisy subsystems cleanly.</simpara>
</listitem>
<listitem>
<simpara><literal>std.Progress</literal> output adapts to terminal capabilities. On CI/non-TTY or disabled printing, nothing is written.</simpara>
</listitem>
<listitem>
<simpara>Timezone support: stdlib does not yet have a stable <literal>std.tz</literal> module in 0.15.2. Use platform APIs or a library if you need timezone math. [TBD]</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="_exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Write a micro-benchmark using <literal>Timer</literal> to compare two formatting routines. Print the faster one and by how many microseconds.</simpara>
</listitem>
<listitem>
<simpara>Wrap <literal>std.log</literal> with a custom <literal>logFn</literal> that prefixes timestamps from <literal>nanoTimestamp()</literal>. Ensure it remains non-allocating.</simpara>
</listitem>
<listitem>
<simpara>Create a small build simulator with <literal>std.Progress</literal> showing three phases. Make the second phase dynamically increase <literal>estimated_total_items</literal>.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="_open_questions">
<title>Open Questions</title>
<itemizedlist>
<listitem>
<simpara>Timezone helpers in std: status and roadmap for a future <literal>std.tz</literal> or equivalent? [TBD]</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>