////
changes: ["Initial WASI build and run project chapter"]
examples_compile: yes
keywords: ["wasi", "wasm", "build system", "project"]
last_updated: 2025-11-06
last_verified: 2025-11-06
next_chapter: "43__stdlib-index"
open_questions: []
previous_chapter: "41__cross-compilation-and-wasm"
status: draft
xref_complete: true
////

= Project: WASI Build & Run
:chapter-number: 42
:chapter-slug: project-wasi-build-and-run
:creative-commons:
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

With the cross-compilation mechanics from the previous chapter (see xref:41__cross-compilation-and-wasm.adoc[41]), we can now assemble a complete WASI project that compiles to both native and WebAssembly targets using a single `build.zig`. This chapter constructs a small log analyzer CLI that reads input, processes it, and emits summary statistics—functionality that maps cleanly to WASI's file and stdio capabilities (see link:https://github.com/ziglang/zig/tree/master/lib/std/os/wasi.zig[wasi.zig]). You'll write the application once, then generate and test both a Linux executable and a `.wasm` module using runtimes like Wasmtime or Wasmer (see link:https://ziglang.org/download/0.15.1/release-notes.html[v0.15.2]).

The build system will define multiple targets, each with its own artifact, and you'll wire run steps that automatically launch the correct runtime based on target (see xref:22__build-system-deep-dive.adoc[22]). By the end, you'll have a working template for shipping portable command-line tools as both native binaries and WASI modules.

[[learning-goals]]
== Learning Goals

* Structure a Zig project with shared source code that compiles cleanly to `x86_64-linux` and `wasm32-wasi` (see link:https://github.com/ziglang/zig/tree/master/lib/std/Target.zig[Target.zig]).
* Integrate multiple `addExecutable` targets in `build.zig` with distinct optimization and naming strategies (see link:https://github.com/ziglang/zig/tree/master/lib/std/Build.zig[Build.zig]).
* Configure run steps with runtime detection (native vs Wasmtime/Wasmer) and pass arguments through to the final binary (see xref:22__build-system-deep-dive.adoc[22]).
* Test the same logic path in both native and WASI environments, validating cross-platform behavior (see link:https://ziglang.org/documentation/master/#Command-line-flags[#Command-line-flags]).

[[project-structure]]
== Project Structure

We organize the analyzer as a single-package workspace with a `src/` directory containing the entry point and analysis logic. The `build.zig` will create two artifacts: `log-analyzer-native` and `log-analyzer-wasi`.

[[directory-layout]]
=== Directory Layout

[source,text]
----
42-log-analyzer/
├── build.zig
├── build.zig.zon
└── src/
    ├── main.zig
    └── analysis.zig
----

NOTE: The `build.zig.zon` is minimal since we have no external dependencies; it serves as metadata for potential future packaging (see xref:21__zig-init-and-package-metadata.adoc[21]).

[[build-zig-zon]]
=== Package Metadata

[source,zig]
----
include::{sourcedir}/42__project-wasi-build-and-run/build.zig.zon[]
----

TIP: The `.minimum_zig_version` field prevents accidental builds with older compilers that lack WASI improvements introduced in 0.15.2.

[[build-system-setup]]
== Build System Setup

Our `build.zig` defines two executables sharing the same root source file but targeting different platforms. We also add a custom run step for the WASI binary that detects available runtimes.

[[build-zig-multi-target]]
=== Multi-Target Build Script

[source,zig]
----
include::{sourcedir}/42__project-wasi-build-and-run/build.zig[]
----

.Build
[source,shell]
----
$ zig build
----

.Output
[source,shell]
----
(no output on success; artifacts installed to zig-out/bin/)
----

IMPORTANT: The WASI target sets `-OReleaseSmall` to minimize module size, while the native target uses `-OReleaseFast` for runtime speed—demonstrating per-artifact optimization control.

[[analysis-logic]]
== Analysis Logic

The analyzer reads the entire log content, splits it by newlines, counts occurrences of severity keywords (ERROR, WARN, INFO), and prints a summary. We factor the parsing into `analysis.zig` so it can be unit-tested independently of I/O.

[[analysis-module]]
=== Core Analysis Module

[source,zig]
----
include::{sourcedir}/42__project-wasi-build-and-run/src/analysis.zig[]
----

NOTE: By accepting content as a slice, `analyzeLog` remains simple and testable. `main.zig` handles file reading, and the function just processes text (see link:https://github.com/ziglang/zig/tree/master/lib/std/mem.zig[mem.zig]).

[[main-entry-point]]
== Main Entry Point

The entry point parses command-line arguments, reads the entire file content (or stdin), delegates to `analyzeLog`, and prints the results. Both native and WASI builds share this code path; WASI handles file access through its virtualized filesystem or stdin.

[[main-zig]]
=== Main Source File

[source,zig]
----
include::{sourcedir}/42__project-wasi-build-and-run/src/main.zig[]
----

TIP: The `--input` flag allows testing with files; omit it to read from stdin, which WASI runtimes can pipe easily. Note that WASI filesystem access requires explicit capability grants from the runtime (see link:https://github.com/ziglang/zig/tree/master/lib/std/posix.zig[posix.zig]).

[[building-and-running]]
== Building and Running

With the source complete, we can build both targets and run them side-by-side to confirm identical behavior.

[[native-build-run]]
=== Native Execution

[source,shell]
----
$ zig build
$ echo -e "INFO startup\nERROR failed\nWARN retry\nINFO success" > sample.log
$ ./zig-out/bin/log-analyzer-native --input sample.log
----

.Output
[source,shell]
----
analyzing: sample.log
results: INFO=2 WARN=1 ERROR=1
----

[[wasi-build-run]]
=== WASI Execution with Wasmer (Stdin)

[source,shell]
----
$ zig build
$ echo -e "INFO startup\nERROR failed\nWARN retry\nINFO success" | wasmer run zig-out/bin/log-analyzer-wasi.wasm
----

.Output
[source,shell]
----
analyzing: stdin
results: INFO=2 WARN=1 ERROR=1
----

IMPORTANT: WASI stdin piping works reliably across runtimes. File access with `--input` requires capability grants (`--dir` or `--mapdir`) which vary by runtime implementation and may have limitations in preview1.

[[wasi-run-with-wasmer]]
=== Native Stdin Test for Comparison

[source,shell]
----
$ echo -e "INFO startup\nERROR failed\nWARN retry\nINFO success" | ./zig-out/bin/log-analyzer-native
----

.Output
[source,shell]
----
analyzing: stdin
results: INFO=2 WARN=1 ERROR=1
----

TIP: Both native and WASI produce identical output when reading from stdin, demonstrating true source-level portability for command-line tools.

[[zig-build-run-steps]]
== Using `zig build` Run Steps

The `build.zig` includes run step definitions for both targets. Invoke them directly:

[source,shell]
----
$ zig build run-native -- --input sample.log
----

.Output
[source,shell]
----
analyzing: sample.log
results: INFO=2 WARN=1 ERROR=1
----

[source,shell]
----
$ echo -e "INFO test" | zig build run-wasi
----

.Output
[source,shell]
----
analyzing: stdin
results: INFO=1 WARN=0 ERROR=0
----

NOTE: The `run-wasi` step automatically selects an installed WASI runtime (Wasmtime or Wasmer) or errors if neither is available. See the `detectWasiRuntime` helper in `build.zig`.

[[size-comparison]]
== Binary Size Comparison

WASI modules built with `-OReleaseSmall` produce compact artifacts:

[source,shell]
----
$ ls -lh zig-out/bin/log-analyzer-*
----

.Output
[source,shell]
----
-rwxrwxr-x 1 user user 7.9M Nov  6 14:29 log-analyzer-native
-rwxr--r-- 1 user user  18K Nov  6 14:29 log-analyzer-wasi.wasm
----

TIP: The `.wasm` module is dramatically smaller (18KB vs 7.9MB) because it omits native OS integration and relies on the host runtime for system calls, making it ideal for edge deployment or browser environments.

[[extending-the-project]]
== Extending the Project

This template serves as a foundation for more complex CLI tools targeting WASI:

* **JSON output**: Emit structured results using `std.json.stringify`, enabling downstream processing by other tools (see link:https://github.com/ziglang/zig/tree/master/lib/std/json.zig[json.zig]).
* **Streaming from stdin**: The current implementation already handles stdin efficiently by reading all content at once, suitable for logs up to 10MB with the current limit (see xref:28__filesystem-and-io.adoc[28]).
* **Multi-format support**: Accept different log formats (JSON, syslog, custom) and detect them automatically based on content patterns.
* **HTTP frontend**: Package the WASI module for use in a serverless function that accepts logs via POST and returns JSON summaries (see xref:31__networking-http-and-json.adoc[31]).

[[notes-caveats]]
== Notes & Caveats

* WASI preview1 (current snapshot) lacks networking, threading, and has limited filesystem features. Stdin/stdout work reliably, but file access requires runtime-specific capability grants.
* The `zig libc` effort introduced in 0.15.2 shares implementation between musl and wasi-libc, improving consistency and enabling features like `readToEndAlloc` to work identically across platforms.
* WASI runtimes vary in their permission model. Wasmer's `--mapdir` had issues in testing, while stdin piping works universally. Design CLI tools to prefer stdin when targeting WASI.

[[exercises]]
== Exercises

* Add a `--format json` flag that emits `{"info": N, "warn": N, "error": N}` instead of the plaintext summary, then validate the output by piping to `jq`.
* Extend `analysis.zig` with a unit test that verifies case-insensitive matching (e.g., "info" and "INFO" both count), demonstrating `std.ascii.eqlIgnoreCase` (see xref:13__testing-and-leak-detection.adoc[13]).
* Create a third build target for `wasm32-freestanding` (no WASI) that exposes the analyzer as an exported function callable from JavaScript via `@export` (see link:https://github.com/ziglang/zig/tree/master/lib/std/wasm.zig[wasm.zig]).
* Benchmark native vs WASI execution time with a large log file (generate 100k lines), comparing startup overhead and throughput (see xref:40__profiling-optimization-hardening.adoc[40]).

[[caveats-alternatives-edge-cases]]
== Caveats, Alternatives, Edge Cases

* If you need threading, WASI preview2 (component model) introduces experimental concurrency primitives. Consult upstream WASI specs for migration paths.
* For browser targets, switch to `wasm32-freestanding` and use JavaScript interop (`@export`/`@extern`) instead of WASI syscalls (see xref:33__c-interop-import-export-abi.adoc[33]).
* Some WASI runtimes (e.g., Wasmedge) support non-standard extensions like sockets or GPU access. Stick to preview1 for maximum portability, or document runtime-specific dependencies clearly.
