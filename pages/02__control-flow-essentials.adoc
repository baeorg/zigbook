////
changes: ["Initial draft for Control Flow Essentials chapter"]
examples_compile: yes
keywords: ["control-flow", "loops", "switch"]
last_updated: 2025-11-01
last_verified: 2025-11-01
next_chapter: "03__data-fundamentals"
open_questions: []
previous_chapter: "01__boot-basics"
status: reviewed
xref_complete: true
////

= Control Flow Essentials
:chapter-number: 2
:chapter-slug: control-flow-essentials
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Chapter 1 established the building blocks for running a Zig program and working with data; now we turn those values into decisions by walking through the language's control-flow primitives, as described in link:https://ziglang.org/documentation/master/#if[#if]. Control flow in Zig is expression-oriented, so choosing a branch or looping often produces a value instead of merely guiding execution.

We explore the semantics behind loops, labeled flow, and `switch`, emphasizing how `break`, `continue`, and `else` clauses communicate intent in both safe and release builds; see link:https://ziglang.org/documentation/master/#while[#while], link:https://ziglang.org/documentation/master/#for[#for], and link:https://ziglang.org/documentation/master/#switch[#switch].

[[learning-goals]]
== Learning Goals

* Use `if` expressions (with optional payload capture) to derive values while handling missing data paths explicitly.
* Combine `while`/`for` loops with labeled `break`/`continue` to manage nested iteration and exit conditions clearly.
* Apply `switch` to enumerate exhaustive decision tables, including ranges, multiple values, and enumerations.
* Leverage loop `else` clauses and labeled breaks to return values directly from iteration constructs.

[[pipeline-overview]]
== What Happens to Control Flow Code

Before diving into control flow syntax, it is helpful to understand what the compiler does with your `if`, `while`, and `switch` statements. Zig transforms source code through multiple intermediate representations (IRs), each serving a specific purpose:

[mermaid]
....
graph LR
    SOURCE["Source Code<br/>.zig files"]
    TOKENS["Token Stream"]
    AST["AST<br/>(Ast.zig)"]
    ZIR["ZIR<br/>(Zir)"]
    AIR["AIR<br/>(Air.zig)"]
    MIR["MIR<br/>(codegen.AnyMir)"]
    MACHINE["Machine Code"]

    SOURCE -->|"tokenizer.zig"| TOKENS
    TOKENS -->|"Parse.zig"| AST
    AST -->|"AstGen.zig"| ZIR
    ZIR -->|"Sema.zig"| AIR
    AIR -->|"codegen.generateFunction()"| MIR
    MIR -->|"codegen.emitFunction()"| MACHINE
....

|===
| IR Stage | Representation | Key Properties | Purpose for Control Flow

| *Tokens*
| Flat token stream
| Raw lexical analysis
| Recognizes `if`, `while`, `switch` keywords

| *AST*
| Tree structure
| Syntax-correct, untyped
| Preserves structure of nested control flow

| *ZIR*
| Instruction-based IR
| Untyped, single SSA form per declaration
| Lowers control flow to blocks and branches

| *AIR*
| Instruction-based IR
| Fully typed, single SSA form per function
| Type-checked branches with known outcomes

| *MIR*
| Backend-specific IR
| Near machine code, register-allocated
| Converts to jumps and conditional instructions
|===

The control flow constructs you write—`if` expressions, `switch` statements, labeled loops—are systematically lowered through these stages. By the time your code reaches machine code, a `switch` has become a jump table, and a `while` loop is a conditional branch instruction. The diagrams in this chapter show how this lowering happens at the ZIR stage, where control flow becomes explicit blocks and branches.

[[section-1]]
== Core Control Structures

Control flow in Zig treats blocks and loops as expressions, which means each construct can yield a value and participate directly in assignment or return statements. This section steps through conditionals, loops, and `switch`, showing how each fits into the expression model while keeping readability high, as described in link:https://ziglang.org/documentation/master/#Blocks[#Blocks].

[[section-1-sub-a]]
=== Conditionals as Expressions

`if` evaluates to the value of whichever branch runs, and the optional capture form (`if (opt) |value|`) is a concise way to unwrap optionals without shadowing earlier names. Nested labeled blocks (`blk: { ... }`) let you choose among multiple outcomes while still returning a single value.

[source,zig]
----

include::{sourcedir}/02__control-flow-essentials/branching.zig[]

----

.Run
[source,shell]
----
$ zig run branching.zig
----

.Output
[source,shell]
----
sample 0: positive
sample 1: zero
sample 2: missing
sample 3: negative
----

The function returns a `[]const u8` because the `if` expression itself produces the string, stressing how expression-oriented branching keeps call sites compact. The `samples` loop shows that `for` can iterate with an index tuple `(item, index)` yet still rely on the upstream expression to format output.

==== How if-else Expressions Lower to ZIR

When the compiler encounters an `if` expression, it transforms it into blocks and conditional branches in ZIR (Zig Intermediate Representation). The exact lowering depends on whether a result location is needed; see xref:60__advanced-result-location-semantics.adoc#patterns[result location]:

[mermaid]
....
graph TB
    IfNode["if (cond) then_expr else else_expr"] --> EvalCond["Evaluate condition"]

    EvalCond --> CheckRL["Result location needed?"]

    CheckRL -->|No RL| SimpleIf["Generate condbr<br/>Two blocks with breaks"]
    CheckRL -->|With RL| BlockIf["Generate block_inline<br/>Shared result pointer"]

    SimpleIf --> ThenBlock["then_block:<br/>eval then_expr<br/>break value"]
    SimpleIf --> ElseBlock["else_block:<br/>eval else_expr<br/>break value"]

    BlockIf --> AllocResult["alloc_inferred"]
    BlockIf --> ThenBlockRL["then_block:<br/>write to result ptr"]
    BlockIf --> ElseBlockRL["else_block:<br/>write to result ptr"]
....

When you write `const result = if (x > 0) "positive" else "negative"`, the compiler creates two blocks (one for each branch) and uses `break` statements to return the chosen value. This is why `if` expressions can participate in assignments—they compile to blocks that yield values through their break statements.

[[section-1-sub-b]]
=== While and For Loops with Labels

Loops in Zig can deliver values directly by pairing a `break` result with the loop's `else` clause, which fires when execution completes without breaking. Labeled loops (`outer: while (...)`) coordinate nested iteration so you can exit early or skip work without temporary booleans.

[source,zig]
----

include::{sourcedir}/02__control-flow-essentials/loop_labels.zig[]

----

.Run
[source,shell]
----
$ zig run loop_labels.zig
----

.Output
[source,shell]
----
first all-even row: 1
found target value at row 1, column 1
----

The `while` loop's `else null` captures the "no match" case without extra state, and the labeled `break :outer` instantly exits both loops once the target is found. This pattern keeps state handling tight while remaining explicit about the control transfer.

==== How Loops Lower to ZIR

Loops are transformed into labeled blocks with explicit break and continue targets. This is what makes labeled breaks and loop `else` clauses possible:

[mermaid]
....
graph TB
    Loop["while/for"] --> LoopLabel["Create labeled block"]

    LoopLabel --> Condition["Generate loop condition"]
    Condition --> Body["Generate loop body"]
    Body --> Continue["Generate continue expression"]

    LoopLabel --> BreakTarget["break_block target"]
    Body --> ContinueTarget["continue_block target"]

    Continue --> CondCheck["Jump back to condition"]
....

When you write `outer: while (x < 10)`, the compiler creates:

* *break_block*: The target for `break :outer` statements—exits the loop
* *continue_block*: The target for `continue :outer` statements—jumps to the next iteration
* *Loop body*: Contains your code, with access to both targets

This is why you can nest loops and use labeled breaks to exit to a specific level—each loop label creates its own break_block in ZIR. The loop `else` clause is attached to the break_block and only executes when the loop completes without breaking.

[[section-1-sub-c]]
=== `switch` for Exhaustive Decisions

`switch` checks values exhaustively—covering literals, ranges, and enums—and the compiler enforces totality unless you provide an `else` branch. Combining `switch` with helper functions is a clean way to centralize categorization logic.

[source,zig]
----

include::{sourcedir}/02__control-flow-essentials/switch_examples.zig[]

----

.Run
[source,shell]
----
$ zig run switch_examples.zig
----

.Output
[source,shell]
----
0: no progress
2: warming up
5: halfway there
8: almost done
10: perfect run
12: out of range
mode safe -> factor 16
----

Every `switch` must account for all possibilities—once every tag is covered, the compiler verifies there is no missing case. Enumerations eliminate magic numbers while still letting you branch on compile-time-known variants.

==== How `switch` Expressions Lower to ZIR

The compiler transforms `switch` statements into a structured block that handles all cases exhaustively. Range cases, multiple values per prong, and payload captures are all encoded in the ZIR representation:

[mermaid]
....
graph TB
    Switch["switch (target) { ... }"] --> EvalTarget["Evaluate target operand"]
    EvalTarget --> Prongs["Process switch prongs"]

    Prongs --> Multi["Multiple cases per prong"]
    Prongs --> Range["Range cases (a...b)"]
    Prongs --> Capture["Capture payload"]

    Multi --> SwitchBlock["Generate switch_block"]
    Range --> SwitchBlock
    Capture --> SwitchBlock

    SwitchBlock --> ExtraData["Store in extra:<br/>- prong count<br/>- case items<br/>- prong bodies"]
....

Exhaustiveness checking happens during semantic analysis (after ZIR generation) when types are known. The compiler verifies that:

* All enum tags are covered (or an `else` branch exists)
* Integer ranges don't overlap
* No unreachable prongs exist

This is why you cannot accidentally forget a case in a `switch` over an enum—the type system ensures totality at compile time. Range syntax like `0...5` is encoded in the ZIR as a range case, not as individual values.

[[section-2]]
== Workflow Patterns

Combining these constructs unlocks more expressive pipelines: loops gather or filter data, `switch` routes actions, and loop labels keep nested flows precise without introducing mutable sentinels. This section chains the primitives into reusable patterns you can adapt for parsing, simulation, or state machines.

[[workflow-1]]
=== Script Processing with `break` Values

This example interprets a mini instruction stream, using a labeled `for` loop to maintain a running total and stop when a threshold is reached. The `switch` handles command dispatch, including a deliberate `unreachable` when an unknown tag appears during development.

[source,zig]
----

include::{sourcedir}/02__control-flow-essentials/script_runner.zig[]

----

.Run
[source,shell]
----
$ zig run script_runner.zig
----

.Output
[source,shell]
----
stopped at step 3 with total 7
----

The `break :outer` returns a full `Outcome` struct, making the loop act like a search that either finds its target or falls back to the loop's `else`. The explicit `unreachable` documents assumptions for future contributors and activates safety checks in debug builds.

[[workflow-2]]
=== Loop Guards and Early Termination

Sometimes the data itself signals when to stop. This walkthrough identifies the first negative number, then accumulates even values until a `0` sentinel appears, demonstrating loop `else` clauses, labeled `continue`, and conventional `break`.

[source,zig]
----

include::{sourcedir}/02__control-flow-essentials/range_scan.zig[]

----

.Run
[source,shell]
----
$ zig run range_scan.zig
----

.Output
[source,shell]
----
first negative at index 3
encountered zero, breaking out
sum of even prefix values = 16
----

The two loops showcase complementary exit styles: a loop expression with an `else` default, and a labeled loop where `continue` and `break` spell out which iterations contribute to the running total.

[[notes-caveats]]
== Notes & Caveats

* Prefer labeled loops for clarity any time you have nested iteration; it keeps `break`/`continue` explicit and avoids sentinel variables.
* `switch` must remain exhaustive—if you rely on `else`, document the invariant with comments or `unreachable` so future cases are not silently ignored.
* Loop `else` clauses are evaluated only when the loop exits naturally; make sure your `break` paths return values to avoid falling back to unintended defaults.

[[exercises]]
== Exercises

* Extend `branching.zig` with a third branch that formats values greater than 100 differently, confirming the `if` expression still returns a single string.
* Adapt `loop_labels.zig` to return the exact coordinates as a struct via `break :outer`, then print them from `main`.
* Modify `script_runner.zig` to parse characters at runtime (for example, from a byte slice) and add a new command that resets the total, ensuring the `switch` stays exhaustive.
