<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="en">
<info>
<title>Style &amp; Best Practices</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>Overview</title>
<simpara>Finishing the GPU compute project left us with a multi-file workspace that depends on consistent naming, predictable formatting, and steadfast tests (see <link xl:href="35__project-gpu-compute-in-zig.xml">35</link>). This chapter explains how to keep that discipline as codebases evolve. We will pair <literal>zig fmt</literal> conventions with documentation hygiene, surface the idiomatic error-handling patterns that Zig expects, and lean on targeted invariants to keep future refactors safe (see <link xl:href="https://ziglang.org/download/0.15.1/release-notes.html">v0.15.2</link>).</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>Learning Goals</title>
<itemizedlist>
<listitem>
<simpara>Adopt formatting and naming conventions that communicate intent across modules.</simpara>
</listitem>
<listitem>
<simpara>Structure documentation and tests so they form an executable spec for your APIs.</simpara>
</listitem>
<listitem>
<simpara>Apply <literal>defer</literal>, <literal>errdefer</literal>, and invariant helpers to maintain resource safety and correctness in the long term.</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis>Refs: <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/testing.zig">testing.zig</link></emphasis></simpara>
</chapter>
<chapter xml:id="style-foundations">
<title>Foundations: Consistency as a Feature</title>
<simpara>Formatting is not a cosmetic step: the standard formatter eliminates subjective whitespace debates and highlights semantic changes in diffs. <literal>zig fmt</literal> received incremental improvements in 0.15.x to ensure generated code matches what the compiler expects, so projects should wire formatting into editors and CI from the outset. Combine auto-formatting with descriptive identifiers, doc comments, and scoped error sets so readers can follow the control flow without rummaging through implementation details.</simpara>
<section xml:id="documenting-apis">
<title>Documenting APIs with Executable Tests</title>
<simpara>The following example assembles naming, documentation, and testing into a single file. It exposes a small statistics helper, expands the error set when printing, and demonstrates how tests can double as usage examples (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig">fmt.zig</link>).</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 36__style-and-best-practices.adoc - include::example$chapters-data/code/36__style-and-best-practices/01_style_baseline.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig test 01_style_baseline.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">All 3 tests passed.</programlisting>
</para>
</formalpara>
<tip>
<simpara>Treat documentation comments plus unit tests as the minimum viable API reference—both are compiled on every run, so they stay in sync with the code you ship.</simpara>
</tip>
</section>
</chapter>
<chapter xml:id="resource-patterns">
<title>Resource Management &amp; Error Patterns</title>
<simpara>Zig’s standard library favors explicit resource ownership; pairing <literal>defer</literal> with <literal>errdefer</literal> helps ensure that temporary allocations unwind correctly. When parsing user-supplied data, keep the error vocabulary small and deterministic so callers can route failure modes without inspecting strings. See <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fs.zig">fs.zig</link>.</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 36__style-and-best-practices.adoc - include::example$chapters-data/code/36__style-and-best-practices/02_error_handling_patterns.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig test 02_error_handling_patterns.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">All 2 tests passed.</programlisting>
</para>
</formalpara>
<note>
<simpara>Returning slices via <literal>toOwnedSlice</literal> keeps the lifetimes obvious and prevents leaking the backing allocation when parsing fails midway—<literal>errdefer</literal> makes the cleanup explicit (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/mem.zig">mem.zig</link>).</simpara>
</note>
</chapter>
<chapter xml:id="maintainability">
<title>Maintainability Checklist: Guarding Invariants</title>
<simpara>Data structures that defend their own invariants are easier to refactor safely. By isolating the checks in a helper and calling it before and after mutations, you create a single source of truth for correctness. <literal>std.debug.assert</literal> makes the contract visible in debug builds without penalizing release performance (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/debug.zig">debug.zig</link>).</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 36__style-and-best-practices.adoc - include::example$chapters-data/code/36__style-and-best-practices/03_invariant_guard.zig[]</programlisting>
<formalpara>
<title>Run</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig test 03_invariant_guard.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>Output</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">All 2 tests passed.</programlisting>
</para>
</formalpara>
<tip>
<simpara>Capture invariants in unit tests as well—assertions guard developers, while tests stop regressions that slip past manual review.</simpara>
</tip>
</chapter>
<chapter xml:id="notes-caveats">
<title>Notes &amp; Caveats</title>
<itemizedlist>
<listitem>
<simpara><literal>zig fmt</literal> only touches syntax it understands; generated code or embedded strings may still need a manual glance.</simpara>
</listitem>
<listitem>
<simpara>Expand error sets deliberately—combining the smallest possible unions keeps call sites precise and avoids accidental catch-alls (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/error.zig">error.zig</link>).</simpara>
</listitem>
<listitem>
<simpara>Remember to test under both debug and release builds so assertions and <literal>std.debug</literal> checks do not mask production-only issues (see <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/build.zig">build.zig</link>).</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>Exercises</title>
<itemizedlist>
<listitem>
<simpara>Wrap the statistics helper in a module that exposes both mean and variance; add doctests that demonstrate the API from a consumer’s perspective.</simpara>
</listitem>
<listitem>
<simpara>Extend the loader to stream data instead of reading entire files; compare heap usage in release-safe builds to ensure you keep allocations bounded.</simpara>
</listitem>
<listitem>
<simpara>Add a stress test to the ring buffer that interleaves pushes and pops across thousands of operations, then run it under <literal>zig test -Drelease-safe</literal> to confirm invariants survive in optimized builds.</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>Alternatives &amp; Edge Cases</title>
<itemizedlist>
<listitem>
<simpara>Projects with generated code may need formatting exclusions—document those directories so contributors know when <literal>zig fmt</literal> is safe to run.</simpara>
</listitem>
<listitem>
<simpara>Favor small helper functions (like <literal>invariant</literal>) over sprinkling assertions everywhere; centralized checks are easier to audit during reviews.</simpara>
</listitem>
<listitem>
<simpara>When adding new dependencies, gate them behind feature flags or build options so style rules remain enforceable even in minimal configurations.</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>