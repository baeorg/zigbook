////
changes: ["Initial text, formatting, and unicode chapter"]
examples_compile: yes
keywords: ["fmt", "ascii", "unicode", "base64", "formatting", "parsing"]
last_updated: 2025-11-06
last_verified: 2025-11-06
next_chapter: "46__io-and-stream-adapters"
open_questions: []
previous_chapter: "44__collections-and-algorithms"
status: draft
xref_complete: true
////

= Text, Formatting, and Unicode
:chapter-number: 45
:chapter-slug: text-formatting-and-unicode
:creative-commons:
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

After mastering collections for structured data, xref:44__collections-and-algorithms.adoc[44] you now turn to text—the fundamental medium of human-computer interaction. This chapter explores `std.fmt` for formatting and parsing, `std.ascii` for ASCII character operations, `std.unicode` for UTF-8/UTF-16 handling, and encoding utilities like `base64`. link:https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig[fmt.zig] link:https://github.com/ziglang/zig/tree/master/lib/std/ascii.zig[ascii.zig]

Unlike high-level languages that hide encoding complexities, Zig exposes the mechanics: you choose between `[]const u8` (byte slices) and proper Unicode code point iteration, control number formatting precision, and handle encoding errors explicitly.

Text processing in Zig demands awareness of byte vs. character boundaries, allocator usage for dynamic formatting, and the performance implications of different string operations. By chapter's end, you'll format numbers with custom precision, parse integers and floats safely, manipulate ASCII efficiently, navigate UTF-8 sequences, and encode binary data for transport—all with Zig's characteristic explicitness and zero hidden costs. link:https://github.com/ziglang/zig/tree/master/lib/std/unicode.zig[unicode.zig]

[[learning-goals]]
== Learning Goals

* Format values with `Writer.print()` using format specifiers for integers, floats, and custom types. link:https://github.com/ziglang/zig/tree/master/lib/std/Io/Writer.zig[Writer.zig]
* Parse strings into integers (`parseInt`) and floats (`parseFloat`) with proper error handling.
* Use `std.ascii` for character classification (`isDigit`, `isAlpha`, `toUpper`, `toLower`).
* Navigate UTF-8 sequences with `std.unicode` and understand code point vs. byte distinctions.
* Encode and decode Base64 data for binary-to-text transformations. link:https://github.com/ziglang/zig/tree/master/lib/std/base64.zig[base64.zig]
* Implement custom formatters for user-defined types using the `{f}` specifier in Zig 0.15.2.

[[formatting-basics]]
== Formatting with std.fmt

Zig's formatting revolves around `Writer.print(fmt, args)`, which writes formatted output to any `Writer` implementation. Format strings use `{}` placeholders with optional specifiers: `{d}` for decimal, `{x}` for hex, `{s}` for strings, `{any}` for debug representation, and `{f}` for custom formatters.

[[print-basic]]
=== Basic Formatting

The simplest pattern: capture a buffer with `std.io.fixedBufferStream`, then `print` into it.

[source,zig]
----
include::{sourcedir}/45__text-formatting-and-unicode/format_basic.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe format_basic.zig && ./format_basic
----

.Output
[source,shell]
----
Formatted: Answer=42, pi=3.14
----

TIP: `std.io.fixedBufferStream` provides a `Writer` backed by a fixed buffer. No allocation needed. For dynamic output, use `std.ArrayList(u8).writer()`. link:https://github.com/ziglang/zig/tree/master/lib/std/Io/fixed_buffer_stream.zig[fixed_buffer_stream.zig]

[[format-specifiers]]
=== Format Specifiers

Zig's format specifiers control number bases, precision, alignment, and padding.

[source,zig]
----
include::{sourcedir}/45__text-formatting-and-unicode/format_specifiers.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe format_specifiers.zig && ./format_specifiers
----

.Output
[source,shell]
----
Decimal: 255
Hexadecimal (lowercase): ff
Hexadecimal (uppercase): FF
Binary: 11111111
Octal: 377
Float with 2 decimals: 3.14
Scientific notation: 1.23e2
Padded: 00042
Right-aligned:    42
----

NOTE: Use `{d}` for decimal, `{x}` for hex, `{b}` for binary, `{o}` for octal. Precision (`.N`) and width work with floats and integers. Padding with `0` creates zero-filled fields.

[[parsing]]
== Parsing Strings

Zig provides `parseInt` and `parseFloat` for converting text to numbers, returning errors for invalid input rather than crashing or silently failing.

[[parse-int]]
=== Parsing Integers

`parseInt(T, buf, base)` converts a string to an integer of type `T` in the specified base (2-36, or 0 for auto-detection).

[source,zig]
----
include::{sourcedir}/45__text-formatting-and-unicode/parse_int.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe parse_int.zig && ./parse_int
----

.Output
[source,shell]
----
Parsed decimal: 42
Parsed hex: 255
Parsed binary: 7
Auto-detected (0x): 4660
Parse error: InvalidCharacter
----

IMPORTANT: `parseInt` returns `error{Overflow, InvalidCharacter}`. Always handle these explicitly or propagate with `try`. Base 0 auto-detects `0x` (hex), `0o` (octal), `0b` (binary) prefixes.

[[parse-float]]
=== Parsing Floats

`parseFloat(T, buf)` converts a string to a floating-point number, handling scientific notation and special values (`nan`, `inf`).

[source,zig]
----
include::{sourcedir}/45__text-formatting-and-unicode/parse_float.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe parse_float.zig && ./parse_float
----

.Output
[source,shell]
----
Parsed: 3.14159
Scientific: 123000
Special (inf): inf
----

TIP: `parseFloat` supports decimal notation (`3.14`), scientific notation (`1.23e5`), hexadecimal floats (`0x1.8p3`), and special values (`nan`, `inf`, `-inf`). link:https://github.com/ziglang/zig/tree/master/lib/std/fmt/parse_float.zig[parse_float.zig]

[[ascii-operations]]
== ASCII Character Operations

`std.ascii` provides fast character classification and case conversion for 7-bit ASCII. Functions gracefully handle values outside the ASCII range by returning `false` or leaving them unchanged.

[[ascii-classification]]
=== Character Classification

Test whether characters are digits, letters, whitespace, etc.

[source,zig]
----
include::{sourcedir}/45__text-formatting-and-unicode/ascii_classify.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe ascii_classify.zig && ./ascii_classify
----

.Output
[source,shell]
----
'A': alpha=true, digit=false, upper=true
'5': alpha=false, digit=true, upper=false
' ': alpha=false, digit=false, whitespace=true
----

NOTE: ASCII functions operate on bytes (`u8`). Non-ASCII bytes (>127) return `false` for classification checks.

[[ascii-case]]
=== Case Conversion

Convert between uppercase and lowercase for ASCII characters.

[source,zig]
----
include::{sourcedir}/45__text-formatting-and-unicode/ascii_case.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe ascii_case.zig && ./ascii_case
----

.Output
[source,shell]
----
Original: Hello, World!
Uppercase: HELLO, WORLD!
Lowercase: hello, world!
----

IMPORTANT: `std.ascii` functions operate byte-by-byte and only affect ASCII characters. For full Unicode case mapping, use dedicated Unicode libraries or manually handle UTF-8 sequences.

[[unicode]]
== Unicode and UTF-8

Zig strings are `[]const u8` byte slices, typically UTF-8 encoded. `std.unicode` provides utilities for validating UTF-8, decoding code points, and converting between UTF-8 and UTF-16.

[[utf8-validation]]
=== UTF-8 Validation

Check whether a byte sequence is valid UTF-8.

[source,zig]
----
include::{sourcedir}/45__text-formatting-and-unicode/utf8_validate.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe utf8_validate.zig && ./utf8_validate
----

.Output
[source,shell]
----
Valid UTF-8: Hello, 世界
Invalid UTF-8 detected
----

TIP: Use `std.unicode.utf8ValidateSlice` to verify entire strings. Invalid UTF-8 can cause undefined behavior in code that assumes well-formed sequences.

[[utf8-iteration]]
=== Iterating Code Points

Decode UTF-8 byte sequences into Unicode code points using `std.unicode.Utf8View`.

[source,zig]
----
include::{sourcedir}/45__text-formatting-and-unicode/utf8_iterate.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe utf8_iterate.zig && ./utf8_iterate
----

.Output
[source,shell]
----
Code point: U+0048 (H)
Code point: U+0065 (e)
Code point: U+006C (l)
Code point: U+006C (l)
Code point: U+006F (o)
Code point: U+002C (,)
Code point: U+0020 ( )
Code point: U+4E16 (世)
Code point: U+754C (界)
Byte count: 13, Code point count: 9
----

NOTE: UTF-8 is variable-width: ASCII characters are 1 byte, but many Unicode characters require 2-4 bytes. Always iterate code points when character semantics matter, not bytes.

[[base64]]
== Base64 Encoding

Base64 encodes binary data as printable ASCII, useful for embedding binary in text formats (JSON, XML, URLs). Zig provides standard, URL-safe, and custom Base64 variants.

[[base64-basic]]
=== Encoding and Decoding

Encode binary data to Base64 and decode it back.

[source,zig]
----
include::{sourcedir}/45__text-formatting-and-unicode/base64_basic.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe base64_basic.zig && ./base64_basic
----

.Output
[source,shell]
----
Original: Hello, World!
Encoded: SGVsbG8sIFdvcmxkIQ==
Decoded: Hello, World!
----

TIP: `std.base64.standard.Encoder` and `.Decoder` provide encode/decode methods. The `==` padding is optional and can be controlled with encoder options.

[[custom-formatters]]
== Custom Formatters

Implement the `format` function for your types to control how they're printed with `Writer.print()`.

[source,zig]
----
include::{sourcedir}/45__text-formatting-and-unicode/custom_formatter.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe custom_formatter.zig && ./custom_formatter
----

.Output
[source,shell]
----
Point: (10, 20)
----

NOTE: In Zig 0.15.2, the `format` method signature is simplified to: `pub fn format(self: @This(), writer: *std.Io.Writer) std.Io.Writer.Error!void`. Use the `{f}` format specifier to invoke custom formatters (e.g., `"{f}"`, not `"{}"`).

[[bufprint]]
== Formatting to Buffers

For stack-allocated formatting without allocation, use `std.fmt.bufPrint`.

[source,zig]
----
include::{sourcedir}/45__text-formatting-and-unicode/bufprint.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe bufprint.zig && ./bufprint
----

.Output
[source,shell]
----
Formatted: x=42, y=3.14
----

IMPORTANT: `bufPrint` returns `error.NoSpaceLeft` if the buffer is too small. Always size buffers appropriately or handle the error.

[[allocprint]]
== Dynamic Formatting with Allocation

For dynamically sized output, use `std.fmt.allocPrint` which allocates and returns a formatted string.

[source,zig]
----
include::{sourcedir}/45__text-formatting-and-unicode/allocprint.zig[]
----

.Build and Run
[source,shell]
----
$ zig build-exe allocprint.zig && ./allocprint
----

.Output
[source,shell]
----
Dynamic: The answer is 42
----

TIP: `allocPrint` returns a slice you must free with `allocator.free(result)`. Use this when output size is unpredictable.

[[exercises]]
== Exercises

* Write a CSV parser using `std.mem.split` and `parseInt` to read rows of numbers from a comma-separated file. link:https://github.com/ziglang/zig/tree/master/lib/std/mem.zig[mem.zig]
* Implement a hex dump utility that formats binary data as hexadecimal with ASCII representation (similar to `hexdump -C`).
* Create a string validation function that checks if a string contains only ASCII printable characters, rejecting control codes and non-ASCII bytes.
* Build a simple URL encoder/decoder using Base64 for the encoding portion and custom logic for percent-encoding special characters.

[[caveats-alternatives-edge-cases]]
== Caveats, alternatives, edge cases

* **UTF-8 vs. bytes**: Zig strings are `[]const u8`. Always clarify whether you're working with bytes (indexing) or code points (semantic characters). Mismatched assumptions cause bugs with multi-byte characters.
* **Locale-sensitive operations**: `std.ascii` and `std.unicode` don't handle locale-specific case mapping or collation. For Turkish `i` vs. `I` or locale-aware sorting, you need external libraries.
* **Float formatting precision**: `parseFloat` round-trips through text may lose precision for very large or very small numbers. For exact decimal representation, use fixed-point arithmetic or dedicated decimal libraries.
* **Base64 variants**: Standard Base64 uses `+/`, URL-safe uses `-_`. Choose the correct encoder/decoder for your use case (`std.base64.standard` vs. `std.base64.url_safe_no_pad`).
* **Format string safety**: Format strings are `comptime`-checked, but runtime-constructed format strings won't benefit from compile-time validation. Avoid building format strings dynamically when possible.
* **Writer interface**: All formatting functions accept `anytype` Writers, allowing output to files, sockets, ArrayLists, or custom destinations. Ensure your Writer implements `write(self, bytes: []const u8) !usize`.
