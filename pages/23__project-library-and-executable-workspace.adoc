////
changes: ["Complete project demonstrating library and executable workspace with tests and custom steps"]
examples_compile: yes
keywords: ["library", "executable", "workspace", "addLibrary", "installArtifact", "project structure"]
last_updated: 2025-11-03
last_verified: 2025-11-03
next_chapter: "24__zig-package-manager-deep"
open_questions: []
previous_chapter: "22__build-system-deep-dive"
status: draft
xref_complete: true
////

= Project: Library & Executable Workspace
:chapter-number: 23
:chapter-slug: project-library-and-executable-workspace
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

Chapter 22 taught the `std.Build` API mechanics; this chapter consolidates that knowledge through a complete project: **TextKit**, a text processing library paired with a CLI tool that demonstrates real-world patterns for structuring workspaces, organizing modules, linking artifacts, integrating tests, and creating custom build steps. See xref:22__build-system-deep-dive.adoc[22] and link:https://github.com/ziglang/zig/tree/master/lib/std/Build.zig[Build.zig].

By walking through TextKit's implementation—from module organization to build script orchestration—you will understand how professional Zig projects separate concerns between reusable libraries and application-specific executables, while maintaining a single unified build graph that handles compilation, testing, and distribution. See xref:21__zig-init-and-package-metadata.adoc[21] and link:https://github.com/ziglang/zig/tree/master/lib/std/Build/Step/Compile.zig[Compile.zig].

[[learning-goals]]
== Learning Goals

* Structure a workspace with both library and executable artifacts sharing a common `build.zig`.
* Organize library code into multiple modules for maintainability and testability. xref:20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc[20]
* Build a static library with `b.addLibrary()` and install it for external consumption.
* Create an executable that imports and uses the library module. xref:22__build-system-deep-dive.adoc[22]
* Integrate comprehensive tests for both library and executable components. xref:13__testing-and-leak-detection.adoc[13]
* Define custom build steps beyond the default install, run, and test targets.
* Understand the contrast between `zig build` (graph-based) and `zig build-exe` (imperative).

[[project-overview]]
== Project Structure: TextKit

TextKit is a text processing utility consisting of:

* **Library (`textkit`)**: Reusable text processing functions exposed as a module
* **Executable (`textkit-cli`)**: Command-line interface consuming the library
* **Tests**: Comprehensive coverage for library functionality
* **Custom Steps**: Demonstration commands beyond standard build/test/run

[[directory-layout]]
=== Directory Layout

[source,text]
----
textkit/
├── build.zig              # Build graph definition
├── build.zig.zon          # Package metadata
├── sample.txt             # Demo input file
└── src/
    ├── textkit.zig        # Library root (public API)
    ├── string_utils.zig   # String manipulation utilities
    ├── text_stats.zig     # Text analysis functions
    └── main.zig           # CLI executable entry point
----

This layout follows Zig conventions: `src/` contains all source files, `build.zig` orchestrates compilation, and `build.zig.zon` declares package identity. See xref:21__zig-init-and-package-metadata.adoc[21] and link:https://github.com/ziglang/zig/blob/master/lib/init/[init templates].

[[library-implementation]]
== Library Implementation

The TextKit library exposes two primary modules: `StringUtils` for character-level operations and `TextStats` for document analysis. See link:https://github.com/ziglang/zig/tree/master/lib/std/Build/Module.zig[Module.zig].

[[string-utils-module]]
=== String Utilities Module

[source,zig]
----
include::{sourcedir}/23__project-library-and-executable-workspace/src/string_utils.zig[]
----

This module demonstrates:

* **Struct-based organization**: Static methods grouped under `StringUtils`
* **Inline tests**: Each function paired with its test cases for locality
* **Simple algorithms**: Character counting, ASCII validation, in-place reversal

[[text-stats-module]]
=== Text Statistics Module

[source,zig]
----
include::{sourcedir}/23__project-library-and-executable-workspace/src/text_stats.zig[]
----

Key patterns:

* **State aggregation**: `TextStats` struct holds computed statistics
* **Analysis function**: Pure function taking text, returning stats
* **Format method**: Zig 0.15.2 format interface for printing
* **Comprehensive tests**: Edge cases (empty text, no trailing newline)

See link:https://ziglang.org/download/0.15.1/release-notes.html[v0.15.2] and link:https://github.com/ziglang/zig/tree/master/lib/std/Io.zig[Io.zig].

[[library-root]]
=== Library Root: Public API

[source,zig]
----
include::{sourcedir}/23__project-library-and-executable-workspace/src/textkit.zig[]
----

The root file (`textkit.zig`) serves as the library's public interface:

* **Re-exports**: Makes submodules accessible as `textkit.StringUtils` and `textkit.TextStats`
* **Version metadata**: Semantic version for external consumers
* **Test aggregation**: `std.testing.refAllDecls()` ensures all module tests run

This pattern allows internal reorganization without breaking consumer imports. xref:20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc[20], link:https://github.com/ziglang/zig/tree/master/lib/std/testing.zig[testing.zig]

[[executable-implementation]]
== Executable Implementation

The CLI tool wraps library functionality in a user-friendly command-line interface with subcommands for different operations. link:https://github.com/ziglang/zig/tree/master/lib/std/process.zig[process.zig]

[[cli-structure]]
=== CLI Structure and Argument Parsing

[source,zig]
----
include::{sourcedir}/23__project-library-and-executable-workspace/src/main.zig[lines=1..56]
----

The executable demonstrates:

* **Command dispatch**: Routing subcommands to handler functions
* **Argument validation**: Checking parameter counts and formats
* **Error handling**: Graceful failures with informative messages
* **Library consumption**: Clean imports via `@import("textkit")`

xref:02__control-flow-essentials.adoc[2]

[[cli-handlers]]
=== Command Handler Functions

[source,zig]
----
include::{sourcedir}/23__project-library-and-executable-workspace/src/main.zig[lines=56..126]
----

Each handler showcases different library features:

* **`analyzeFile`**: File I/O, memory allocation, text statistics
* **`reverseText`**: Stack buffer usage, string manipulation
* **`countCharacter`**: Simple library delegation

[[build-script]]
== Build Script: Orchestrating the Workspace

The `build.zig` file ties everything together, defining how library and executable relate and how users interact with the project.

[[build-script-full]]
=== Complete Build Script

[source,zig]
----
include::{sourcedir}/23__project-library-and-executable-workspace/build.zig[]
----

[[build-script-sections]]
=== Build Script Sections Explained

[[library-section]]
==== Library Creation

[source,zig]
----

include::{sourcedir}/23__project-library-and-executable-workspace/build.zig[lines=15..29]

----

Two module creations serve different purposes:

* `textkit_mod`: Public module for consumers (via `b.addModule`)
* `lib`: Static library artifact with separate module configuration

The library module specifies only `.target` because optimization is user-facing, while the library artifact requires both `.target` and `.optimize` for compilation.

NOTE: We use `.linkage = .static` to produce a `.a` archive file; change to `.dynamic` for `.so`/`.dylib`/`.dll` shared libraries. xref:22__build-system-deep-dive.adoc[22]

[[executable-section]]
==== Executable with Library Import

[source,zig]
----

include::{sourcedir}/23__project-library-and-executable-workspace/build.zig[lines=31..44]

----

The `.imports` table connects `main.zig` to the library module, enabling `@import("textkit")`. The name "textkit" is arbitrary—you could rename it to "lib" and use `@import("lib")` instead.

[[run-section]]
==== Run Step with Argument Forwarding

[source,zig]
----
include::{sourcedir}/23__project-library-and-executable-workspace/build.zig[lines=46..58]
----

This standard pattern:

1. Creates a run artifact step
2. Depends on installation (ensures binary is in `zig-out/bin/`)
3. Forwards CLI arguments after `--`
4. Wires to top-level `run` step

xref:22__build-system-deep-dive.adoc[22], link:https://github.com/ziglang/zig/tree/master/lib/std/Build/Step/Run.zig[Run.zig]

[[test-section]]
==== Test Integration

[source,zig]
----
include::{sourcedir}/23__project-library-and-executable-workspace/build.zig[lines=60..79]
----

Separating library and executable tests isolates failures and enables parallel execution. Both depend on the same `test` step so `zig build test` runs everything. xref:13__testing-and-leak-detection.adoc[13]

[[custom-steps]]
==== Custom Demo Step

[source,zig]
----
include::{sourcedir}/23__project-library-and-executable-workspace/build.zig[lines=80..90]
----

Custom steps showcase functionality without requiring user input. `zig build demo` runs predefined commands sequentially, demonstrating the CLI's capabilities.

[[using-the-project]]
== Using the Project

TextKit supports multiple workflows for building, testing, and running. xref:22__build-system-deep-dive.adoc[22]

[[building]]
=== Building Library and Executable

[source,shell]
----
$ zig build
----

.Result
* Library: `zig-out/lib/libtextkit.a`
* Executable: `zig-out/bin/textkit-cli`

Both artifacts are installed to standard locations by default.

[[testing]]
=== Running Tests

[source,shell]
----
$ zig build test
----

.Output (success)
[listing]
----
All 5 tests passed.
----

Tests from both `string_utils.zig`, `text_stats.zig`, and `main.zig` run together, reporting aggregate results. xref:13__testing-and-leak-detection.adoc[13]

[[running-cli]]
=== Running the CLI

[[cli-usage]]
==== View Usage

[source,shell]
----
$ zig build run
----

.Output
[source,shell]
----
TextKit CLI - Text processing utility

Usage:
  textkit-cli analyze <file>      Analyze text file statistics
  textkit-cli reverse <text>      Reverse the given text
  textkit-cli count <text> <char> Count character occurrences
----

[[cli-reverse]]
==== Reverse Text

[source,shell]
----
$ zig build run -- reverse "Hello World"
----

.Output
[source,shell]
----
Original: Hello World
Reversed: dlroW olleH
----

[[cli-count]]
==== Count Characters

[source,shell]
----
$ zig build run -- count "mississippi" "s"
----

.Output
[source,shell]
----
Character 's' appears 4 time(s) in: mississippi
----

[[cli-analyze]]
==== Analyze File

[source,shell]
----
$ zig build run -- analyze sample.txt
----

.Output
[source,shell]
----
File: sample.txt
  Lines: 7
  Words: 51
  Characters: 336
  ASCII only: true
----

[[demo-step]]
=== Running Demo Step

[source,shell]
----
$ zig build demo
----

.Output
[source,shell]
----
Original: Hello Zig!
Reversed: !giZ olleH
Character 's' appears 4 time(s) in: mississippi
----

Executes multiple commands in sequence without user interaction—useful for CI/CD pipelines or quick verification.

[[contrasting-workflows]]
== Contrasting Build Workflows

Understanding when to use `zig build` versus `zig build-exe` clarifies the build system's purpose. 

[[zig-build-exe-approach]]
=== Direct compilation with `zig build-exe`

[source,shell]
----
$ zig build-exe src/main.zig --name textkit-cli --pkg-begin textkit src/textkit.zig --pkg-end
----

This imperative command:

* Compiles immediately without graph construction
* Requires manual specification of all modules and flags
* Produces no caching or incremental compilation benefits
* Suitable for quick one-off builds or debugging



[[zig-build-approach]]
=== Graph-based build with `zig build`

[source,shell]
----
$ zig build
----

This declarative command:

* Executes `build.zig` to construct a dependency graph
* Caches artifacts and skips unchanged steps
* Parallelizes independent compilations
* Supports user customization via `-D` flags
* Integrates testing, installation, and custom steps

The graph-based approach scales better as projects grow, making `zig build` the standard for non-trivial codebases. xref:22__build-system-deep-dive.adoc[22]

[[design-patterns]]
== Design Patterns and Best Practices

TextKit demonstrates several professional patterns worth adopting.

[[module-organization]]
=== Module Organization

* **Single responsibility**: Each module (`string_utils`, `text_stats`) focuses on one concern
* **Root re-exports**: `textkit.zig` provides unified public API
* **Test co-location**: Tests live next to implementation for maintainability

xref:20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc[20]

[[build-script-patterns]]
=== Build Script Patterns

* **Standard options first**: Always start with `standardTargetOptions()` and `standardOptimizeOption()`
* **Logical grouping**: Comment sections (===== LIBRARY =====) improve readability
* **Artifact installation**: Call `installArtifact()` for everything users should access
* **Test separation**: Independent library and executable test steps isolate failures

xref:22__build-system-deep-dive.adoc[22]

[[cli-design]]
=== CLI Design Patterns

* **Subcommand dispatch**: Central router delegates to handler functions
* **Graceful degradation**: Usage messages for invalid input
* **Resource cleanup**: `defer` ensures allocator and file handle cleanup
* **Library separation**: All logic in library, CLI is thin wrapper

[[exercises]]
== Exercises

* Add a new subcommand `trim` that removes leading/trailing whitespace from text, implementing the function in `string_utils.zig` with tests. link:https://github.com/ziglang/zig/tree/master/lib/std/ascii.zig[ascii.zig]
* Convert the library from static (`.linkage = .static`) to dynamic (`.linkage = .dynamic`) and observe the output file differences.
* Create a second executable `textkit-batch` that processes multiple files in parallel using threads, sharing the same library module. xref:29__threads-and-atomics.adoc[37]
* Add a custom build step `bench` that runs performance benchmarks on `StringUtils.reverse` with various input sizes.

[[notes-caveats]]
== Notes & Caveats

* The static library (`.a` file) is not strictly necessary since Zig can link modules directly, but producing the library artifact demonstrates traditional library distribution patterns.
* When creating both a public module (`b.addModule`) and a library artifact (`b.addLibrary`), ensure both point to the same root source file to avoid confusion.
* The `installArtifact()` step installs to `zig-out/` by default; override with `.prefix` option for custom installation paths.
* Tests in `main.zig` typically verify only that the executable compiles; comprehensive functionality tests belong in library modules. xref:13__testing-and-leak-detection.adoc[13]

[[caveats-alternatives-edge-cases]]
== Caveats, alternatives, edge cases

* If the library were header-only (no runtime code), you wouldn't need `addLibrary()`—only the module definition suffices. xref:20__concept-primer-modules-vs-programs-vs-packages-vs-libraries.adoc[20]
* Zig 0.14.0 deprecated direct `root_source_file` in `ExecutableOptions`; always use `root_module` wrapper as shown here.
* For C interop scenarios, you'd add `lib.linkLibC()` and potentially generate headers with `lib.addCSourceFile()` plus `installHeader()`.
* Large projects might split `build.zig` into helper functions or separate files included via `@import("build_helpers.zig")`—the build script is regular Zig code.
