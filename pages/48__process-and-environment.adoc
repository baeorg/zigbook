////
changes: ["Initial Process and Environment chapter for Zig 0.15.2"]
examples_compile: yes
keywords: ["process", "environment", "std.process", "argv", "Child", "EnvMap"]
last_updated: 2025-11-06
last_verified: 2025-11-06
previous_chapter: "47__time-logging-and-progress"
next_chapter: "49__compression-and-archives"
status: draft
xref_complete: true
open_questions: []
////

= Process and Environment
:chapter-number: 48
:chapter-slug: process-and-environment
:creative-commons:
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== Overview

After building observability with timers, logging, and progress bars in xref:47__time-logging-and-progress.adoc[the previous chapter], we now step into the mechanics of how Zig programs interact with their immediate operating-system context. That means enumerating command-line arguments, examining and shaping environment variables, managing working directories, and spawning child processes—all via `std.process` on Zig 0.15.2. link:https://github.com/ziglang/zig/tree/master/lib/std/process.zig[process.zig]

Mastering these APIs lets tools feel at home on every machine: flags parse predictably, configuration flows in cleanly, and subprocesses cooperate instead of hanging or leaking handles. In Part VI we will broaden that scope across build targets, so the patterns here form the portable baseline to build upon. xref:41__cross-compilation-and-wasm.adoc[41]

[[learning-goals]]
== Learning Goals

* Navigate `std.process` iterators to inspect program arguments without leaking allocations.
* Capture, clone, and modify environment maps safely using Zig’s sentinel-aware strings. xref:03__data-fundamentals.adoc[3]
* Query and update the current working directory with deterministic error handling.
* Launch child processes, harvest their output, and interpret exit conditions in a portable fashion. link:https://github.com/ziglang/zig/tree/master/lib/std/process/Child.zig[Child.zig]
* Build small utilities that respect user overrides while maintaining predictable defaults. xref:05__project-tempconv-cli.adoc[5]

[[process-basics]]
== Process Basics: Arguments, Environment, and CWD

Zig keeps process state explicit: argument iteration, environment snapshots, and working-directory lookups all surface as functions returning slices or dedicated structs rather than hidden globals. That mirrors the data-first mindset from Part I while adding just enough OS abstraction to stay portable. xref:01__boot-basics.adoc[1]

[[process-basics-args]]
=== Command-line arguments without surprises

`std.process.argsAlloc` copies the null-terminated argument list into allocator-owned memory so you can safely compute lengths, take basenames, or duplicate strings. xref:05__project-tempconv-cli.adoc[5] For lightweight scans, `argsWithAllocator` exposes an iterator that reuses buffers. Just remember to call `deinit` once you finish.

[source,zig]
----
include::{sourcedir}/48__process-and-environment/args_overview.zig[]
----

.Run
[source,shell]
----
$ zig run args_overview.zig
----

.Output
[source,shell]
----
argv[0].basename = args_overview
argc = 1
user args absent
----

TIP: When you hand off `[:0]u8` entries to other APIs, use `std.mem.sliceTo(arg, 0)` to strip the sentinel without copying. This preserves both allocator ownership and Unicode correctness.

[[process-basics-envmap]]
=== Environment maps as explicit snapshots

Environment variables become predictable once you work on a local `EnvMap` copy. The map deduplicates keys, provides case-insensitive lookups on Windows, and makes ownership rules clear. xref:28__filesystem-and-io.adoc[28]

[source,zig]
----
include::{sourcedir}/48__process-and-environment/env_map_playground.zig[]
----

.Run
[source,shell]
----
$ zig run env_map_playground.zig
----

.Output
[source,shell]
----
pairs = 3
APP_MODE = override
THREADS present? no
----

NOTE: Use `putMove` when you already own heap-allocated strings and want the map to adopt them. It avoids extra copies and mirrors the `ArrayList.put` semantics covered in xref:44__collections-and-algorithms.adoc[the collections chapter].

[[process-basics-cwd]]
=== Current working directory helpers

`std.process.getCwdAlloc` delivers the working directory in a heap slice, while `getCwd` writes into a caller-supplied buffer. Choose the latter inside hot loops to avoid churn. Combine that with `std.fs.cwd()` from xref:28__filesystem-and-io.adoc[the filesystem chapter] for path joins or scoped directory changes.

[[child-processes]]
== Managing Child Processes

Process orchestration centers on `std.process.Child`, which wraps OS-specific hazards (handle inheritance, Unicode command lines, signal races) in a consistent interface. xref:22__build-system-deep-dive.adoc[22] You decide how each stream behaves (inherit, ignore, pipe, or close), then wait for a `Term` that spells out whether the child exited, signaled, or stopped.

[[child-processes-capture]]
=== Capturing stdout deterministically

Spawning `zig version` makes a portable demo: we pipe stdout/stderr, collect data into `ArrayList` buffers, and accept only exit code zero. xref:39__performance-and-inlining.adoc[39]

[source,zig]
----
include::{sourcedir}/48__process-and-environment/child_process_capture.zig[]
----

.Run
[source,shell]
----
$ zig run child_process_capture.zig
----

.Output
[source,shell]
----
zig version -> 0.15.2
stderr bytes -> 0
----

TIP: Always set `stdin_behavior = .Ignore` for fire-and-forget commands. Otherwise, the child inherits the parent's stdin and may block on accidental reads (common with shells or REPLs).

[[child-processes-exits]]
=== Exit semantics and diagnostics

`Child.wait()` returns a `Term` union. Inspect `Term.Exited` for numeric codes and report `Term.Signal` or `Term.Stopped` verbosely so users know when a signal intervened. Tie those diagnostics into the structured logging discipline from xref:47__time-logging-and-progress.adoc[Chapter 47] for uniform CLI error reporting.

[[notes-caveats]]
== Notes & Caveats

* `argsWithAllocator` borrows buffers. Stash any data you need beyond the iteration before calling `deinit`.
* Environment keys are case-insensitive on Windows. Avoid storing duplicates that differ only by case. xref:36__style-and-best-practices.adoc[36]
* `Child.spawn` can still fail after `fork`/`CreateProcess`. Always call `waitForSpawn` implicitly via `wait()` before touching pipes. xref:13__testing-and-leak-detection.adoc[13]

[[exercises]]
== Exercises

* Write a wrapper that prints a table of `(index, argument, length)` using only the iterator interface. No heap copies permitted.
* Extend the `EnvMap` example to merge overlay variables from a `.env` file while rejecting duplicates of security-critical keys (e.g., `PATH`). xref:28__filesystem-and-io.adoc[28]
* Build a miniature task runner that spawns three commands in sequence, piping stdout into a progress logger from xref:47__time-logging-and-progress.adoc[Chapter 47].

[[caveats-alternatives-edge-cases]]
== Caveats, alternatives, edge cases

* WASI without libc disables dynamic argument/environment access. Gate code with `builtin.os.tag` checks when targeting the browser or serverless runtimes.
* On Windows, batch files require `cmd.exe` quoting rules. Rely on `argvToScriptCommandLineWindows` rather than crafting strings manually. xref:41__cross-compilation-and-wasm.adoc[41]
* High-output children can exhaust pipes. Use `collectOutput` with a sensible `max_output_bytes`, or stream to disk to avoid `StdoutStreamTooLong`.

