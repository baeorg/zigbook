<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>项目</title>
<subtitle>表格生成器</subtitle>
<date>2025-11-15</date>
</info>
<chapter xml:id="overview">
<title>概述</title>
<simpara>在这个项目中，我们将<link xl:href="15__comptime-and-reflection.xml">15</link>中的想法转化为实际工作流：在编译时生成小型查找表，并在运行时以零开销使用它们。这种技术从热循环中移除分支，用常量数据替换重复工作，并保持代码简单。我们将采用"先测量"的思维模式，展示表格何时有帮助，以及何时不值得增加二进制大小。</simpara>
<simpara>我们将实现三个独立的演示：</simpara>
<itemizedlist>
<listitem>
<simpara>ASCII分类表：常量时间字符分类（数字/字母/空格/标点）</simpara>
</listitem>
<listitem>
<simpara>Popcount表：字节的快速位计数，可组合用于更大聚合</simpara>
</listitem>
<listitem>
<simpara>乘法表：参数化的N×N矩阵，紧凑呈现</simpara>
</listitem>
</itemizedlist>
<simpara>每个示例都使用Zig的现代标准输出写入器（参见Writergate更改），并在直接运行时打印可见结果。参见<link xl:href="https://ziglang.org/download/0.15.1/release-notes.html">v0.15.2</link>和<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/ascii.zig">ascii.zig</link>。</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>设计简单、可读且快速的编译时表格构建器。<link xl:href="15__comptime-and-reflection.xml">15</link></simpara>
</listitem>
<listitem>
<simpara>权衡利弊：代码大小vs速度，灵活性vs"内置"常量。<link xl:href="39__performance-and-inlining.xml">41</link></simpara>
</listitem>
<listitem>
<simpara>使用<literal>std.Io.Writer</literal>以最少的分配干净地格式化和呈现表格。<link xl:href="45__text-formatting-and-unicode.xml">47</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="ascii-class-table">
<title>ASCII分类表</title>
<simpara>我们构建一个256条目表，将字节映射到数字/字母/空格/标点的位掩码。在运行时，我们汇总输入字符串。"标点"集派生自<literal>isPrint &amp;&amp; !isAlphanumeric &amp;&amp; !isWhitespace</literal>（对ASCII足够）。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 16__project-table-generator.adoc - include::example$chapters-data/code/16__project-table-generator/ascii_class_table.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run ascii_class_table.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">input: Hello, Zig 0.15.2!

digits=4 letters=8 spaces=6 punct=4</programlisting>
</para>
</formalpara>
<tip>
<simpara>像这样的表格消除了内循环中的重复分支。保持派生逻辑易于审计，并在可能情况下优先使用<literal>std.ascii</literal>助手。<link xl:href="15__comptime-and-reflection.xml">15</link></simpara>
</tip>
</chapter>
<chapter xml:id="popcount-table">
<title>字节的Popcount表</title>
<simpara>我们不在每个字节上调用位操作例程，而是烘焙一个256条目popcount表，并在输入间减少。这从玩具示例扩展到"缓冲区中置位计数"原语。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 16__project-table-generator.adoc - include::example$chapters-data/code/16__project-table-generator/popcount_table.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run popcount_table.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">bytes: 0x00 0x0F 0xF0 0xAA 0xFF -&gt; total set bits = 20</programlisting>
</para>
</formalpara>
<note>
<simpara>在许多工作负载中，CPU的POPCNT指令（或<literal>std.math.popCount</literal>）已经很快。仅当你的分析显示它有助于你的数据访问模式和平台时，才优先使用表格。<link xl:href="50__random-and-math.xml">52</link></simpara>
</note>
</chapter>
<chapter xml:id="times-table">
<title>参数化乘法表（N×N）</title>
<simpara>这里表格维度是一个<literal>comptime</literal>参数，因此编译器展开生成并存储一个紧凑的<literal>[N][N]u16</literal>。我们格式化一个12×12"乘法表"，并且只打印子集以保持输出可读。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 16__project-table-generator.adoc - include::example$chapters-data/code/16__project-table-generator/mult_table.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run mult_table.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">12x12 multiplication table (partial):
   1   2   3   4   5   6   7   8   9  10  11  12
   2   4   6   8  10  12  14  16  18  20  22  24
   3   6   9  12  15  18  21  24  27  30  33  36
   4   8  12  16  20  24  28  32  36  40  44  48
   5  10  15  20  25  30  35  40  45  50  55  60
   6  12  18  24  30  36  42  48  54  60  66  72</programlisting>
</para>
</formalpara>
<important>
<simpara><literal>inline while/for</literal>构造需要编译时已知的边界；将它们与<literal>comptime var</literal>索引配对使意图明确。除非有理由展开，否则选择普通循环。<link xl:href="15__comptime-and-reflection.xml">15</link></simpara>
</important>
</chapter>
<chapter xml:id="notes-caveats">
<title>注意事项</title>
<itemizedlist>
<listitem>
<simpara>二进制大小vs速度：表格耗费内存。当你在热路径中移除有意义的工作，并且二进制预算允许时使用它们。<link xl:href="39__performance-and-inlining.xml">41</link></simpara>
</listitem>
<listitem>
<simpara>可移植性：ASCII分类是直接的；Unicode需要不同策略（范围/页面表格或库）。<link xl:href="45__text-formatting-and-unicode.xml">47</link></simpara>
</listitem>
<listitem>
<simpara>I/O：示例使用Zig 0.15.2<literal>std.Io.Writer</literal>接口，接口中带有缓冲区——不要忘记调用<literal>flush()</literal>。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>练习</title>
<itemizedlist>
<listitem>
<simpara>用附加类（十六进制数字、控制）扩展ASCII表，并为任意输入文件打印直方图。</simpara>
</listitem>
<listitem>
<simpara>在编译时生成<literal>crc32</literal>或<literal>crc16</literal>表，并在运行时对照已知测试向量验证（作为小型端到端演示）。<link xl:href="15__comptime-and-reflection.xml">15</link></simpara>
</listitem>
<listitem>
<simpara>参数化乘法表的单元格格式化器，以不同宽度对齐；测量对可读性和代码大小的影响。<link xl:href="45__text-formatting-and-unicode.xml">47</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>替代方案与边界情况</title>
<itemizedlist>
<listitem>
<simpara>表格失效：如果输入改变形状（例如，从ASCII切换到UTF-8代码点），突出地记录假设，并引入编译时断言以尽早捕获误用。<link xl:href="36__style-and-best-practices.xml">37</link></simpara>
</listitem>
<listitem>
<simpara>微架构效应：根据缓存行为，分支例程可以胜过表格遍历；用真实数据分析。<link xl:href="40__profiling-optimization-hardening.xml">42</link></simpara>
</listitem>
<listitem>
<simpara>对于远大于CPU缓存的表格，考虑按需生成、分块，或从磁盘加载的预计算资产，而非嵌入二进制中。<link xl:href="28__filesystem-and-io.xml">28</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>