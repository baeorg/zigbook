<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<article xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>项目：带进度的ZIP解压</title>
<date>2025-11-13</date>
<author>
<personname>
<firstname>Zig</firstname>
<surname>文档</surname>
</personname>
</author>
<copyright>
<year>2025</year>
<holder>zigbook</holder>
</copyright>
</info>

<section xml:id="overview">
<title>概述</title>
<simpara>上一个项目专注于确定性文本分析；现在我们将这些工件和周围的诊断打包到一个可重现的归档管道中。<xref linkend="53__project-top-k-word-frequency-analyzer" xrefstyle="short">53</xref>我们将编写一个极简的ZIP创建器，将文件流式传输到内存中，发出中央目录，然后在报告增量进度的同时验证提取。该程序依赖于标准库的ZIP读取器、手动标头编码、用于CRC32检查的<literal>StringHashMap</literal>簿记，以及通过<literal>std.Progress</literal>的结构化状态更新。<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/zip.zig">zip.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/hash_map.zig">hash_map.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/hash/crc.zig">crc.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Progress.zig">Progress.zig</link></simpara>
</section>

<section xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>通过按正确顺序写入本地文件头、中央目录和中央目录结束记录，同时遵守大小和偏移约束，从头开始组装ZIP归档。</simpara>
</listitem>
<listitem>
<simpara>捕获与捆绑包一起的确定性完整性指标（CRC32、SHA-256），以便持续集成可以在每次运行时验证结构和内容。<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/crypto.zig">crypto.zig</link></simpara>
</listitem>
<listitem>
<simpara>通过禁用动画渲染器并发出带有<literal>std.Progress</literal>的纯文本检查点，呈现分析师友好的进度消息，保持可脚本化。</simpara>
</listitem>
</itemizedlist>
</section>

<section xml:id="pipeline-design">
<title>设计管道</title>
<simpara>工作流分三个阶段运行：种子示例文件、构建归档以及提取和验证。每个阶段都会递增根进度节点，产生确定性的控制台摘要，这些摘要兼作验收标准。所有文件系统操作都在<literal>std.testing.tmpDir</literal>管理的临时目录下发生，保持真实工作区清洁。<xref linkend="47__time-logging-and-progress" xrefstyle="short">47</xref> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/testing.zig">testing.zig</link></simpara>
<simpara>对于归档元数据，我们在写入标头和稍后验证提取文件时重用相同的相对路径。将CRC32和字节计数存储在每个路径的<literal>StringHashMap</literal>中，为我们提供了一种简单的方法，可以在提取后将期望与实际输出进行差异比较。</simpara>
</section>

<section xml:id="archive-assembly">
<title>归档组装</title>
<simpara>由于Zig 0.15.2附带了ZIP读取器但没有写入器，我们使用<literal>ArrayList(u8)</literal>在内存中构建归档，按顺序附加每个组件：本地文件头、文件名、文件字节。每个标头字段都使用显式的小端助手写入，因此结果在架构之间是可移植的。一旦有效负载进入blob，我们就会附加中央目录（每个文件一个记录），然后是中央目录结束记录，镜像PKWARE APPNOTE中定义的结构，并在<literal>std.zip</literal>中编码。<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/array_list.zig">array_list.zig</link> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig">fmt.zig</link></simpara>
<simpara>在写入标头时，我们确保大小和偏移量适合32位字段（坚持使用经典的ZIP子集），并将文件名复制一次到映射中，以便以后可以确定性释放资源。归档映像完成后，我们将其持久化到磁盘并计算SHA-256摘要以供下游回归使用——该摘要使用<literal>std.fmt.bytesToHex</literal>呈现，因此可以内联比较，无需任何额外工具。</simpara>
</section>

<section xml:id="extraction-and-verification">
<title>提取和验证</title>
<simpara>提取重用标准库迭代器，该迭代器遍历每个中央目录记录，并将数据流传递给<literal>std.zip.Entry.extract</literal>；我们通过<literal>std.zip.Diagnostics</literal>规范化根文件夹名称，以便可以将其呈现给调用者。每个文件落地到磁盘后，我们会再次计算CRC32，并将字节计数与记录的期望值进行比较。任何不匹配都会立即导致程序失败，使其可以安全地嵌入到CI管道或部署挂钩中。</simpara>
<simpara><literal>std.Progress</literal>节点驱动控制台输出：根节点跟踪三个高级阶段，而子节点在播种、构建和验证期间计算文件列表。由于打印被禁用，最终消息是普通的文本行（通过缓冲的stdout写入器呈现），可以在自动化测试中逐字进行差异比较。<xref linkend="47__time-logging-and-progress" xrefstyle="short">47</xref></simpara>
</section>

<section xml:id="code-listing">
<title>端到端实现</title>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 54__project-zip-unzip-with-progress.adoc - include::example$chapters-data/code/54__project-zip-unzip-with-progress/zip_progress_pipeline.zig[]</programlisting>
<simpara>运行</simpara>
<screen>$ zig run zip_progress_pipeline.zig</screen>
<simpara>输出</simpara>
<screen>[1/3] seeded samples -> files=4, bytes=250
[2/3] built archive -> bytes=716
    sha256=4a13a3dc1e6ef90c252b0cc797ff14456aa28c670cafbc9d27a025b0079b05d5
[3/3] extracted + verified -> files=4, bytes=250, root=input</screen>
<simpara>验证步骤在诊断发现公共前缀时有意复制提取的根字符串；摘要在之后释放该缓冲区，以保持通用分配器清洁。这反映了通过临时目录流式传输大型归档的CLI实用程序的良好卫生习惯。<xref linkend="52__debug-and-valgrind" xrefstyle="short">52</xref></simpara>
</section>

<section xml:id="notes-caveats">
<title>注意事项和警告</title>
<itemizedlist>
<listitem>
<simpara>写入器坚持使用经典的（非Zip64）子集；一旦文件超过4 GiB，您必须升级标头和额外字段，或委托给专用的ZIP库。<xref linkend="44__collections-and-algorithms" xrefstyle="short">44</xref></simpara>
</listitem>
<listitem>
<simpara>进度节点是嵌套的，但打印被禁用；如果您想要实时的TTY更新，请删除<literal>.disable_printing = true</literal>并让渲染器清除帧。请记住，这样做会牺牲捕获日志中的确定性。<xref linkend="47__time-logging-and-progress" xrefstyle="short">47</xref></simpara>
</listitem>
<listitem>
<simpara>CRC32确认完整性而非真实性。将SHA-256摘要与签名结合使用，或将归档附加到<literal>zig build</literal>步骤，以获得可重现的部署管道。<xref linkend="39__performance-and-inlining" xrefstyle="short">39</xref></simpara>
</listitem>
</itemizedlist>
</section>

<section xml:id="exercises">
<title>练习</title>
<itemizedlist>
<listitem>
<simpara>当任何文件越过4 GiB边界时，扩展构建器以发出Zip64记录。为小捆绑包保留旧路径，并编写回归测试来验证两者。<xref linkend="33__c-interop-import-export-abi" xrefstyle="short">33</xref></simpara>
</listitem>
<listitem>
<simpara>将内存blob替换为以块形式刷新到磁盘的流式写入器；在<literal>perf</literal>或<literal>zig build test</literal>下使用大型合成文件比较吞吐量和内存消耗。<xref linkend="41__cross-compilation-and-wasm" xrefstyle="short">41</xref></simpara>
</listitem>
<listitem>
<simpara>添加一个命令行标志，在归档之前接受忽略列表（glob模式），然后报告与现有总计一起跳过的确切文件数。<xref linkend="36__style-and-best-practices" xrefstyle="short">36</xref> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fs/Dir.zig">Dir.zig</link></simpara>
</listitem>
</itemizedlist>
</section>

<section xml:id="caveats-alternatives">
<title>注意事项、替代方案、边缘情况</title>
<itemizedlist>
<listitem>
<simpara>将归档直接流式传输到stdout非常适合管道，但会使验证变得更加棘手；考虑先写入临时文件，以便您可以重新打开它进行校验，然后再继续传输。<xref linkend="28__filesystem-and-io" xrefstyle="short">28</xref> <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fs/File.zig">File.zig</link></simpara>
</listitem>
<listitem>
<simpara>ZIP加密故意不在范围内。如果您需要保密性，请使用<literal>std.crypto</literal>原语包装生成的文件，或切换到使用age或minisign的加密tarball等格式。<xref linkend="45__text-formatting-and-unicode" xrefstyle="short">45</xref></simpara>
</listitem>
<listitem>
<simpara>对于多GB语料库，请分块读取输入并增量更新CRC32，而不是调用<literal>readToEndAlloc</literal>；否则临时分配器会膨胀。<xref linkend="10__allocators-and-memory-management" xrefstyle="short">10</xref></simpara>
</listitem>
</itemizedlist>
</section>

</article>
</book>