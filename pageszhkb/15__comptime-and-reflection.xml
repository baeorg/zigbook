<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>编译时与反射</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>概述</title>
<simpara>Zig让你在编译时执行普通的Zig代码。这个简单、安静的想法解锁了很多功能：生成查找表、基于类型或值特化代码、在程序运行前验证不变量，以及编写无需宏或单独元编程语言的泛型工具。反射完善了这个图景：使用<literal>@TypeOf</literal>、<literal>@typeInfo</literal>等，代码可以检查类型并自适应地构建行为。</simpara>
<simpara>本章是Zig 0.15.2中编译时执行和反射的实践之旅。我们将构建可以直接运行的小型、独立的示例。在此过程中，我们将讨论什么在何时运行（编译时vs运行时），如何保持代码可读性和性能，以及何时优先选择显式参数而非巧妙的反射。更多细节参见<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/meta.zig">meta.zig</link>。</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>使用<literal>comptime</literal>表达式和块在构建时计算数据，并在运行时呈现它。</simpara>
</listitem>
<listitem>
<simpara>使用<literal>@TypeOf</literal>、<literal>@typeInfo</literal>和<literal>@typeName</literal>内省类型，实现健壮、通用的助手函数。</simpara>
</listitem>
<listitem>
<simpara>明智地应用<literal>inline fn</literal>和<literal>inline for/while</literal>，理解代码大小和性能权衡。<link xl:href="37__illegal-behavior-and-safety-modes.xml">37</link></simpara>
</listitem>
<listitem>
<simpara>使用<literal>@hasDecl</literal>、<literal>@hasField</literal>检测声明和字段，并使用<literal>@embedFile</literal>嵌入资源。<link xl:href="19__modules-and-imports-root-builtin-discovery.xml">19</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="comptime-basics">
<title>编译时基础：现在计算数据，稍后打印</title>
<simpara>编译时工作只是提前评估的普通Zig。下面的示例：</simpara>
<itemizedlist>
<listitem>
<simpara>在编译时评估表达式。</simpara>
</listitem>
<listitem>
<simpara>在运行时检查<literal>@inComptime()</literal>（它是<literal>false</literal>）。</simpara>
</listitem>
<listitem>
<simpara>使用<literal>inline while</literal>和编译时索引在编译时构建一个小的平方查找表。</simpara>
</listitem>
</itemizedlist>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 15__comptime-and-reflection.adoc - include::example$chapters-data/code/15__comptime-and-reflection/comptime_basics.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/15__comptime-and-reflection/comptime_basics.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">a (comptime 2+3) = 5
@inComptime() during runtime: false
squares[0..8): 0,1,4,9,16,25,36,49</programlisting>
</para>
</formalpara>
<tip>
<simpara><literal>inline while</literal>要求条件在编译时已知。对展开循环使用<literal>comptime var</literal>索引。除非有测量的理由展开，否则优先使用普通循环。</simpara>
</tip>
<section xml:id="comptime-tracking">
<title>编译器如何跟踪编译时值</title>
<simpara>当你编写编译时代码时，编译器必须确定哪些分配和值在编译时完全已知。这种跟踪使用语义分析(Sema)中的机制，监控分配内存的所有存储。</simpara>
<literallayout class="monospaced">graph TB
    subgraph "关键结构"
        COMPTIMEALLOC["ComptimeAlloc&lt;br/&gt;val, is_const, alignment"]
        MAYBECOMPTIMEALLOC["MaybeComptimeAlloc&lt;br/&gt;runtime_index, stores[]"]
        BASEALLOC["base_allocs map&lt;br/&gt;derived ptr → base alloc"]
    end

    subgraph "生命周期"
        RUNTIMEALLOC["Runtime alloc instruction"]
        STORES["Store operations tracked"]
        MAKEPTRCONST["make_ptr_const instruction"]
        COMPTIMEVALUE["Determine comptime value"]
    end

    subgraph "MaybeComptimeAlloc 跟踪"
        STORELIST["stores: MultiArrayList&lt;br/&gt;inst, src"]
        RUNTIMEINDEXFIELD["runtime_index&lt;br/&gt;Allocation point"]
    end

    subgraph "ComptimeAlloc 字段"
        VAL["val: MutableValue&lt;br/&gt;Current value"]
        ISCONST["is_const: bool&lt;br/&gt;Immutable after init"]
        ALIGNMENT["alignment&lt;br/&gt;Pointer alignment"]
        RUNTIMEINDEXALLOC["runtime_index&lt;br/&gt;Creation point"]
    end

    RUNTIMEALLOC --&gt; MAYBECOMPTIMEALLOC
    MAYBECOMPTIMEALLOC --&gt; STORELIST
    STORELIST --&gt; STORES
    STORES --&gt; MAKEPTRCONST
    MAKEPTRCONST --&gt; COMPTIMEVALUE
    COMPTIMEVALUE --&gt; COMPTIMEALLOC

    COMPTIMEALLOC --&gt; VAL
    COMPTIMEALLOC --&gt; ISCONST
    COMPTIMEALLOC --&gt; ALIGNMENT
    COMPTIMEALLOC --&gt; RUNTIMEINDEXALLOC

    BASEALLOC -.-&gt;|"跟踪"| RUNTIMEALLOC</literallayout>
<simpara>当编译器在语义分析期间遇到分配时，它会创建一个<literal>MaybeComptimeAlloc</literal>条目来跟踪所有存储。如果任何存储依赖于运行时值或条件，则该分配在编译时无法知道，该条目将被丢弃。如果当指针变为常量时所有存储都在编译时已知，编译器会在编译时应用所有存储，并创建带有最终值的<literal>ComptimeAlloc</literal>。这种机制使编译器能够在编译时评估复杂的初始化模式，同时确保正确性。实现细节参见<link xl:href="https://github.com/ziglang/zig/blob/master/src/Sema.zig">Sema.zig</link>。</simpara>
</section>
</chapter>
<chapter xml:id="reflection-typeinfo">
<title>反射：<literal>@TypeOf</literal>、<literal>@typeInfo</literal>及其伙伴</title>
<simpara>反射让你编写"通用但精确"的代码。这里我们检查一个<literal>struct</literal>并打印其字段及其类型，然后以通常的方式构造值。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 15__comptime-and-reflection.adoc - include::example$chapters-data/code/15__comptime-and-reflection/type_info_introspect.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/15__comptime-and-reflection/type_info_introspect.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">type name: type_info_introspect.Person
fields: 3
  0. id: u32
  1. name: []const u8
  2. active: bool
example: id=42 name=Zig active=true</programlisting>
</para>
</formalpara>
<note>
<simpara>在编译时使用<literal>@typeInfo(T)</literal>来派生实现（格式化器、序列化器、适配器）。将结果保存在本地<literal>const</literal>中以提高可读性。</simpara>
</note>
<section xml:id="type-decomposition">
<title>使用<literal>std.meta</literal>进行类型分解</title>
<simpara>除了<literal>@typeInfo</literal>，<literal>std.meta</literal>模块提供了专门的功能，用于从复合类型中提取组件类型。这些工具通过避免手动<literal>@typeInfo</literal>检查，使通用代码更清晰。</simpara>
<literallayout class="monospaced">graph TB
    subgraph "类型提取器"
        CHILD["Child(T)"]
        ELEM["Elem(T)"]
        SENTINEL["sentinel(T)"]
        TAG["Tag(T)"]
        ACTIVETAG["activeTag(union)"]
    end

    subgraph "输入类型"
        ARRAY["array"]
        VECTOR["vector"]
        POINTER["pointer"]
        OPTIONAL["optional"]
        UNION["union"]
        ENUM["enum"]
    end

    ARRAY --&gt; CHILD
    VECTOR --&gt; CHILD
    POINTER --&gt; CHILD
    OPTIONAL --&gt; CHILD

    ARRAY --&gt; ELEM
    VECTOR --&gt; ELEM
    POINTER --&gt; ELEM

    ARRAY --&gt; SENTINEL
    POINTER --&gt; SENTINEL

    UNION --&gt; TAG
    ENUM --&gt; TAG
    UNION --&gt; ACTIVETAG</literallayout>
<simpara>关键类型提取函数：</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Child(T)</literal>：从数组、向量、指针和可选值中提取子类型——对容器上的泛型函数很有用。</simpara>
</listitem>
<listitem>
<simpara><literal>Elem(T)</literal>：从内存跨度类型（数组、切片、指针）中获取元素类型——比手动<literal>@typeInfo</literal>字段访问更清晰。</simpara>
</listitem>
<listitem>
<simpara><literal>sentinel(T)</literal>：返回哨兵值（如果存在），启用空终止数据的泛型处理。</simpara>
</listitem>
<listitem>
<simpara><literal>Tag(T)</literal>：从枚举和联合体中获取标签类型，用于基于switch的分派。</simpara>
</listitem>
<listitem>
<simpara><literal>activeTag(u)</literal>：在运行时返回联合体值的活动标签。</simpara>
</listitem>
</itemizedlist>
<simpara>这些函数组合良好：<literal>std.meta.Child(std.meta.Child(T))</literal>从<literal>[][]u8</literal>中提取元素类型。使用它们编写适应类型结构的泛型算法，无需冗长的<literal>switch (@typeInfo(T))</literal>块。<link xl:href="https://github.com/ziglang/zig/blob/master/lib/std/meta.zig">meta.zig</link></simpara>
</section>
<section xml:id="field-declaration-introspection">
<title>字段和声明内省</title>
<simpara>对于结构化访问容器内部，<literal>std.meta</literal>提供了手动<literal>@typeInfo</literal>导航的高级替代方案：</simpara>
<literallayout class="monospaced">graph TB
    subgraph "容器内省"
        FIELDS["fields(T)"]
        FIELDINFO["fieldInfo(T, field)"]
        FIELDNAMES["fieldNames(T)"]
        TAGS["tags(T)"]
        FIELDENUM["FieldEnum(T)"]
    end

    subgraph "声明内省"
        DECLARATIONS["declarations(T)"]
        DECLINFO["declarationInfo(T, name)"]
        DECLENUM["DeclEnum(T)"]
    end

    subgraph "适用类型"
        STRUCT["struct"]
        UNION["union"]
        ENUMP["enum"]
        ERRORSET["error_set"]
    end

    STRUCT --&gt; FIELDS
    UNION --&gt; FIELDS
    ENUMP --&gt; FIELDS
    ERRORSET --&gt; FIELDS

    STRUCT --&gt; DECLARATIONS
    UNION --&gt; DECLARATIONS
    ENUMP --&gt; DECLARATIONS

    FIELDS --&gt; FIELDINFO
    FIELDS --&gt; FIELDNAMES
    FIELDS --&gt; FIELDENUM
    ENUMP --&gt; TAGS</literallayout>
<simpara>内省API提供：</simpara>
<itemizedlist>
<listitem>
<simpara><literal>fields(T)</literal>：返回任何结构体、联合体、枚举或错误集编译时字段信息——使用<literal>inline for</literal>迭代以处理每个字段。</simpara>
</listitem>
<listitem>
<simpara><literal>fieldInfo(T, field)</literal>：获取特定字段的详细信息（名称、类型、默认值、对齐）。</simpara>
</listitem>
<listitem>
<simpara><literal>FieldEnum(T)</literal>：创建一个枚举，其变体对应每个字段名称，启用基于switch的字段分派。</simpara>
</listitem>
<listitem>
<simpara><literal>declarations(T)</literal>：返回类型中函数和常量的编译时声明信息——对查找可选接口方法很有用。</simpara>
</listitem>
</itemizedlist>
<simpara>示例模式：<literal>inline for (std.meta.fields(MyStruct)) |field| { &#8230;&#8203; }</literal>让你编写通用序列化、格式化或比较函数，无需手工编码字段访问。<literal>FieldEnum(T)</literal>助手对字段名称上的switch语句特别有用。<link xl:href="https://github.com/ziglang/zig/blob/master/lib/std/meta.zig">meta.zig</link></simpara>
</section>
</chapter>
<chapter xml:id="inline-and-unrolling">
<title>内联函数和内联循环：力量和成本</title>
<simpara><literal>inline fn</literal>强制内联，<literal>inline for</literal>展开编译时已知的迭代。两者都增加代码大小。当你已经分析并确定热路径受益于展开或调用开销消除时使用它们。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 15__comptime-and-reflection.adoc - include::example$chapters-data/code/15__comptime-and-reflection/inline_for_inline_fn.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/15__comptime-and-reflection/inline_for_inline_fn.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">acc=26</programlisting>
</para>
</formalpara>
<caution>
<simpara>内联不是性能作弊代码。它用指令缓存和二进制大小换取潜在速度。在之前和之后测量。<link xl:href="39__performance-and-inlining.xml">39</link></simpara>
</caution>
</chapter>
<chapter xml:id="decl-field-embedfile">
<title>能力：<literal>@hasDecl</literal>、<literal>@hasField</literal>和<literal>@embedFile</literal></title>
<simpara>编译时能力测试让你适应类型而不会过度拟合API。资源嵌入使小资源保持接近代码，无需运行时I/O。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 15__comptime-and-reflection.adoc - include::example$chapters-data/code/15__comptime-and-reflection/has_decl_field_embedfile.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/15__comptime-and-reflection/has_decl_field_embedfile.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">has greet: true
has field x: true
message: compile-time constant
embedded:
Hello from @embedFile!
This text is compiled into the binary at build time.</programlisting>
</para>
</formalpara>
<tip>
<simpara>将资源放在使用它们的源代码旁边，并在<literal>@embedFile</literal>中使用相对路径引用它们。对于较大资产或用户提供的数据，优先使用运行时I/O。<link xl:href="28__filesystem-and-io.xml">28</link></simpara>
</tip>
</chapter>
<chapter xml:id="anytype-generics">
<title><literal>anytype</literal>和显式类型参数：实用泛型</title>
<simpara>Zig的泛型只是带有<literal>comptime</literal>参数的函数。为了清晰起见，使用显式类型参数；在透明转发类型且不约束语义的叶子助手中使用<literal>anytype</literal>。反射（<literal>@TypeOf</literal>、<literal>@typeName</literal>）在你接受灵活输入时帮助诊断。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 15__comptime-and-reflection.adoc - include::example$chapters-data/code/15__comptime-and-reflection/anytype_and_generics.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/15__comptime-and-reflection/anytype_and_generics.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">sum(u32,[1,2,3,4]) = 10
sum(u64,[10,20]) = 30
value of type u8: 42
value of type *const [5:0]u8: { 104, 101, 108, 108, 111 }</programlisting>
</para>
</formalpara>
<important>
<simpara>优先为公共API使用显式的<literal>comptime T: type</literal>参数；将<literal>anytype</literal>限制在透明转发具体类型且不约束语义的助手中。</simpara>
</important>
</chapter>
<chapter xml:id="notes-caveats">
<title>注意事项</title>
<itemizedlist>
<listitem>
<simpara>编译时执行在编译器中运行；注意复杂性。将繁重工作排除在紧增量循环之外，以保持快速重建。<link xl:href="38__zig-cli-deep-dive.xml">38</link></simpara>
</listitem>
<listitem>
<simpara>内联循环需要编译时已知的边界。有疑问时，使用运行时循环，让优化器完成工作。<link xl:href="39__performance-and-inlining.xml">39</link></simpara>
</listitem>
<listitem>
<simpara>反射很强大，但可能模糊控制流。为了清晰起见，优先选择简单直接的参数，并且只在工效学证明合理的地方反射。<link xl:href="36__style-and-best-practices.xml">36</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>练习</title>
<itemizedlist>
<listitem>
<simpara>编写一个<literal>formatFields</literal>助手，使用<literal>@typeInfo</literal>打印任何结构体的字段名称和值。尝试使用嵌套结构体和切片。<link xl:href="45__text-formatting-and-unicode.xml">47</link></simpara>
</listitem>
<listitem>
<simpara>构建一个编译时计算的<literal>sin</literal>/<literal>cos</literal>查找表，用于整数角度，并在紧循环中对比<literal>std.math</literal>调用进行基准测试。测量代码大小和运行时。<link xl:href="50__random-and-math.xml">50</link></simpara>
</listitem>
<listitem>
<simpara>添加<literal>hasToString</literal>检查：如果类型<literal>T</literal>有<literal>format</literal>方法，用<literal>{f}</literal>打印，否则用<literal>{any}</literal>打印。在简短文档注释中阐明行为。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>替代方案与边界情况</title>
<itemizedlist>
<listitem>
<simpara><literal>@inComptime()</literal>仅在编译时上下文中为<literal>true</literal>；不要依赖它进行运行时行为切换。将此类切换保存在值/参数中。</simpara>
</listitem>
<listitem>
<simpara><literal>@embedFile</literal>增加二进制大小；避免嵌入大资源。对于配置/徽标，它很棒。对于数据集，从磁盘或网络流式传输。<link xl:href="28__filesystem-and-io.xml">28</link></simpara>
</listitem>
<listitem>
<simpara>避免在大型函数上使用<literal>inline fn</literal>；它可能膨胀代码。在你分析显示收益的叶子算术助手或非常小的组合器上使用它。<link xl:href="39__performance-and-inlining.xml">39</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>