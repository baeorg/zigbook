<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>数据基础</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>概览</title>
<simpara>控制流只有在操作数据时才有用，因此本章将Zig的核心集合类型——数组、切片和哨兵终止字符串——置于实际使用中，同时保持值语义明确。参考 <link xl:href="https://ziglang.org/documentation/master/#Arrays">#数组</link> 和 <link xl:href="https://ziglang.org/documentation/master/#Slices">#切片</link>。</simpara>
<simpara>我们还将使指针、可选类型和对齐友好的转换变得常规，展示如何安全地重新解释内存，同时保留边界检查和对可变性的清晰度。参考 <link xl:href="https://ziglang.org/documentation/master/#Pointers">#指针</link> 和 <link xl:href="https://ziglang.org/documentation/master/#alignCast">#对齐转换</link> 了解详情。</simpara>
<section xml:id="type-system-context">
<title>Zig的类型系统类别</title>
<simpara>在深入了解特定集合类型之前，了解数组、切片和指针在Zig类型系统中的位置是有帮助的。Zig中的每种类型都属于一个类别，每个类别提供特定的操作：</simpara>
<literallayout class="monospaced">graph TB
    subgraph "类型类别"
        PRIMITIVE["基本类型&lt;br/&gt;bool, u8, i32, f64, void, ..."]
        POINTER["指针类型&lt;br/&gt;*T, [*]T, []T, [:0]T"]
        AGGREGATE["聚合类型&lt;br/&gt;struct, array, tuple"]
        FUNCTION["函数类型&lt;br/&gt;fn(...) ReturnType"]
        SPECIAL["特殊类型&lt;br/&gt;anytype, type, comptime_int"]
    end

    subgraph "常见类型操作"
        ABISIZE["abiSize()&lt;br/&gt;内存中的字节大小"]
        ABIALIGN["abiAlignment()&lt;br/&gt;所需对齐"]
        HASRUNTIME["hasRuntimeBits()&lt;br/&gt;有运行时存储？"]
        ELEMTYPE["elemType()&lt;br/&gt;元素类型（数组/切片）"]
    end

    PRIMITIVE --&gt; ABISIZE
    POINTER --&gt; ABISIZE
    AGGREGATE --&gt; ABISIZE
    
    PRIMITIVE --&gt; ABIALIGN
    POINTER --&gt; ABIALIGN
    AGGREGATE --&gt; ABIALIGN
    
    POINTER --&gt; ELEMTYPE
    AGGREGATE --&gt; ELEMTYPE</literallayout>
<simpara>本章的关键见解：</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">数组</emphasis>是具有编译时已知长度的聚合类型——它们的大小是 <literal>元素大小 × 长度</literal></simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">切片</emphasis>是存储指针和运行时长度的指针类型——总是2 × 指针大小</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">指针</emphasis>有多种形状（单项 <literal>*T</literal>，多项 <literal>[*]T</literal>，切片 <literal>[]T</literal>）具有不同的安全保证</simpara>
</listitem>
<listitem>
<simpara>所有类型都暴露其大小和对齐方式，这会影响结构体布局和内存分配</simpara>
</listitem>
</itemizedlist>
<simpara>这种类型感知的设计让编译器在切片上强制执行边界检查，同时在您明确选择退出安全时允许在多项指针上进行指针算术运算。</simpara>
</section>
</chapter>
<chapter xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>区分数组值语义与切片视图，包括零长度习语用于安全回退。</simpara>
</listitem>
<listitem>
<simpara>导航指针形状（<literal>*T</literal>、<literal>[*]T</literal>、<literal>?*T</literal>）并在不牺牲安全检查的情况下解包可选类型（参考 <link xl:href="https://ziglang.org/documentation/master/#Optionals">#可选类型</link>）。</simpara>
</listitem>
<listitem>
<simpara>在与其它API互操作时应用哨兵终止字符串和对齐感知转换（<literal>@alignCast</literal>、<literal>@bitCast</literal>、<literal>@intCast</literal>）（参考 <link xl:href="https://ziglang.org/documentation/master/#Sentinel-Terminated-Pointers">#哨兵终止指针</link> 和 <link xl:href="https://ziglang.org/documentation/master/#Explicit-Casts">#显式转换</link>）。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="section-1">
<title>在内存中构建集合</title>
<simpara>数组拥有存储而切片借用存储，因此编译器在长度、可变性和生命周期方面强制执行不同的保证；掌握它们的相互作用使迭代可预测，并将大多数边界检查移至调试构建中。</simpara>
<section xml:id="section-1-sub-a">
<title>作为拥有存储的数组</title>
<simpara>数组在其类型中携带长度，按值复制，并为您提供一个可变的基线，从中可以分割只读和读写切片。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 03__data-fundamentals.adoc - include::example$chapters-data/code/03__data-fundamentals/arrays_and_slices.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run arrays_and_slices.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">array len=4 allows mutation
mutable_slice: len=4 head=-3
prefix: len=2 head=-3
values[0] after slice write = -3
empty slice len=0 is zero-length
copy[0]=-1 owned[0]=1
zero slice len=0 from literal</programlisting>
</para>
</formalpara>
<note>
<simpara>可变切片和原始数组共享存储，而 <literal>[]const</literal> 前缀阻止写入——这是一个有意的边界，迫使只读消费者保持诚实。</simpara>
</note>
<section xml:id="_memory_layout_arrays_vs_slices">
<title>内存布局：数组与切片</title>
<simpara>了解数组和切片在内存中的布局方式可以阐明为什么"数组拥有存储而切片借用存储"以及为什么数组到切片的强制转换是廉价操作：</simpara>
<literallayout class="monospaced">graph TB
    subgraph "内存中的数组"
        ARRAY_DECL["const values: [4]i32 = .{1, 2, 3, 4}"]
        ARRAY_MEM["内存布局（16字节）\n\n栈帧\n| 1 | 2 | 3 | 4 |"]
        
        ARRAY_DECL --&gt; ARRAY_MEM
    end
    
    subgraph "内存中的切片"
        SLICE_DECL["const slice: []const i32 = &amp;values"]
        SLICE_MEM["内存布局（64位上16字节）\n\n栈帧\n|    ptr    |   len=4   |"]
        POINTS["ptr指向数组数据"]
        
        SLICE_DECL --&gt; SLICE_MEM
        SLICE_MEM --&gt; POINTS
    end
    
    POINTS -.-&gt;|"引用"| ARRAY_MEM
    
    subgraph "关键差异"
        DIFF1["数组：内联存储数据&lt;br/&gt;大小 = 元素大小 × 长度"]
        DIFF2["切片：存储指针 + 长度&lt;br/&gt;大小 = 2 × 指针大小（64位上16字节）"]
        DIFF3["强制转换：&amp;array → slice&lt;br/&gt;只是创建 {ptr, len} 对"]
    end</literallayout>
<simpara><emphasis role="strong">为什么这很重要：</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>数组具有<strong>值语义</strong>：分配数组会复制所有元素</simpara>
</listitem>
<listitem>
<simpara>切片具有<strong>引用语义</strong>：分配切片只会复制指针和长度</simpara>
</listitem>
<listitem>
<simpara>数组到切片的强制转换（<literal>&amp;array</literal>）是廉价的——它不会复制数据，只是创建一个描述符</simpara>
</listitem>
<listitem>
<simpara>切片是"胖指针"：它们携带运行时长度信息，支持边界检查</simpara>
</listitem>
</itemizedlist>
<simpara>这就是为什么函数通常接受切片作为参数——它们可以处理数组、切片和两者的部分，而无需复制底层数据。</simpara>
</section>
</section>
<section xml:id="section-1-sub-b">
<title>实践中的字符串和哨兵</title>
<simpara>哨兵终止数组桥接到C API，而不会牺牲切片的安全性；您可以使用 <literal>std.mem.span</literal> 重新解释字节流，并在保留哨兵约定时仍然变异底层缓冲区。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 03__data-fundamentals.adoc - include::example$chapters-data/code/03__data-fundamentals/sentinel_strings.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run sentinel_strings.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">literal len=17 contents="data fundamentals"
trimmed slice len=4 -&gt; Labe
full label after mutation: LabeX</programlisting>
</para>
</formalpara>
<simpara>哨兵切片保持尾部零完整，因此即使在本地变异后，为FFI获取 <literal>[*:0]u8</literal> 仍然有效，而普通切片在Zig内提供符合人体工程学的迭代（参考 <link xl:href="https://ziglang.org/documentation/master/#Type-Coercion">#类型强制转换</link>）。</simpara>
<tip>
<simpara><literal>std.mem.span</literal> 将哨兵指针转换为普通切片而不克隆数据，当您临时需要边界检查或切片辅助程序，然后再返回指针API时，它是理想的选择。</simpara>
</tip>
</section>
<section xml:id="section-1-sub-c">
<title>不可变和可变视图</title>
<simpara>当调用者只检查数据时，优先选择 <literal>[]const T</literal>——Zig会很乐意将可变切片强制转换为const视图，为您提供API清晰度，并防止意外写入在编译时发生。</simpara>
</section>
</chapter>
<chapter xml:id="section-2">
<title>指针模式和转换工作流</title>
<simpara>当您共享存储、与外部布局互操作或超出切片边界时，指针就会出现；通过依赖可选包装器和显式转换，您保持意图清晰，并允许安全检查在假设失效时触发。</simpara>
<section xml:id="pointer-shapes">
<title>指针形状参考</title>
<simpara>Zig提供多种指针类型，每种类型具有不同的安全保证和用例。了解何时使用每种形状对于编写安全、高效的代码至关重要：</simpara>
<literallayout class="monospaced">graph TB
    subgraph "指针形状"
        SINGLE["*T&lt;br/&gt;单项指针"]
        MANY["[*]T&lt;br/&gt;多项指针"]
        SLICE["[]T&lt;br/&gt;切片"]
        OPTIONAL["?*T&lt;br/&gt;可选指针"]
        SENTINEL_PTR["[*:0]T&lt;br/&gt;哨兵多项"]
        SENTINEL_SLICE["[:0]T&lt;br/&gt;哨兵切片"]
    end
    
    subgraph "特征"
        SINGLE --&gt; S_BOUNDS["✓ 边界：单个元素&lt;br/&gt;✓ 安全：解引用检查&lt;br/&gt;📍 用途：函数参数、引用"]
        
        MANY --&gt; M_BOUNDS["⚠ 边界：未知长度&lt;br/&gt;✗ 安全：无边界检查&lt;br/&gt;📍 用途：C互操作、紧凑循环"]
        
        SLICE --&gt; SL_BOUNDS["✓ 边界：运行时长度&lt;br/&gt;✓ 安全：边界检查&lt;br/&gt;📍 用途：大多数Zig代码、迭代"]
        
        OPTIONAL --&gt; O_BOUNDS["✓ 边界：可能为null&lt;br/&gt;✓ 安全：必须先解包&lt;br/&gt;📍 用途：可选引用"]
        
        SENTINEL_PTR --&gt; SP_BOUNDS["✓ 边界：直到哨兵&lt;br/&gt;~ 安全：哨兵必须存在&lt;br/&gt;📍 用途：C字符串、空终止"]
        
        SENTINEL_SLICE --&gt; SS_BOUNDS["✓ 边界：长度 + 哨兵&lt;br/&gt;✓ 安全：长度和哨兵都有&lt;br/&gt;📍 用途：Zig ↔ C字符串桥接"]
    end</literallayout>
<simpara><emphasis role="strong">比较表：</emphasis></simpara>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">形状</entry>
<entry align="left" valign="top">示例</entry>
<entry align="left" valign="top">长度已知？</entry>
<entry align="left" valign="top">边界检查？</entry>
<entry align="left" valign="top">常见用途</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><literal>*T</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>*i32</literal></simpara></entry>
<entry align="left" valign="top"><simpara>单个元素</simpara></entry>
<entry align="left" valign="top"><simpara>是（隐式）</simpara></entry>
<entry align="left" valign="top"><simpara>单项引用</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>[*]T</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>[*]i32</literal></simpara></entry>
<entry align="left" valign="top"><simpara>未知</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">否</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>C数组、指针算术</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>[]T</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>[]i32</literal></simpara></entry>
<entry align="left" valign="top"><simpara>运行时（在切片中）</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">是</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>主要Zig集合类型</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>?*T</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>?*i32</literal></simpara></entry>
<entry align="left" valign="top"><simpara>单个（如果非null）</simpara></entry>
<entry align="left" valign="top"><simpara>是 + null检查</simpara></entry>
<entry align="left" valign="top"><simpara>可选引用</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>[*:0]T</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>[*:0]u8</literal></simpara></entry>
<entry align="left" valign="top"><simpara>直到哨兵</simpara></entry>
<entry align="left" valign="top"><simpara>哨兵必须存在</simpara></entry>
<entry align="left" valign="top"><simpara>C字符串（<literal>char*</literal>）</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>[:0]T</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>[:0]u8</literal></simpara></entry>
<entry align="left" valign="top"><simpara>运行时 + 哨兵</simpara></entry>
<entry align="left" valign="top"><simpara>是 + 哨兵保证</simpara></entry>
<entry align="left" valign="top"><simpara>用于C API的Zig字符串</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara><emphasis role="strong">指导原则：</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">默认使用切片</emphasis>（<literal>[]T</literal>）用于所有Zig代码——它们提供安全性和便利性</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">使用单项指针</emphasis>（<literal>*T</literal>）当您需要变异单个值或按引用传递时</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">避免多项指针</emphasis>（<literal>[*]T</literal>）除非与C接口或在性能关键的内部循环中</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">使用可选指针</emphasis>（<literal>?*T</literal>）当null是有意义的状态时，不用于错误处理</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">使用哨兵类型</emphasis>（<literal>[*:0]T</literal>、<literal>[:0]T</literal>）在C边界，内部转换为切片</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="workflow-1">
<title>用于共享可变性的可选指针</title>
<simpara>可选单项指针公开可变性而无需猜测生命周期——仅在存在时捕获它们，通过解引用进行变异，并在指针不存在时优雅地回退。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 03__data-fundamentals.adoc - include::example$chapters-data/code/03__data-fundamentals/pointers_and_optionals.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run pointers_and_optionals.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">alias -&gt; reading 42
optional pointer empty
optional pointer mutated to 52
slice view len=4
samples[2] via many pointer = 42</programlisting>
</para>
</formalpara>
<simpara><literal>?*Sensor</literal> 门控将可变性隐藏在模式匹配之后，而多项指针（<literal>[*]i32</literal>）通过删除边界检查来记录别名风险——这是为紧凑循环和FFI保留的深思熟虑的权衡。</simpara>
</section>
<section xml:id="workflow-2">
<title>对齐和重新解释数据</title>
<simpara>当您必须重新解释原始字节时，使用转换内建函数来提升对齐、更改指针元素类型，并保持整数/浮点转换明确，以便调试构建可以捕获未定义的假设（参考 <link xl:href="https://ziglang.org/documentation/master/#bitCast">#位转换</link>）。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 03__data-fundamentals.adoc - include::example$chapters-data/code/03__data-fundamentals/alignment_and_casts.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run alignment_and_casts.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">32-bit value = 0x11223344
bitcast copy = 0x11223344
truncate -&gt; 0x44, widen -&gt; 287454020
floatCast ratio -&gt; 1.875</programlisting>
</para>
</formalpara>
<simpara>通过链接 <literal>@alignCast</literal>、<literal>@ptrCast</literal> 和 <literal>@bitCast</literal>，您可以明确断言布局关系，随后的 <literal>@truncate</literal>/<literal>@intCast</literal> 转换在跨API变窄或加宽时保持整数宽度诚实。</simpara>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>说明与注意事项</title>
<itemizedlist>
<listitem>
<simpara>哨兵终止指针非常适合C桥接，但在Zig内部优先选择切片，以便边界检查保持可用且API暴露长度。</simpara>
</listitem>
<listitem>
<simpara>使用 <literal>@alignCast</literal> 提升指针对齐仍然在调试模式下捕获（如果地址未对齐）——在提升之前证明前提条件。</simpara>
</listitem>
<listitem>
<simpara>多项指针（<literal>[*]T</literal>）删除边界检查；谨慎使用它们，并记录安全切片会强制执行的不变量。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>练习</title>
<itemizedlist>
<listitem>
<simpara>扩展 <literal>arrays_and_slices.zig</literal> 以从运行时数组创建零长度可变切片，然后通过 <literal>std.ArrayList</literal> 追加，观察切片视图如何保持有效。</simpara>
</listitem>
<listitem>
<simpara>修改 <literal>sentinel_strings.zig</literal> 以接受用户提供的 <literal>[:0]u8</literal>，并通过返回错误联合来防止缺少哨兵的输入。</simpara>
</listitem>
<listitem>
<simpara>通过添加在截断之前拒绝低字节为零的值的分支来增强 <literal>alignment_and_casts.zig</literal>，展示 <literal>@intCast</literal> 如何依赖于调用者提供的范围保证。</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>