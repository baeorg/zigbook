<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>项目</title>
<subtitle>路径工具 (TDD)</subtitle>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>概述</title>
<simpara>在这个实践章节中，我们构建一个轻量级、分配器友好的路径助手，它与Zig标准库良好协作并跨平台工作。我们将采用测试优先的方式开发——然后提供一个小的CLI演示，让你可以在没有测试框架的情况下看到实际输出。在此过程中，我们故意引入一个内存泄漏，观察Zig的测试分配器捕获它，然后修复它并验证。</simpara>
<simpara>目标不是替代<literal>std.fs.path</literal>，而是练习API设计、测试驱动开发(TDD)以及在现实、小型的工具中实现无泄漏分配。参见<link xl:href="13__testing-and-leak-detection.xml">13__testing-and-leak-detection.xml</link>和<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fs/path.zig">path.zig</link>。</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>设计小型、可组合的API：连接、basename/dirpath、扩展名和更改扩展名。</simpara>
</listitem>
<listitem>
<simpara>正确使用分配器，在成功和失败路径下避免泄漏。<link xl:href="10__allocators-and-memory-management.xml">10__allocators-and-memory-management.xml</link></simpara>
</listitem>
<listitem>
<simpara>使用<literal>std.testing</literal>练习TDD，并将TDD与<literal>zig run</literal>演示配对以获得可见输出。<link xl:href="13__testing-and-leak-detection.xml">13__testing-and-leak-detection.xml</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="api-sketch">
<title>小型API接口</title>
<simpara>我们将在<literal>pathutil</literal>命名空间中实现四个助手函数：</simpara>
<itemizedlist>
<listitem>
<simpara><literal>joinAlloc(allocator, parts)</literal> → <literal>[]u8</literal>：用单个分隔符连接组件，保留绝对根路径</simpara>
</listitem>
<listitem>
<simpara><literal>basename(path)</literal> → <literal>[]const u8</literal>：最后一个组件，忽略尾部分隔符</simpara>
</listitem>
<listitem>
<simpara><literal>dirpath(path)</literal> → <literal>[]const u8</literal>：目录部分，无尾部分隔符（裸名称为"."，根为"/"）</simpara>
</listitem>
<listitem>
<simpara><literal>extname(path)</literal> → <literal>[]const u8</literal>和<literal>changeExtAlloc(allocator, path, new_ext)</literal> → <literal>[]u8</literal></simpara>
</listitem>
</itemizedlist>
<simpara>这些函数强调可预测、教学友好的行为；对于生产级的边界情况，优先使用<literal>std.fs.path</literal>。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 14__project-path-utility.adoc - include::example$chapters-data/code/14__project-path-utility-tdd/path_util.zig[]</programlisting>
<note>
<simpara>为了教学目的，我们在解析时接受<literal>'/'</literal>或<literal>'\\'</literal>作为任何平台上的分隔符，但在连接时总是发出本地分隔符(<literal>std.fs.path.sep</literal>)。</simpara>
</note>
</chapter>
<chapter xml:id="demo-run">
<title>试试看：运行演示（可见输出）</title>
<simpara>为了在测试运行器之外保持输出可见，这里有一个调用我们助手函数并打印结果的微型CLI。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 14__project-path-utility.adoc - include::example$chapters-data/code/14__project-path-utility-tdd/path_util_demo.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run chapters-data/code/14__project-path-utility-tdd/path_util_demo.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">join a,b,c =&gt; a/b/c
join /,usr/,/bin =&gt; /usr/bin
basename(/home/user/docs/report.txt) =&gt; report.txt
dirpath(/home/user/docs/report.txt) =&gt; /home/user/docs
extname(/home/user/docs/report.txt) =&gt; txt
changeExt(/home/user/docs/report.txt, md) =&gt; /home/user/docs/report.md</programlisting>
</para>
</formalpara>
</chapter>
<chapter xml:id="tdd-loop">
<title>测试优先：将行为和边界情况编码</title>
<simpara>TDD有助于澄清意图并锁定边界情况。我们保持测试小而快速；它们使用Zig的测试分配器运行，默认情况下会捕获泄漏。本章包含测试，因为内容计划要求TDD；在其他地方，我们将偏爱<literal>zig run</literal>风格的演示以获得可见输出。参见<link xl:href="13__testing-and-leak-detection.xml">13__testing-and-leak-detection.xml</link>和<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/testing.zig">testing.zig</link>。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 14__project-path-utility.adoc - include::example$chapters-data/code/14__project-path-utility-tdd/path_util_test.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig test chapters-data/code/14__project-path-utility-tdd/path_util_test.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">All 3 tests passed.</programlisting>
</para>
</formalpara>
</chapter>
<chapter xml:id="leak-catch-fix">
<title>捕获故意泄漏 → 修复它</title>
<simpara>测试分配器在测试结束时标记泄漏。首先，一个忘记<literal>free</literal>的失败示例：</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 14__project-path-utility.adoc - include::example$chapters-data/code/14__project-path-utility-tdd/leak_demo_fail.zig[]</programlisting>
<formalpara>
<title>运行（期望失败）</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig test chapters-data/code/14__project-path-utility-tdd/leak_demo_fail.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出（摘录）</title>
<para>
<screen>[gpa] (err): memory address 0x… leaked:
… path_util.zig:49:33: … in joinAlloc
… leak_demo_fail.zig:6:42: … in test.deliberate leak caught by testing allocator

All 1 tests passed.
1 errors were logged.
1 tests leaked memory.
error: the following test command failed with exit code 1:
…/test --seed=0x…</screen>
</para>
</formalpara>
<simpara>然后用<literal>defer</literal>修复它，观察测试套件变绿：</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 14__project-path-utility.adoc - include::example$chapters-data/code/14__project-path-utility-tdd/leak_demo_fix.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig test chapters-data/code/14__project-path-utility-tdd/leak_demo_fix.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">All 1 tests passed.</programlisting>
</para>
</formalpara>
<simpara><link xl:href="10__allocators-and-memory-management.xml">10__allocators-and-memory-management.xml</link>，<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/heap.zig">heap.zig</link></simpara>
</chapter>
<chapter xml:id="notes-caveats">
<title>注意事项</title>
<itemizedlist>
<listitem>
<simpara>对于生产环境的路径处理，查阅<literal>std.fs.path</literal>了解平台细节（UNC路径、驱动器号、特殊根路径）。</simpara>
</listitem>
<listitem>
<simpara>在成功分配后立即使用<literal>defer allocator.free(buf)</literal>；它通过构造使成功和错误路径都正确。<link xl:href="04__errors-resource-cleanup.xml">04__errors-resource-cleanup.xml</link></simpara>
</listitem>
<listitem>
<simpara>当你需要可见输出（教程、演示）时，优先使用<literal>zig run</literal>示例；当你需要保证（CI）时，优先使用<literal>zig test</literal>。本章演示两者，因为它明确关注TDD。<link xl:href="13__testing-and-leak-detection.xml">13__testing-and-leak-detection.xml</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>练习</title>
<itemizedlist>
<listitem>
<simpara>扩展<literal>joinAlloc</literal>以省略<literal>.</literal>段并折叠中间的<literal>..</literal>对（在根附近要小心）。为边界情况添加测试，然后用<literal>zig run</literal>演示。</simpara>
</listitem>
<listitem>
<simpara>添加<literal>stem(path)</literal>，返回没有扩展名的basename；验证<literal>.gitignore</literal>、多点名称和尾部点的行为。</simpara>
</listitem>
<listitem>
<simpara>编写一个微型CLI，接受<literal>--change-ext md file1 file2 …</literal>并打印结果，使用页面分配器和缓冲写入器。<link xl:href="28__filesystem-and-io.xml">28__filesystem-and-io.xml</link></simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>替代方案与边界情况</title>
<itemizedlist>
<listitem>
<simpara>在Windows上，这个教学工具将<literal>'/'</literal>和<literal>'\\'</literal>都视为输入分隔符，但总是打印本地分隔符。<literal>std.fs.path</literal>如果你需要确切的Windows行为，有更丰富的语义。</simpara>
</listitem>
<listitem>
<simpara>分配失败处理：演示使用<literal>std.heap.page_allocator</literal>，在OOM时会中止；测试使用<literal>std.testing.allocator</literal>来系统地捕获泄漏。<link xl:href="10__allocators-and-memory-management.xml">10__allocators-and-memory-management.xml</link></simpara>
</listitem>
<listitem>
<simpara>如果你将这些助手嵌入到更大的工具中，通过你的API传递分配器并保持所有权规则明确；避免全局状态。<link xl:href="36__style-and-best-practices.xml">36__style-and-best-practices.xml</link></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>