<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>控制流基础</title>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>概览</title>
<simpara>第1章建立了运行Zig程序和处理数据的基础；现在我们将这些值转化为决策，通过遍历语言的控制流原语，如<link xl:href="https://ziglang.org/documentation/master/#if">#if</link>所述。Zig中的控制流是面向表达式的，因此选择分支或循环通常会产生一个值，而不仅仅是指导执行。</simpara>
<simpara>我们探索循环、标记流和<literal>switch</literal>背后的语义，强调<literal>break</literal>、<literal>continue</literal>和<literal>else</literal>子句如何在安全和发布版本中传达意图；参见<link xl:href="https://ziglang.org/documentation/master/#while">#while</link>、<link xl:href="https://ziglang.org/documentation/master/#for">#for</link>和<link xl:href="https://ziglang.org/documentation/master/#switch">#switch</link>。</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>使用<literal>if</literal>表达式（带可选负载捕获）来派生值，同时显式处理缺失数据路径。</simpara>
</listitem>
<listitem>
<simpara>将<literal>while</literal>/<literal>for</literal>循环与标记<literal>break</literal>/<literal>continue</literal>结合，清晰管理嵌套迭代和退出条件。</simpara>
</listitem>
<listitem>
<simpara>应用<literal>switch</literal>来枚举详尽的决策表，包括范围、多个值和枚举。</simpara>
</listitem>
<listitem>
<simpara>利用循环<literal>else</literal>子句和标记中断来直接从迭代构造返回值。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="pipeline-overview">
<title>控制流代码发生了什么</title>
<simpara>在深入控制流语法之前，了解编译器如何处理你的<literal>if</literal>、<literal>while</literal>和<literal>switch</literal>语句是有帮助的。Zig通过多个中间表示（IR）转换源代码，每个表示服务于特定目的：</simpara>
<literallayout class="monospaced">graph LR
    SOURCE["源代码&lt;br/&gt;.zig文件"]
    TOKENS["令牌流"]
    AST["AST&lt;br/&gt;(Ast.zig)"]
    ZIR["ZIR&lt;br/&gt;(Zir)"]
    AIR["AIR&lt;br/&gt;(Air.zig)"]
    MIR["MIR&lt;br/&gt;(codegen.AnyMir)"]
    MACHINE["机器码"]

    SOURCE --&gt;|"tokenizer.zig"| TOKENS
    TOKENS --&gt;|"Parse.zig"| AST
    AST --&gt;|"AstGen.zig"| ZIR
    ZIR --&gt;|"Sema.zig"| AIR
    AIR --&gt;|"codegen.generateFunction()"| MIR
    MIR --&gt;|"codegen.emitFunction()"| MACHINE</literallayout>
<informaltable frame="all" rowsep="1" colsep="1">
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">IR阶段</entry>
<entry align="left" valign="top">表示</entry>
<entry align="left" valign="top">关键属性</entry>
<entry align="left" valign="top">控制流目的</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><emphasis>令牌</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>平面令牌流</simpara></entry>
<entry align="left" valign="top"><simpara>原始词法分析</simpara></entry>
<entry align="left" valign="top"><simpara>识别<literal>if</literal>、<literal>while</literal>、<literal>switch</literal>关键字</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>AST</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>树结构</simpara></entry>
<entry align="left" valign="top"><simpara>语法正确，无类型</simpara></entry>
<entry align="left" valign="top"><simpara>保留嵌套控制流的结构</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>ZIR</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>基于指令的IR</simpara></entry>
<entry align="left" valign="top"><simpara>无类型，每个声明单个SSA形式</simpara></entry>
<entry align="left" valign="top"><simpara>将控制流降低为块和分支</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>AIR</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>基于指令的IR</simpara></entry>
<entry align="left" valign="top"><simpara>完全类型化，每个函数单个SSA形式</simpara></entry>
<entry align="left" valign="top"><simpara>类型检查的分支，已知结果</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>MIR</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>后端特定IR</simpara></entry>
<entry align="left" valign="top"><simpara>接近机器码，寄存器分配</simpara></entry>
<entry align="left" valign="top"><simpara>转换为跳转和条件指令</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>你编写的控制流构造——<literal>if</literal>表达式、<literal>switch</literal>语句、标记循环——系统地通过这些阶段降低。当代码到达机器码时，<literal>switch</literal>变成了跳转表，<literal>while</literal>循环是条件分支指令。本章中的图表展示了这种降低如何在ZIR阶段发生，其中控制流变成显式块和分支。</simpara>
</chapter>
<chapter xml:id="section-1">
<title>核心控制结构</title>
<simpara>Zig中的控制流将块和循环视为表达式，这意味着每个构造都可以产生一个值，并直接参与赋值或返回语句。本节逐步介绍条件语句、循环和<literal>switch</literal>，展示每个如何适应表达式模型，同时保持高可读性，如<link xl:href="https://ziglang.org/documentation/master/#Blocks">#Blocks</link>所述。</simpara>
<section xml:id="section-1-sub-a">
<title>作为表达式的条件语句</title>
<simpara><literal>if</literal>评估为运行的任何分支的值，可选捕获形式（<literal>if (opt) |value|</literal>）是解包可选值的简洁方式，而不会遮蔽早期名称。嵌套标记块（<literal>blk: { ... }</literal>）让你在仍然返回单个值的同时选择多个结果。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 02__control-flow-essentials.adoc - include::example$chapters-data/code/02__control-flow-essentials/branching.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run branching.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">sample 0: positive
sample 1: zero
sample 2: missing
sample 3: negative</programlisting>
</para>
</formalpara>
<simpara>函数返回<literal>[]const u8</literal>，因为<literal>if</literal>表达式本身产生字符串，强调面向表达式的分支如何保持调用点紧凑。<literal>samples</literal>循环显示<literal>for</literal>可以使用索引元组<literal>(item, index)</literal>进行迭代，但仍依赖上游表达式来格式化输出。</simpara>
<section xml:id="_how_if_else_expressions_lower_to_zir">
<title>if-else表达式如何降低到ZIR</title>
<simpara>当编译器遇到<literal>if</literal>表达式时，它将其转换为ZIR（Zig中间表示）中的块和条件分支。确切的降低取决于是否需要结果位置；参见<link xl:href="60__advanced-result-location-semantics.adoc#patterns">结果位置</link>：</simpara>
<literallayout class="monospaced">graph TB
    IfNode["if (cond) then_expr else else_expr"] --&gt; EvalCond["评估条件"]

    EvalCond --&gt; CheckRL["需要结果位置？"]

    CheckRL --&gt;|"无RL"| SimpleIf["生成condbr&lt;br/&gt;两个带中断的块"]
    CheckRL --&gt;|"有RL"| BlockIf["生成block_inline&lt;br/&gt;共享结果指针"]

    SimpleIf --&gt; ThenBlock["then_block:&lt;br/&gt;评估then_expr&lt;br/&gt;中断值"]
    SimpleIf --&gt; ElseBlock["else_block:&lt;br/&gt;评估else_expr&lt;br/&gt;中断值"]

    BlockIf --&gt; AllocResult["alloc_inferred"]
    BlockIf --&gt; ThenBlockRL["then_block:&lt;br/&gt;写入结果指针"]
    BlockIf --&gt; ElseBlockRL["else_block:&lt;br/&gt;写入结果指针"]</literallayout>
<simpara>当你写<literal>const result = if (x &gt; 0) "positive" else "negative"</literal>时，编译器创建两个块（每个分支一个）并使用<literal>break</literal>语句返回所选值。这就是<literal>if</literal>表达式可以参与赋值的原因——它们编译为通过其中断产生值的块。</simpara>
</section>
</section>
<section xml:id="section-1-sub-b">
<title>带标记的While和For循环</title>
<simpara>Zig中的循环可以通过将<literal>break</literal>结果与循环的<literal>else</literal>子句配对来直接传递值，当执行完成而没有中断时触发。标记循环（<literal>outer: while (...)</literal>）协调嵌套迭代，因此你可以提前退出或跳过工作，而无需临时布尔值。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 02__control-flow-essentials.adoc - include::example$chapters-data/code/02__control-flow-essentials/loop_labels.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run loop_labels.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">first all-even row: 1
found target value at row 1, column 1</programlisting>
</para>
</formalpara>
<simpara><literal>while</literal>循环的<literal>else null</literal>捕获"无匹配"情况，无需额外状态，标记的<literal>break :outer</literal>一旦找到目标就立即退出两个循环。这种模式保持状态处理紧凑，同时保持对控制转移的显式性。</simpara>
<section xml:id="_how_loops_lower_to_zir">
<title>循环如何降低到ZIR</title>
<simpara>循环被转换为带有显式中断和继续目标的标记块。这使得标记中断和循环<literal>else</literal>子句成为可能：</simpara>
<literallayout class="monospaced">graph TB
    Loop["while/for"] --&gt; LoopLabel["创建标记块"]

    LoopLabel --&gt; Condition["生成循环条件"]
    Condition --&gt; Body["生成循环体"]
    Body --&gt; Continue["生成继续表达式"]

    LoopLabel --&gt; BreakTarget["break_block目标"]
    Body --&gt; ContinueTarget["continue_block目标"]

    Continue --&gt; CondCheck["跳转回条件"]</literallayout>
<simpara>当你写<literal>outer: while (x &lt; 10)</literal>时，编译器创建：</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>break_block</emphasis>：<literal>break :outer</literal>语句的目标——退出循环</simpara>
</listitem>
<listitem>
<simpara><emphasis>continue_block</emphasis>：<literal>continue :outer</literal>语句的目标——跳转到下一次迭代</simpara>
</listitem>
<listitem>
<simpara><emphasis>循环体</emphasis>：包含你的代码，可以访问两个目标</simpara>
</listitem>
</itemizedlist>
<simpara>这就是为什么你可以嵌套循环并使用标记中断退出到特定级别——每个循环标签在ZIR中创建自己的break_block。循环<literal>else</literal>子句附加到break_block，仅当循环完成而不中断时执行。</simpara>
</section>
</section>
<section xml:id="section-1-sub-c">
<title>用于详尽决策的`switch`</title>
<simpara><literal>switch</literal>详尽检查值——覆盖字面量、范围和枚举——编译器强制执行完整性，除非你提供<literal>else</literal>分支。将<literal>switch</literal>与辅助函数结合是集中分类逻辑的干净方式。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 02__control-flow-essentials.adoc - include::example$chapters-data/code/02__control-flow-essentials/switch_examples.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run switch_examples.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">0: no progress
2: warming up
5: halfway there
8: almost done
10: perfect run
12: out of range
mode safe -&gt; factor 16</programlisting>
</para>
</formalpara>
<simpara>每个<literal>switch</literal>必须考虑所有可能性——一旦每个标签都被覆盖，编译器验证没有缺失情况。枚举消除了魔术数字，同时仍然允许你在编译时已知变体上分支。</simpara>
<section xml:id="_how_switch_expressions_lower_to_zir">
<title>`switch`表达式如何降低到ZIR</title>
<simpara>编译器将<literal>switch</literal>语句转换为结构块，详尽处理所有情况。范围情况、每个叉的多个值和负载捕获都在ZIR表示中编码：</simpara>
<literallayout class="monospaced">graph TB
    Switch["switch (target) { ... }"] --&gt; EvalTarget["评估目标操作数"]
    EvalTarget --&gt; Prongs["处理开关叉"]

    Prongs --&gt; Multi["每个叉多个情况"]
    Prongs --&gt; Range["范围情况(a...b)"]
    Prongs --&gt; Capture["捕获负载"]

    Multi --&gt; SwitchBlock["生成switch_block"]
    Range --&gt; SwitchBlock
    Capture --&gt; SwitchBlock

    SwitchBlock --&gt; ExtraData["存储在extra中:&lt;br/&gt;-叉计数&lt;br/&gt;-情况项&lt;br/&gt;-叉体"]</literallayout>
<simpara>详尽性检查在语义分析期间（ZIR生成后）类型已知时发生。编译器验证：</simpara>
<itemizedlist>
<listitem>
<simpara>所有枚举标签都被覆盖（或存在<literal>else</literal>分支）</simpara>
</listitem>
<listitem>
<simpara>整数范围不重叠</simpara>
</listitem>
<listitem>
<simpara>没有不可达的叉存在</simpara>
</listitem>
</itemizedlist>
<simpara>这就是为什么你不能在枚举的<literal>switch</literal>中意外忘记情况——类型系统在编译时确保完整性。像<literal>0...5</literal>这样的范围语法在ZIR中被编码为范围情况，而不是作为单独的值。</simpara>
</section>
</section>
</chapter>
<chapter xml:id="section-2">
<title>工作流模式</title>
<simpara>结合这些构造可以解锁更具表现力的管道：循环收集或过滤数据，<literal>switch</literal>路由操作，循环标签保持嵌套流精确，无需引入可变哨兵。本节将原语链接成可重用模式，你可以适应解析、模拟或状态机。</simpara>
<section xml:id="workflow-1">
<title>使用`break`值的脚本处理</title>
<simpara>此示例解释迷你指令流，使用标记的<literal>for</literal>循环来维护运行总数，并在达到阈值时停止。当开发期间出现未知标签时，<literal>switch</literal>处理命令分派，包括故意的<literal>unreachable</literal>。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 02__control-flow-essentials.adoc - include::example$chapters-data/code/02__control-flow-essentials/script_runner.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run script_runner.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">stopped at step 3 with total 7</programlisting>
</para>
</formalpara>
<simpara><literal>break :outer</literal>返回完整的<literal>Outcome</literal>结构体，使循环像搜索一样工作，要么找到目标，要么回退到循环的<literal>else</literal>。显式的<literal>unreachable</literal>为未来贡献者记录假设，并在调试版本中激活安全检查。</simpara>
</section>
<section xml:id="workflow-2">
<title>循环守卫和提前终止</title>
<simpara>有时数据本身发出停止信号。此演练识别第一个负数，然后累加偶数值直到出现<literal>0</literal>哨兵，演示循环<literal>else</literal>子句、标记<literal>continue</literal>和常规<literal>break</literal>。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 02__control-flow-essentials.adoc - include::example$chapters-data/code/02__control-flow-essentials/range_scan.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run range_scan.zig</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">first negative at index 3
encountered zero, breaking out
sum of even prefix values = 16</programlisting>
</para>
</formalpara>
<simpara>两个循环展示了互补的退出风格：带<literal>else</literal>默认的循环表达式，以及<literal>continue</literal>和<literal>break</literal>阐明哪些迭代对运行总数有贡献的标记循环。</simpara>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>说明与注意事项</title>
<itemizedlist>
<listitem>
<simpara>每当你有嵌套迭代时，为了清晰起见，更喜欢标记循环；它保持<literal>break</literal>/<literal>continue</literal>显式，并避免哨兵变量。</simpara>
</listitem>
<listitem>
<simpara><literal>switch</literal>必须保持详尽——如果你依赖<literal>else</literal>，用注释或<literal>unreachable</literal>记录不变量，以便未来的情况不会被默默忽略。</simpara>
</listitem>
<listitem>
<simpara>循环<literal>else</literal>子句仅在循环自然退出时评估；确保你的<literal>break</literal>路径返回值，以避免回退到意外的默认值。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>练习</title>
<itemizedlist>
<listitem>
<simpara>用第三个分支扩展<literal>branching.zig</literal>，以不同方式格式化大于100的值，确认<literal>if</literal>表达式仍然返回单个字符串。</simpara>
</listitem>
<listitem>
<simpara>调整<literal>loop_labels.zig</literal>，通过<literal>break :outer</literal>将确切坐标作为结构体返回，然后从<literal>main</literal>打印它们。</simpara>
</listitem>
<listitem>
<simpara>修改<literal>script_runner.zig</literal>以在运行时解析字符（例如，从字节切片），并添加一个重置总数的新命令，确保<literal>switch</literal>保持详尽。</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>