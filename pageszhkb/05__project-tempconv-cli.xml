<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>项目</title>
<subtitle>温度转换CLI</subtitle>
<date>2025-11-15</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>
<chapter xml:id="overview">
<title>概览</title>
<simpara>我们的第一个项目将第1-4章的语言基础转化为一个手持命令行实用程序，在摄氏度、华氏度和开尔文之间转换温度。我们将参数解析、枚举和浮点数学组合成一个程序，同时为最终用户保持诊断友好，如 <link xl:href="https://ziglang.org/documentation/master/#Command-line-flags">#命令行标志</link> 和 <link xl:href="https://ziglang.org/documentation/master/#Floats">#浮点数</link> 中所述。</simpara>
<simpara>在此过程中，我们强化了前一章的错误处理理念：验证产生人类可读的提示，进程有意退出而不是堆栈跟踪；参考 <link xl:href="https://ziglang.org/documentation/master/#Error-Handling">#错误处理</link>。</simpara>
</chapter>
<chapter xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>构建一个最小的CLI工具，读取参数，处理 <literal>--help</literal>，并发出使用指导。</simpara>
</listitem>
<listitem>
<simpara>用枚举表示温度单位，并使用 <literal>switch</literal> 标准化转换，如 <link xl:href="https://ziglang.org/documentation/master/#switch">#switch</link> 中所述。</simpara>
</listitem>
<listitem>
<simpara>呈现转换结果，同时通过简洁的诊断而非展开跟踪来表面验证失败。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="section-1">
<title>塑造命令接口</title>
<simpara>在接触任何数学之前，我们需要一个可预测的契约：三个参数（<literal>value</literal>、<literal>from-unit</literal>、<literal>to-unit</literal>）加上 <literal>--help</literal> 用于文档。程序应该预先解释错误，这样调用者永远不会看到恐慌。</simpara>
<section xml:id="section-1-sub-a-pre">
<title>CLI参数如何到达您的程序</title>
<simpara>当您从命令行运行程序时，操作系统在您的 <literal>main()</literal> 函数运行之前通过明确定义的启动序列传递参数。理解这个流程阐明了 <literal>std.process.args()</literal> 获取数据的位置：</simpara>
<literallayout class="monospaced">graph TB
    OS["操作系统"]
    EXEC["execve() 系统调用"]
    KERNEL["内核加载ELF"]
    STACK["栈设置：&lt;br/&gt;argc, argv[], envp[]"]
    
    START["_start 入口点&lt;br/&gt;（裸汇编）"]
    POSIX["posixCallMainAndExit&lt;br/&gt;(argc_argv_ptr)"]
    
    PARSE["解析栈布局：&lt;br/&gt;argc 在 [0]&lt;br/&gt;argv 在 [1..argc+1]&lt;br/&gt;envp 在 NULL 之后"]
    
    GLOBALS["设置全局状态：&lt;br/&gt;std.os.argv = argv[0..argc]&lt;br/&gt;std.os.environ = envp"]
    
    CALLMAIN["callMainWithArgs&lt;br/&gt;(argc, argv, envp)"]
    USERMAIN["您的 main() 函数"]
    ARGS["std.process.args()&lt;br/&gt;读取 std.os.argv"]
    
    OS --&gt; EXEC
    EXEC --&gt; KERNEL
    KERNEL --&gt; STACK
    STACK --&gt; START
    START --&gt; POSIX
    POSIX --&gt; PARSE
    PARSE --&gt; GLOBALS
    GLOBALS --&gt; CALLMAIN
    CALLMAIN --&gt; USERMAIN
    USERMAIN --&gt; ARGS</literallayout>
<simpara><emphasis role="strong">要点：</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">操作系统准备</emphasis>：操作系统在将控制权转移到您的程序之前，将 <literal>argc</literal>（参数计数）和 <literal>argv</literal>（参数数组）放在栈上。</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">汇编入口</emphasis>：<literal>_start</literal> 符号（用内联汇编编写）是真正的入口点，不是 <literal>main()</literal>。</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">栈解析</emphasis>：<literal>posixCallMainAndExit</literal> 读取栈布局以提取 <literal>argc</literal>、<literal>argv</literal> 和环境变量。</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">全局状态</emphasis>：在调用您的 <literal>main()</literal> 之前，运行时填充 <literal>std.os.argv</literal> 和 <literal>std.os.environ</literal> 以及解析的数据。</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">用户访问</emphasis>：当您调用 <literal>std.process.args()</literal> 时，它只是返回对已填充的 <literal>std.os.argv</literal> 切片的迭代器。</simpara>
</listitem>
</itemizedlist>
<simpara><emphasis role="strong">为什么这对CLI程序很重要：</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>从 <literal>main()</literal> 运行开始，参数就可用——无需单独的初始化。</simpara>
</listitem>
<listitem>
<simpara>第一个参数（<literal>argv[0]</literal>）始终是程序名称。</simpara>
</listitem>
<listitem>
<simpara>参数解析在启动期间发生一次，不是每次访问都发生。</simpara>
</listitem>
<listitem>
<simpara>无论您使用 <literal>zig run</literal> 还是编译的二进制文件，这个序列都是相同的。</simpara>
</listitem>
</itemizedlist>
<simpara>这种基础设施意味着您的TempConv CLI可以立即开始解析参数，而无需担心它们到达的低级细节。</simpara>
</section>
<section xml:id="section-1-sub-a">
<title>用护栏解析参数</title>
<simpara>入口点分配完整的参数向量，检查 <literal>--help</literal>，并验证数量。当规则被违反时，我们打印使用横幅并以失败代码退出，依靠 <literal>std.process.exit</literal> 避免嘈杂的堆栈跟踪。</simpara>
</section>
<section xml:id="section-1-sub-b">
<title>单位和验证助手</title>
<simpara>我们用枚举描述支持的单位，以及一个 <literal>parseUnit</literal> 助手，接受大写或小写标记。无效标记触发友好的诊断并立即退出，在嵌入脚本时保持CLI弹性，如 <link xl:href="https://ziglang.org/documentation/master/#enum">#枚举</link> 中所述。</simpara>
</section>
</chapter>
<chapter xml:id="section-2">
<title>转换和报告结果</title>
<simpara>有了接口，程序的其余部分依赖于确定性转换：每个值都标准化为开尔文，然后投影到请求的单位中，保证无论输入组合如何，结果都一致。</simpara>
<section xml:id="workflow-1">
<title>完整的TempConv列表</title>
<simpara>下面的列表包括参数解析、单位助手和转换逻辑。专注于CLI结构如何使每个失败路径显而易见，同时保持快乐路径简洁。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 05__project-tempconv-cli.adoc - include::example$chapters-data/code/05__project-tempconv-cli/tempconv_cli.zig[]</programlisting>
<formalpara>
<title>运行</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">$ zig run tempconv_cli.zig -- 32 F C</programlisting>
</para>
</formalpara>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">32.00 f -&gt; 0.00 c</programlisting>
</para>
</formalpara>
<tip>
<simpara>每当程序发现无效值或单位时，它都会在退出前打印诊断信息，因此脚本可以依赖非零退出状态，而无需解析堆栈跟踪。</simpara>
</tip>
</section>
<section xml:id="workflow-2">
<title>练习额外转换</title>
<simpara>您可以为开尔文或摄氏度输入运行相同的二进制文件——共享的转换助手保证对称性，因为所有内容都通过开尔文流动。</simpara>
<programlisting language="shell" linenumbering="unnumbered">$ zig run tempconv_cli.zig -- 273.15 K C</programlisting>
<formalpara>
<title>输出</title>
<para>
<programlisting language="shell" linenumbering="unnumbered">273.15 k -&gt; 0.00 c</programlisting>
</para>
</formalpara>
</section>
</chapter>
<chapter xml:id="notes-caveats">
<title>说明与注意事项</title>
<itemizedlist>
<listitem>
<simpara>参数解析按设计保持最小化；生产工具可能会使用相同的防护模式添加长格式标志或更丰富的帮助文本。</simpara>
</listitem>
<listitem>
<simpara>温度转换是线性的，因此双精度浮点数就足够了；如果您添加诸如Rankine之类的特殊温标，请仔细调整公式。</simpara>
</listitem>
<listitem>
<simpara><literal>std.debug.print</literal> 写入stderr，这使脚本化管道保持安全——如果您需要干净的stdout输出，请切换到缓冲的stdout写入器；参考 <link xl:href="https://ziglang.org/documentation/master/#Debug">#调试</link>。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="exercises">
<title>练习</title>
<itemizedlist>
<listitem>
<simpara>扩展 <literal>parseUnit</literal> 以识别完整单词 <literal>celsius</literal>、<literal>fahrenheit</literal> 和 <literal>kelvin</literal> 以及它们的单字母缩写。</simpara>
</listitem>
<listitem>
<simpara>添加一个标志，使用Zig的格式化动词在舍入输出（<literal>{d:.2}</literal>）和完全精度之间切换；参考 <link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/fmt.zig">fmt.zig</link>。</simpara>
</listitem>
<listitem>
<simpara>引入一个 <literal>--table</literal> 模式，为一系列值打印转换，用 <literal>for</literal> 强化切片迭代，如 <link xl:href="https://ziglang.org/documentation/master/#for">#for</link> 中所述。</simpara>
</listitem>
</itemizedlist>
</chapter>
<chapter xml:id="caveats-alternatives-edge-cases">
<title>替代方案和边缘情况：</title>
<itemizedlist>
<listitem>
<simpara>开尔文永远不会低于零；如果您的CLI应该拒绝负开尔文输入而不是接受数学值，请附加防护。</simpara>
</listitem>
<listitem>
<simpara>国际受众有时期望逗号小数；如果您需要这种行为，请将 <literal>std.fmt.formatFloat</literal> 与区域设置感知的后处理连接起来。</simpara>
</listitem>
<listitem>
<simpara>为了支持不使用 <literal>zig run</literal> 的脚本化用法，请使用 <literal>zig build-exe</literal> 打包程序，并将二进制文件放在您的 <literal>PATH</literal> 上。</simpara>
</listitem>
</itemizedlist>
</chapter>
</book>