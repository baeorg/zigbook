<?xml version="1.0" encoding="UTF-8"?>
<?asciidoc-toc?>
<?asciidoc-numbered?>
<book xmlns="http://docbook.org/ns/docbook" xmlns:xl="http://www.w3.org/1999/xlink" version="5.0" xml:lang="zh">
<info>
<title>交叉编译和WASM</title>
<subtitle>通过原生和WebAssembly目标扩展Zig的覆盖范围</subtitle>
<date>2025-11-06</date>
<copyright>
<holder>zigbook</holder>
</copyright>
</info>

<chapter xml:id="overview">
<title>概述</title>
<simpara>通过性能分析和安全保障收紧反馈循环后，<xref linkend="40__profiling-optimization-hardening" xrefstyle="short">40</xref> 我们准备将这些二进制文件发布到其他平台。本章将介绍目标发现、原生交叉编译以及生成WASI模块的基础知识，使用我们之前依赖的相同CLI工具。<link xl:href="ZIG_DEEP_WIKI.md#entry-points-and-command-structure">#入口点和命令结构</link></simpara>
<simpara>下一章将这些机制转化为完整的WASI项目，所以请将本章视为实践预检。<xref linkend="42__project-wasi-build-and-run" xrefstyle="short">42</xref></simpara>
</chapter>

<chapter xml:id="learning-goals">
<title>学习目标</title>
<itemizedlist>
<listitem>
<simpara>解释目标三元组并查询Zig的内置元数据以获取替代架构。<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Target/Query.zig">Query.zig</link></simpara>
</listitem>
<listitem>
<simpara>使用 <literal>zig build-exe</literal> 交叉编译原生可执行文件，并在不离开Linux的情况下验证工件。</simpara>
</listitem>
<listitem>
<simpara>生成WASI二进制文件，与原生代码共享相同的源代码，为项目构建管道做好准备。<link xl:href="https://ziglang.org/documentation/master/#Command-line-flags">#命令行标志</link></simpara>
</listitem>
</itemizedlist>
</chapter>

<chapter xml:id="target-discovery">
<title>映射目标三元组</title>
<simpara>Zig的 <literal>@import("builtin")</literal> 暴露了编译器对当前世界的理解，而 <literal>std.Target.Query.parse</literal> 允许你在不构建的情况下检查假设目标。<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/Target.zig">Target.zig</link></simpara>
<simpara>这是在使用 <literal>zig build</literal> 之前定制构建图或ENT文件的基础。</simpara>

<section xml:id="understanding-target-structure">
<title>理解目标结构</title>
<simpara>在解析目标三元组之前，了解Zig如何在内部表示编译目标是有价值的。下图显示了完整的 <literal>std.Target</literal> 结构：</simpara>
<informalfigure>
<mediaobject>
<textobject><phrase>std.Target结构图</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>这个结构揭示了目标三元组如何映射到具体配置。当你指定 <literal>-target wasm32-wasi</literal> 时，你将CPU架构设置为 <literal>wasm32</literal>，OS标签设置为 <literal>wasi</literal>，并隐式地将ObjectFormat设置为 <literal>wasm</literal>。三元组 <literal>x86_64-windows-gnu</literal> 映射到架构 <literal>x86_64</literal>，OS <literal>windows</literal>，ABI <literal>gnu</literal>，以及格式 <literal>coff</literal>（Windows PE）。</simpara>
<simpara>每个组件都会影响代码生成：CPU架构决定指令集和调用约定，OS标签选择系统调用接口和运行时期望，ABI指定调用约定和名称修饰，ObjectFormat选择链接器（ELF用于Linux，Mach-O用于Darwin，COFF用于Windows，WASM用于Web/WASI）。理解这种映射有助于你解码 <literal>std.Target.Query.parse</literal> 结果，预测交叉编译行为，以及排查目标特定问题。CPU特性字段捕获架构特定功能（x86_64上的AVX，ARM上的SIMD），优化器使用这些功能进行代码生成。</simpara>
</section>

<section xml:id="target-resolution-flow">
<title>目标解析流程</title>
<simpara>目标查询（用户输入）通过系统化过程解析为具体目标：</simpara>
<informalfigure>
<mediaobject>
<textobject><phrase>目标解析流程图</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>目标查询来自三个来源：命令行 <literal>-target</literal> 标志（显式用户选择），未指定目标时的原生检测（通过cpuid或/proc/cpuinfo读取主机CPU，通过uname或NT API读取OS，以及通过ldd或平台默认设置读取ABI），或构建脚本中的模块配置。</simpara>
<simpara><literal>resolveTargetQuery()</literal> 函数将查询（可能包含"native"或"default"占位符）转换为完全具体的 <literal>std.Target</literal> 实例，通过填写所有缺失的详细信息。这种解析在代码生成之前的编译初始化期间发生。</simpara>
<simpara>当你省略 <literal>-target</literal> 时，Zig会自动检测你的主机系统并构建原生目标。当你指定部分三元组如 <literal>wasm32-wasi</literal> 时，解析会填充ABI（通常为WASI的 <literal>musl</literal>）和对象格式（<literal>wasm</literal>）。解析后的目标然后流入编译模块，在那里它控制代码生成的各个方面，从指令选择到运行时库选择。</simpara>
</section>

<section xml:id="target-query-example">
<title>示例：从代码比较主机和交叉目标</title>
<simpara>示例内省主机三元组，然后解析两个交叉目标，打印解析后的架构、OS和ABI。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 41__cross-compilation-and-wasm.adoc - include::example$chapters-data/code/41__cross-compilation-and-wasm/01_target_matrix.zig[]</programlisting>
<para role="simpara">运行</para>
<screen language="shell">$ zig run 01_target_matrix.zig</screen>
<para role="simpara">输出</para>
<screen language="shell">host triple: x86_64-linux-gnu
pointer width: 64 bits
query wasm32-wasi: arch=wasm32 os=wasi abi=gnu
query x86_64-windows-gnu: arch=x86_64 os=windows abi=gnu
single-threaded: false</screen>
<note><simpara>解析器遵循与 <literal>-Dtarget</literal> 或 <literal>zig build-exe -target</literal> 相同的语法；在调用编译器之前回收输出以播种构建配置。</simpara></note>
</section>
</chapter>

<chapter xml:id="native-cross">
<title>交叉编译原生可执行文件</title>
<simpara>有了三元组，交叉编译就是交换目标标志的问题。Zig 0.15.2附带自包含的libc集成，因此在Linux上生成Windows或macOS二进制文件不再需要额外的SDK。<link xl:href="https://ziglang.org/download/0.15.1/release-notes.html">v0.15.2</link></simpara>
<simpara>使用 <literal>file</literal> 或类似工具来确认工件，而无需启动另一个OS。</simpara>

<section xml:id="windows-example">
<title>示例：从Linux使用 <literal>zig build-exe</literal> 编译到Windows</title>
<simpara>我们保持源代码相同，原生运行以进行健全性检查，然后发出Windows PE二进制文件并在原地检查它。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 41__cross-compilation-and-wasm.adoc - include::example$chapters-data/code/41__cross-compilation-and-wasm/02_cross_greeter.zig[]</programlisting>
<para role="simpara">运行</para>
<screen language="shell">$ zig run 02_cross_greeter.zig</screen>
<para role="simpara">输出</para>
<screen language="shell">hello from x86_64-linux-gnu!
default executable suffix: </screen>
<para role="simpara">交叉编译</para>
<screen language="shell">$ zig build-exe 02_cross_greeter.zig -target x86_64-windows-gnu -OReleaseFast -femit-bin=greeter-windows.exe
$ file greeter-windows.exe</screen>
<para role="simpara">输出</para>
<screen language="shell">greeter-windows.exe: PE32+ executable (console) x86-64, for MS Windows, 7 sections</screen>
<tip><simpara>当你需要旧硬件的可移植二进制文件时，将 <literal>-target</literal> 与 <literal>-mcpu=baseline</literal> 配对；上面的 <literal>std.Target.Query</literal> 输出显示Zig将假设的CPU模型。</simpara></tip>
</section>
</chapter>

<chapter xml:id="wasi-modules">
<title>生成WASI模块</title>
<simpara>WebAssembly系统接口（WASI）构建与原生管道共享大部分内容，但对象格式不同。相同的Zig源代码可以在Linux上打印诊断信息，并在交叉编译时发出 <literal>.wasm</literal> 有效负载，这要归功于本版本中引入的共享libc部分。</simpara>

<section xml:id="object-formats-linker-selection">
<title>对象格式和链接器选择</title>
<simpara>在生成WASI二进制文件之前，了解对象格式如何确定编译输出非常重要。下图显示了ABI和对象格式之间的关系：</simpara>
<informalfigure>
<mediaobject>
<textobject><phrase>常见ABI图</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>对象格式确定Zig使用哪个链接器实现来生成最终二进制文件。<strong>ELF</strong>（可执行和可链接格式）用于Linux和BSD系统，生成 <literal>.so</literal> 共享库和标准可执行文件。<strong>Mach-O</strong> 目标Darwin系统（macOS、iOS），生成 <literal>.dylib</literal> 库和Mach可执行文件。<strong>COFF</strong>（通用对象文件格式）在定位Windows时生成Windows PE二进制文件（<literal>.exe</literal>、<literal>.dll</literal>）。<strong>WASM</strong>（WebAssembly）是一种独特的格式，为Web浏览器和WASI运行时生成 <literal>.wasm</literal> 模块。与传统格式不同，WASI模块是为沙箱执行而设计的独立于平台的字节码。<strong>C</strong> 和 <strong>SPIRV</strong> 是专门的：C输出源代码以与C构建系统集成，而SPIRV生成GPU着色器字节码。</simpara>
<simpara>当你为 <literal>-target wasm32-wasi</literal> 构建时，Zig选择WASM对象格式并调用WebAssembly链接器（<literal>link/Wasm.zig</literal>），它处理WASM特定概念，如函数导入/导出、内存管理和表初始化。这与ELF链接器（符号解析、重定位）或COFF链接器（导入表、资源节）根本不同。相同的源代码透明地编译为不同的对象格式——无论目标是原生Linux（ELF）、Windows（COFF）还是WASI（WASM），你的Zig代码都保持相同。</simpara>
</section>

<section xml:id="wasi-example">
<title>示例：单一源代码、原生运行、WASI工件</title>
<simpara>我们的管道记录执行阶段，并在 <literal>builtin.target.os.tag</literal> 上分支，因此WASI构建会宣布自己的入口点。</simpara>
<programlisting language="zig" linenumbering="unnumbered">Unresolved directive in 41__cross-compilation-and-wasm.adoc - include::example$chapters-data/code/41__cross-compilation-and-wasm/03_wasi_pipeline.zig[]</programlisting>
<para role="simpara">运行</para>
<screen language="shell">$ zig run 03_wasi_pipeline.zig</screen>
<para role="simpara">输出</para>
<screen language="shell">stage: parse-args
stage: render-payload
stage: native-entry
stage: linux</screen>
<para role="simpara">WASI构建</para>
<screen language="shell">$ zig build-exe 03_wasi_pipeline.zig -target wasm32-wasi -OReleaseSmall -femit-bin=wasi-pipeline.wasm
$ ls -lh wasi-pipeline.wasm</screen>
<para role="simpara">输出</para>
<screen language="shell">-rwxr--r-- 1 zkevm zkevm 4.6K Nov  6 13:40 wasi-pipeline.wasm</screen>
<note><simpara>使用你喜欢的运行时（Wasmtime、Wasmer、浏览器）运行生成的模块，或将其交给下一章的构建图。无需更改源代码。</simpara></note>
</section>
</chapter>

<chapter xml:id="notes-caveats">
<title>注意事项和警告</title>
<itemizedlist>
<listitem>
<simpara><literal>zig targets</literal> 提供了支持的三元组的权威矩阵。在分派作业之前，编写脚本验证你的构建矩阵。</simpara>
</listitem>
<listitem>
<simpara>某些目标默认使用 <literal>ReleaseSmall</literal> 风格的安全性。当你需要跨架构的一致运行时检查时，显式设置 <literal>-Doptimize</literal>。<link xl:href="https://ziglang.org/documentation/master/#releasefast">#releasefast</link></simpara>
</listitem>
<listitem>
<simpara>当交叉链接到glibc时，填充 <literal>ZIG_LIBC</literal> 或使用 <literal>zig fetch</literal> 缓存sysroot工件，这样链接器就不会意外地访问主机头文件。</simpara>
</listitem>
</itemizedlist>
</chapter>

<chapter xml:id="exercises">
<title>练习</title>
<itemizedlist>
<listitem>
<simpara>使用 <literal>--cpu</literal> 和 <literal>--os</literal> 标志扩展问候程序，然后为 <literal>x86_64-macos-gnu</literal> 和 <literal>aarch64-linux-musl</literal> 发出二进制文件，并使用 <literal>ls -lh</literal> 捕获它们的大小。</simpara>
</listitem>
<listitem>
<simpara>修改WASI管道以通过 <literal>std.json.stringify</literal> 发出JSON，然后在WASI运行时中运行它并捕获输出以进行回归测试。<link xl:href="https://github.com/ziglang/zig/tree/master/lib/std/json.zig">json.zig</link></simpara>
</listitem>
<listitem>
<simpara>编写一个 <literal>build.zig</literal> 步骤，该步骤循环遍历目标三元组列表，并为每个目标调用 <literal>addExecutable</literal> 一次，使用 <literal>std.Target.Query</literal> 助手打印人类友好的标签。<xref linkend="22__build-system-deep-dive" xrefstyle="short">22</xref></simpara>
</listitem>
</itemizedlist>
</chapter>

<chapter xml:id="caveats-alternatives-edge-cases">
<title>替代方案和边缘情况：</title>
<itemizedlist>
<listitem>
<simpara>LLVM支持的目标可能仍然与Zig的自托管代码生成行为不同。当你遇到新兴架构时，回退到 <literal>-fllvm</literal>。</simpara>
</listitem>
<listitem>
<simpara>WASI禁止许多系统调用和动态分配模式。保持日志记录简洁或门控，以避免超出导入预算。</simpara>
</listitem>
<listitem>
<simpara>Windows交叉编译默认选择GNU工具链。如果你打算链接到MSVC提供的库，请添加 <literal>-msvc</literal> 或切换ABI。<xref linkend="20__concept-primer-modules-vs-programs-vs-packages-vs-libraries" xrefstyle="short">20</xref></simpara>
</listitem>
</itemizedlist>
</chapter>
</book>