////
changes: ["æ•°æ®åŸºç¡€ç« èŠ‚åˆç¨¿"]
examples_compile: yes
keywords: ["æ•°ç»„", "åˆ‡ç‰‡", "æŒ‡é’ˆ"]
last_updated: 2025-11-01
last_verified: 2025-11-01
next_chapter: "04__errors-resource-cleanup"
open_questions: []
previous_chapter: "02__control-flow-essentials"
status: reviewed
xref_complete: true
////

= æ•°æ®åŸºç¡€
:chapter-number: 3
:chapter-slug: data-fundamentals
:copyright: zigbook
:doctype: book
:embedded:
:experimental:
:icons: font
:partnums:
:pygments-linenums-mode: inline
:pygments-style: manni
:safe-mode-level: 0
:sectanchors:
:sectids:
:sectlinks:
:source-highlighter: pygments
:sourcedir: example$chapters-data/code
:webfonts:
:xrefstyle: short
:zig-version: 0.15.2
:linkcss:
:stylesdir: styles
:stylesheet: zigbook.css

[[overview]]
== æ¦‚è§ˆ

æ§åˆ¶æµåªæœ‰åœ¨æ“ä½œæ•°æ®æ—¶æ‰æœ‰ç”¨ï¼Œå› æ­¤æœ¬ç« å°† Zig çš„æ ¸å¿ƒé›†åˆç±»å‹â€”â€”æ•°ç»„ã€åˆ‡ç‰‡ä¸å“¨å…µç»ˆæ­¢å­—ç¬¦ä¸²â€”â€”ç½®äºå®é™…ä½¿ç”¨ä¸­ï¼ŒåŒæ—¶ä¿æŒå€¼è¯­ä¹‰æ˜ç¡®ã€‚å‚è€ƒ link:https://ziglang.org/documentation/master/#Arrays[#æ•°ç»„] ä¸ link:https://ziglang.org/documentation/master/#Slices[#åˆ‡ç‰‡]ã€‚

æˆ‘ä»¬è¿˜å°†ä½¿æŒ‡é’ˆã€å¯é€‰ç±»å‹ä¸å¯¹é½å‹å¥½çš„è½¬æ¢å˜å¾—å¸¸è§„ï¼Œå±•ç¤ºå¦‚ä½•å®‰å…¨åœ°é‡æ–°è§£é‡Šå†…å­˜ï¼ŒåŒæ—¶ä¿ç•™è¾¹ç•Œæ£€æŸ¥ä¸å¯¹å¯å˜æ€§çš„æ¸…æ™°åº¦ã€‚å‚è€ƒ link:https://ziglang.org/documentation/master/#Pointers[#æŒ‡é’ˆ] ä¸ link:https://ziglang.org/documentation/master/#alignCast[#å¯¹é½è½¬æ¢]ã€‚

[[type-system-context]]
=== Zig çš„ç±»å‹ç³»ç»Ÿç±»åˆ«

Before diving into specific collection types, it's helpful to understand where arrays, slices, and pointers fit within Zig's type system. Every type in Zig belongs to a category, and each category provides specific operations:

[mermaid]
....
graph TB
    subgraph "Type Categories"
        PRIMITIVE["Primitive Types<br/>bool, u8, i32, f64, void, ..."]
        POINTER["Pointer Types<br/>*T, [*]T, []T, [:0]T"]
        AGGREGATE["Aggregate Types<br/>struct, array, tuple"]
        FUNCTION["Function Types<br/>fn(...) ReturnType"]
        SPECIAL["Special Types<br/>anytype, type, comptime_int"]
    end

    subgraph "Common Type Operations"
        ABISIZE["abiSize()<br/>Byte size in memory"]
        ABIALIGN["abiAlignment()<br/>Required alignment"]
        HASRUNTIME["hasRuntimeBits()<br/>Has runtime storage?"]
        ELEMTYPE["elemType()<br/>Element type (arrays/slices)"]
    end

    PRIMITIVE --> ABISIZE
    POINTER --> ABISIZE
    AGGREGATE --> ABISIZE
    
    PRIMITIVE --> ABIALIGN
    POINTER --> ABIALIGN
    AGGREGATE --> ABIALIGN
    
    POINTER --> ELEMTYPE
    AGGREGATE --> ELEMTYPE
....

Key insights for this chapter:

* *Arrays* are aggregate types with compile-time-known lengthâ€”their size is `element_size * length`
* *Slices* are pointer types that store both a pointer and runtime lengthâ€”always 2 Ã— pointer size
* *Pointers* come in multiple shapes (single-item `pass:[*T]`, many-item `pass:[[*\]T]`, slice `[]T`) with different safety guarantees
* All types expose their size and alignment, which affect struct layout and memory allocation

This type-aware design lets the compiler enforce bounds checking on slices while allowing pointer arithmetic on many-item pointers when you explicitly opt out of safety.

[[learning-goals]]
== å­¦ä¹ ç›®æ ‡

* åŒºåˆ†æ•°ç»„å€¼è¯­ä¹‰ä¸åˆ‡ç‰‡è§†å›¾ï¼ŒåŒ…æ‹¬ç”¨äºå®‰å…¨å›é€€çš„é›¶é•¿åº¦ä¹ è¯­ã€‚
* ç†Ÿæ‚‰æŒ‡é’ˆå½¢çŠ¶ï¼ˆ`pass:[*T]`ã€`pass:[[*\]T]`ã€`pass:[?*T]`ï¼‰ï¼Œå¹¶åœ¨ä¸ç‰ºç‰²å®‰å…¨æ£€æŸ¥çš„æƒ…å†µä¸‹è§£åŒ…å¯é€‰ç±»å‹ï¼ˆå‚è€ƒ link:https://ziglang.org/documentation/master/#Optionals[#å¯é€‰ç±»å‹]ï¼‰ã€‚
* åœ¨ä¸å…¶å®ƒ API äº’æ“ä½œæ—¶åº”ç”¨å“¨å…µç»ˆæ­¢å­—ç¬¦ä¸²ä¸å¯¹é½æ„ŸçŸ¥è½¬æ¢ï¼ˆ`@alignCast`ã€`@bitCast`ã€`@intCast`ï¼‰ï¼ˆå‚è€ƒ link:https://ziglang.org/documentation/master/#Sentinel-Terminated-Pointers[#å“¨å…µç»ˆæ­¢æŒ‡é’ˆ] ä¸ link:https://ziglang.org/documentation/master/#Explicit-Casts[#æ˜¾å¼è½¬æ¢]ï¼‰ã€‚

[[section-1]]
== åœ¨å†…å­˜ä¸­æ„å»ºé›†åˆ

æ•°ç»„æ‹¥æœ‰å­˜å‚¨è€Œåˆ‡ç‰‡å€Ÿç”¨å­˜å‚¨ï¼Œå› æ­¤ç¼–è¯‘å™¨åœ¨é•¿åº¦ã€å¯å˜æ€§ä¸ç”Ÿå‘½å‘¨æœŸæ–¹é¢å¼ºåˆ¶æ‰§è¡Œä¸åŒçš„ä¿è¯ï¼›æŒæ¡å®ƒä»¬çš„ç›¸äº’ä½œç”¨ä½¿è¿­ä»£æ›´å¯é¢„æµ‹ï¼Œå¹¶å°†å¤§å¤šæ•°è¾¹ç•Œæ£€æŸ¥ç§»è‡³è°ƒè¯•æ„å»ºã€‚

[[section-1-sub-a]]
=== ä½œä¸ºæ‹¥æœ‰å­˜å‚¨çš„æ•°ç»„

æ•°ç»„åœ¨å…¶ç±»å‹ä¸­æºå¸¦é•¿åº¦ï¼ŒæŒ‰å€¼å¤åˆ¶ï¼Œå¹¶ä¸ºä½ æä¾›ä¸€ä¸ªå¯å˜çš„åŸºçº¿ï¼Œä»ä¸­å¯ä»¥åˆ†å‰²åªè¯»ä¸è¯»å†™åˆ‡ç‰‡ã€‚

[source,zig]
----

include::{sourcedir}/03__data-fundamentals/arrays_and_slices.zig[]

----

.Run
[source,shell]
----
$ zig run arrays_and_slices.zig
----

.Output
[source,shell]
----
array len=4 allows mutation
mutable_slice: len=4 head=-3
prefix: len=2 head=-3
values[0] after slice write = -3
empty slice len=0 is zero-length
copy[0]=-1 owned[0]=1
zero slice len=0 from literal
----

[NOTE]
å¯å˜åˆ‡ç‰‡ä¸åŸå§‹æ•°ç»„å…±äº«å­˜å‚¨ï¼Œè€Œ `[]const` å‰ç¼€é˜»æ­¢å†™å…¥â€”â€”è¿™æ˜¯ä¸€ä¸ªæœ‰æ„çš„è¾¹ç•Œï¼Œè¿«ä½¿åªè¯»æ¶ˆè´¹è€…ä¿æŒè¯šå®ã€‚

==== å†…å­˜å¸ƒå±€ï¼šæ•°ç»„ä¸åˆ‡ç‰‡

Understanding how arrays and slices are laid out in memory clarifies why "arrays own storage while slices borrow it" and why array-to-slice coercion is a cheap operation:

[mermaid]
....
graph TB
    subgraph "Array in Memory"
        ARRAY_DECL["const values: [4]i32 = .{1, 2, 3, 4}"]
        ARRAY_MEM["Memory Layout (16 bytes)\n\nstack frame\n| 1 | 2 | 3 | 4 |"]
        
        ARRAY_DECL --> ARRAY_MEM
    end
    
    subgraph "Slice in Memory"
        SLICE_DECL["const slice: []const i32 = &values"]
        SLICE_MEM["Memory Layout (16 bytes on 64-bit)\n\nstack frame\n|    ptr    |   len=4   |"]
        POINTS["ptr points to array data"]
        
        SLICE_DECL --> SLICE_MEM
        SLICE_MEM --> POINTS
    end
    
    POINTS -.->|"references"| ARRAY_MEM
    
    subgraph "Key Differences"
        DIFF1["Array: Stores data inline<br/>Size = elem_size Ã— length"]
        DIFF2["Slice: Stores pointer + length<br/>Size = 2 Ã— pointer_size (16 bytes on 64-bit)"]
        DIFF3["Coercion: &array â†’ slice<br/>Just creates {ptr, len} pair"]
    end
....

**ä¸ºä»€ä¹ˆè¿™å¾ˆé‡è¦ï¼š**

* æ•°ç»„å…·æœ‰**å€¼è¯­ä¹‰**ï¼šåˆ†é…æ•°ç»„ä¼šå¤åˆ¶æ‰€æœ‰å…ƒç´ 
* åˆ‡ç‰‡å…·æœ‰**å¼•ç”¨è¯­ä¹‰**ï¼šåˆ†é…åˆ‡ç‰‡åªä¼šå¤åˆ¶æŒ‡é’ˆä¸é•¿åº¦
* æ•°ç»„åˆ°åˆ‡ç‰‡çš„å¼ºåˆ¶è½¬æ¢ï¼ˆ`&array`ï¼‰æ˜¯å»‰ä»·çš„â€”â€”å®ƒä¸å¤åˆ¶æ•°æ®ï¼Œåªæ˜¯åˆ›å»ºä¸€ä¸ªæè¿°ç¬¦
* åˆ‡ç‰‡æ˜¯â€œèƒ–æŒ‡é’ˆâ€ï¼šå®ƒä»¬æºå¸¦è¿è¡Œæ—¶é•¿åº¦ä¿¡æ¯ï¼Œæ”¯æŒè¾¹ç•Œæ£€æŸ¥

è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå‡½æ•°é€šå¸¸æ¥å—åˆ‡ç‰‡ä½œä¸ºå‚æ•°â€”â€”å®ƒä»¬å¯ä»¥å¤„ç†æ•°ç»„ã€åˆ‡ç‰‡å’Œä¸¤è€…çš„éƒ¨åˆ†ï¼Œè€Œæ— éœ€å¤åˆ¶åº•å±‚æ•°æ®ã€‚

[[section-1-sub-b]]
=== å®è·µä¸­çš„å­—ç¬¦ä¸²ä¸å“¨å…µ

å“¨å…µç»ˆæ­¢æ•°ç»„æ¡¥æ¥åˆ° C APIï¼Œè€Œä¸ç‰ºç‰²åˆ‡ç‰‡çš„å®‰å…¨æ€§ï¼›ä½ å¯ä»¥ç”¨ `std.mem.span` é‡æ–°è§£é‡Šå­—èŠ‚æµï¼Œå¹¶åœ¨ä¿ç•™å“¨å…µçº¦å®šæ—¶ä»ç„¶å˜å¼‚åº•å±‚ç¼“å†²åŒºã€‚

[source,zig]
----
    
include::{sourcedir}/03__data-fundamentals/sentinel_strings.zig[]

----

.Run
[source,shell]
----
$ zig run sentinel_strings.zig
----

.Output
[source,shell]
----
literal len=17 contents="data fundamentals"
trimmed slice len=4 -> Labe
full label after mutation: LabeX
----

å“¨å…µåˆ‡ç‰‡ä¿æŒå°¾éƒ¨é›¶å®Œæ•´ï¼Œå› æ­¤å³ä¾¿åœ¨æœ¬åœ°å˜å¼‚åï¼Œä¸º FFI è·å– `pass:[[*:0\]u8]` ä»ç„¶æœ‰æ•ˆï¼Œè€Œæ™®é€šåˆ‡ç‰‡åœ¨ Zig å†…æä¾›ç¬¦åˆäººä½“å·¥ç¨‹å­¦çš„è¿­ä»£ï¼ˆå‚è€ƒ link:https://ziglang.org/documentation/master/#Type-Coercion[#ç±»å‹å¼ºåˆ¶è½¬æ¢]ï¼‰ã€‚

TIP: `std.mem.span` å°†å“¨å…µæŒ‡é’ˆè½¬æ¢ä¸ºæ™®é€šåˆ‡ç‰‡è€Œä¸å…‹éš†æ•°æ®ï¼Œå½“ä½ ä¸´æ—¶éœ€è¦è¾¹ç•Œæ£€æŸ¥æˆ–åˆ‡ç‰‡è¾…åŠ©åå†è¿”å›æŒ‡é’ˆ API æ—¶ï¼Œå®ƒæ˜¯ç†æƒ³é€‰æ‹©ã€‚

[[section-1-sub-c]]
=== ä¸å¯å˜ä¸å¯å˜è§†å›¾

å½“è°ƒç”¨è€…ä»…æ£€æŸ¥æ•°æ®æ—¶ï¼Œä¼˜å…ˆä½¿ç”¨ `[]const T`â€”â€”Zig ä¼šä¹äºå°†å¯å˜åˆ‡ç‰‡å¼ºåˆ¶è½¬æ¢ä¸º const è§†å›¾ï¼Œæä¾› API æ¸…æ™°åº¦ï¼Œå¹¶è®©æ„å¤–å†™å…¥åœ¨ä¸€å¼€å§‹å°±æ— æ³•ç¼–è¯‘ã€‚

[[section-2]]
== æŒ‡é’ˆæ¨¡å¼ä¸è½¬æ¢å·¥ä½œæµ

å½“ä½ å…±äº«å­˜å‚¨ã€ä¸å¤–éƒ¨å¸ƒå±€äº’æ“ä½œæˆ–è¶…å‡ºåˆ‡ç‰‡è¾¹ç•Œæ—¶ï¼ŒæŒ‡é’ˆå°±ä¼šå‡ºç°ï¼›é€šè¿‡ä¾èµ–å¯é€‰åŒ…è£…ä¸æ˜¾å¼è½¬æ¢ï¼Œä½ ä¿æŒæ„å›¾æ¸…æ™°ï¼Œå¹¶å…è®¸å®‰å…¨æ£€æŸ¥åœ¨å‡è®¾å¤±æ•ˆæ—¶è§¦å‘ã€‚

[[pointer-shapes]]
=== æŒ‡é’ˆå½¢çŠ¶å‚è€ƒ

Zig offers multiple pointer types, each with different safety guarantees and use cases. Understanding when to use each shape is essential for writing safe, efficient code:

[mermaid]
....
graph TB
    subgraph "Pointer Shapes"
        SINGLE["*T<br/>Single-Item Pointer"]
        MANY["[*]T<br/>Many-Item Pointer"]
        SLICE["[]T<br/>Slice"]
        OPTIONAL["?*T<br/>Optional Pointer"]
        SENTINEL_PTR["[*:0]T<br/>Sentinel Many-Item"]
        SENTINEL_SLICE["[:0]T<br/>Sentinel Slice"]
    end
    
    subgraph "Characteristics"
        SINGLE --> S_BOUNDS["âœ“ Bounds: Single element<br/>âœ“ Safety: Dereference checked<br/>ğŸ“ Use: Function parameters, references"]
        
        MANY --> M_BOUNDS["âš  Bounds: Unknown length<br/>âœ— Safety: No bounds checking<br/>ğŸ“ Use: C interop, tight loops"]
        
        SLICE --> SL_BOUNDS["âœ“ Bounds: Runtime length<br/>âœ“ Safety: Bounds checked<br/>ğŸ“ Use: Most Zig code, iteration"]
        
        OPTIONAL --> O_BOUNDS["âœ“ Bounds: May be null<br/>âœ“ Safety: Must unwrap first<br/>ğŸ“ Use: Optional references"]
        
        SENTINEL_PTR --> SP_BOUNDS["âœ“ Bounds: Until sentinel<br/>~ Safety: Sentinel must exist<br/>ğŸ“ Use: C strings, null-terminated"]
        
        SENTINEL_SLICE --> SS_BOUNDS["âœ“ Bounds: Length + sentinel<br/>âœ“ Safety: Both length and sentinel<br/>ğŸ“ Use: Zig â†” C string bridge"]
    end
....

**æ¯”è¾ƒè¡¨ï¼š**

|===
| å½¢çŠ¶ | ç¤ºä¾‹ | é•¿åº¦å·²çŸ¥ï¼Ÿ | è¾¹ç•Œæ£€æŸ¥ï¼Ÿ | å¸¸è§ç”¨é€”

| `*T`
| `*i32`
| å•ä¸ªå…ƒç´ 
| æ˜¯ï¼ˆéšå¼ï¼‰
| å•é¡¹å¼•ç”¨

| `[*]T`
| `[*]i32`
| æœªçŸ¥
| **å¦**
| C æ•°ç»„ã€æŒ‡é’ˆç®—æœ¯

| `[]T`
| `[]i32`
| è¿è¡Œæ—¶ï¼ˆåœ¨åˆ‡ç‰‡ä¸­ï¼‰
| **æ˜¯**
| ä¸»è¦ Zig é›†åˆç±»å‹

| `?*T`
| `?*i32`
| å•ä¸ªï¼ˆè‹¥é nullï¼‰
| æ˜¯ + null æ£€æŸ¥
| å¯é€‰å¼•ç”¨

| `[*:0]T`
| `[*:0]u8`
| ç›´åˆ°å“¨å…µ
| å“¨å…µå¿…é¡»å­˜åœ¨
| C å­—ç¬¦ä¸²ï¼ˆ`char*`ï¼‰

| `[:0]T`
| `[:0]u8`
| è¿è¡Œæ—¶ + å“¨å…µ
| æ˜¯ + å“¨å…µä¿è¯
| ç”¨äº C API çš„ Zig å­—ç¬¦ä¸²
|===

**æŒ‡å¯¼åŸåˆ™ï¼š**

* **é»˜è®¤ä½¿ç”¨åˆ‡ç‰‡**ï¼ˆ`[]T`ï¼‰ç”¨äºæ‰€æœ‰ Zig ä»£ç â€”â€”å®ƒä»¬æä¾›å®‰å…¨ä¸ä¾¿åˆ©
* **ä½¿ç”¨å•é¡¹æŒ‡é’ˆ**ï¼ˆ`pass:[*T]`ï¼‰å½“ä½ éœ€è¦å˜å¼‚å•ä¸ªå€¼æˆ–æŒ‰å¼•ç”¨ä¼ é€’æ—¶
* **é¿å…å¤šé¡¹æŒ‡é’ˆ**ï¼ˆ`pass:[[*\]T]`ï¼‰é™¤éä¸ C æ¥å£æˆ–åœ¨æ€§èƒ½å…³é”®çš„å†…éƒ¨å¾ªç¯ä¸­
* **ä½¿ç”¨å¯é€‰æŒ‡é’ˆ**ï¼ˆ`pass:[?*T]`ï¼‰å½“ null æ˜¯æœ‰æ„ä¹‰çš„çŠ¶æ€æ—¶ï¼Œè€Œéç”¨äºé”™è¯¯å¤„ç†
* **ä½¿ç”¨å“¨å…µç±»å‹**ï¼ˆ`pass:[[*:0\]T]`ã€`[:0]T`ï¼‰åœ¨ C è¾¹ç•Œï¼Œå†…éƒ¨è½¬æ¢ä¸ºåˆ‡ç‰‡

[[workflow-1]]
=== ç”¨äºå…±äº«å¯å˜æ€§çš„å¯é€‰æŒ‡é’ˆ

Optional single-item pointers expose mutability without guessing at lifetimesâ€”capture them only when present, mutate through the dereference, and fall back gracefully when the pointer is absent.

[source,zig]
----

include::{sourcedir}/03__data-fundamentals/pointers_and_optionals.zig[]

----

.Run
[source,shell]
----
$ zig run pointers_and_optionals.zig
----

.Output
[source,shell]
----
alias -> reading 42
optional pointer empty
optional pointer mutated to 52
slice view len=4
samples[2] via many pointer = 42
----

`pass:[?*Sensor]` é—¨æ§å°†å¯å˜æ€§éšè—åœ¨æ¨¡å¼åŒ¹é…ä¹‹åï¼Œè€Œå¤šé¡¹æŒ‡é’ˆï¼ˆ`pass:[[*\]i32]`ï¼‰é€šè¿‡åˆ é™¤è¾¹ç•Œæ£€æŸ¥è®°å½•åˆ«åé£é™©â€”â€”è¿™æ˜¯ä¸ºç´§å‡‘å¾ªç¯ä¸ FFI ä¿ç•™çš„æ·±æ€ç†Ÿè™‘çš„æƒè¡¡ã€‚

[[workflow-2]]
=== å¯¹é½ä¸é‡æ–°è§£é‡Šæ•°æ®

å½“ä½ å¿…é¡»é‡æ–°è§£é‡ŠåŸå§‹å­—èŠ‚æ—¶ï¼Œä½¿ç”¨è½¬æ¢å†…å»ºå‡½æ•°æå‡å¯¹é½ã€æ”¹å˜æŒ‡é’ˆå…ƒç´ ç±»å‹ï¼Œå¹¶ä¿æŒæ•´æ•°/æµ®ç‚¹è½¬æ¢çš„æ˜¾å¼æ€§ï¼Œä»¥ä¾¿è°ƒè¯•æ„å»ºæ•è·æœªå®šä¹‰çš„å‡è®¾ï¼ˆå‚è€ƒ link:https://ziglang.org/documentation/master/#bitCast[#ä½è½¬æ¢]ï¼‰ã€‚

[source,zig]
----
    
include::{sourcedir}/03__data-fundamentals/alignment_and_casts.zig[]

----

.Run
[source,shell]
----
$ zig run alignment_and_casts.zig
----

.Output
[source,shell]
----
32-bit value = 0x11223344
bitcast copy = 0x11223344
truncate -> 0x44, widen -> 287454020
floatCast ratio -> 1.875
----

é€šè¿‡é“¾æ¥ `@alignCast`ã€`@ptrCast` ä¸ `@bitCast`ï¼Œä½ å¯ä»¥æ˜¾å¼æ–­è¨€å¸ƒå±€å…³ç³»ï¼›éšå `@truncate`/`@intCast` çš„è½¬æ¢åœ¨è·¨ API å˜çª„æˆ–åŠ å®½æ—¶ä¿æŒæ•´æ•°å®½åº¦çš„æ­£ç¡®æ€§ã€‚

[[notes-caveats]]
== è¯´æ˜ä¸æ³¨æ„äº‹é¡¹

* å“¨å…µç»ˆæ­¢æŒ‡é’ˆéå¸¸é€‚åˆ C æ¡¥æ¥ï¼Œä½†åœ¨ Zig å†…éƒ¨ä¼˜å…ˆé€‰æ‹©åˆ‡ç‰‡ï¼Œä»¥ä¾¿è¾¹ç•Œæ£€æŸ¥ä¿æŒå¯ç”¨ä¸” API æš´éœ²é•¿åº¦ã€‚
* ä½¿ç”¨ `@alignCast` æå‡æŒ‡é’ˆå¯¹é½åœ¨åœ°å€æœªå¯¹é½æ—¶ä»ä¼šåœ¨ Debug æ¨¡å¼è§¦å‘é™·é˜±â€”â€”åœ¨æå‡ä¹‹å‰è¯æ˜å‰ç½®æ¡ä»¶ã€‚
* å¤šé¡¹æŒ‡é’ˆï¼ˆ`pass:[[*\]T]`ï¼‰åˆ é™¤è¾¹ç•Œæ£€æŸ¥ï¼›è°¨æ…ä½¿ç”¨ï¼Œå¹¶è®°å½•å®‰å…¨åˆ‡ç‰‡ä¼šå¼ºåˆ¶çš„ä¸å˜é‡ã€‚

[[exercises]]
== ç»ƒä¹ 

* æ‰©å±• `arrays_and_slices.zig`ï¼Œä»è¿è¡Œæ—¶æ•°ç»„åˆ›å»ºé›¶é•¿åº¦å¯å˜åˆ‡ç‰‡ï¼Œç„¶åé€šè¿‡ `std.ArrayList` è¿½åŠ ï¼Œè§‚å¯Ÿåˆ‡ç‰‡è§†å›¾å¦‚ä½•ä¿æŒæœ‰æ•ˆã€‚
* ä¿®æ”¹ `sentinel_strings.zig`ï¼Œæ¥å—ç”¨æˆ·æä¾›çš„ `[:0]u8`ï¼Œé€šè¿‡è¿”å›é”™è¯¯è”åˆæ¥é˜²æ­¢ç¼ºå°‘å“¨å…µçš„è¾“å…¥ã€‚
* å¢å¼º `alignment_and_casts.zig`ï¼Œæ–°å¢åœ¨æˆªæ–­å‰æ‹’ç»ä½å­—èŠ‚ä¸ºé›¶çš„å€¼çš„åˆ†æ”¯ï¼Œå±•ç¤º `@intCast` å¦‚ä½•ä¾èµ–è°ƒç”¨è€…æä¾›çš„èŒƒå›´ä¿è¯ã€‚
